<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Quijoo" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      计算机基础 
      
      
      |
    
     Quijoo 记录
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 8.1.1"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Oranges</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">计算机基础</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2025-12-13 06:32:43
        </span>
        
      </div>
      <div class="markdown-body">
        <h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>计算机指令是机器码，是汇编码，是硬件软件交互界面；指令长度是CPU指令长度（例如：32<br>位&#x2F;64位）<br>常规的指令形式是 OP + Address * n;<br>指令字长和机器字长没有固定关系，通常有半指令字长，单指令字长，双指令字长，此外指令长度可以是固定的也可以是不定的，通常来说定长指令更易于处理</p>
<ol>
<li><p>零地址指令</p>
<ul>
<li>不需要操作数的指令(空操作，停机，关中断指令)，</li>
<li>堆栈计算机指令</li>
</ul>
</li>
<li><p>一地址指令</p>
<ul>
<li>$OP(A_1)\rightarrow A_1$(自增,自减,求反求补)</li>
<li>$(ACC)OP(A-1)\rightarrow ACC$, 隐含约定地址， 计算寻址范围</li>
</ul>
</li>
<li><p>二地址指令<br>算术指令，逻辑运算指令<br>指令含义 $(A_1)OP(A_2)\rightarrow A_1$</p>
</li>
<li><p>三地址指令<br>$(A_1)OP(A_2)\rightarrow A_3$, 如果地址均为主存地址， 完成该类指令需要四次访存(取指令 * 1， 取操作数<em>2， 存放结果</em>1)</p>
</li>
<li><p>四地址指令<br>最后一个地址 $A_4$ 是下一条将要执行的指令</p>
</li>
</ol>
<h2 id="指令扩展"><a href="#指令扩展" class="headerlink" title="指令扩展"></a>指令扩展</h2><p>虽然现代处理器采用大都采用定长指令，但是为了在此基础上保留指令的丰富类别，采用可变长操作码的定长指令；这意味着操作码位数长度不变，且分散在指令的不同位置，这将增加指令的译码难度，增加控制器复杂度。</p>
<h2 id="指令操作类型"><a href="#指令操作类型" class="headerlink" title="指令操作类型"></a>指令操作类型</h2><p><strong>数据传送</strong></p>
<ol>
<li>寄存器之间的传送(MOV)</li>
<li>从内存单元读取数据到CPU寄存器(LOAD)</li>
<li>从CPU寄存器写数据到内存单元(STORE)</li>
</ol>
<p><strong>算术和逻辑</strong><br>加(ADD)、 减(SUB)、 乘(MUL)、 除(DIV)、 比较(CMP)、 加1(INC)、 减1(DEC)、 与(AND)、或(OR)、 取反(NOT)、 亦或(XOR)</p>
<p><strong>移位操作</strong><br>算法移位、逻辑移位、循环移位</p>
<p><strong>转移操作</strong></p>
<ol>
<li>无条件转移(JMP)</li>
<li>条件转移(BRANCH)</li>
<li>调用(CALL)</li>
<li>返回(RET)</li>
<li>陷阱(TRAP)</li>
</ol>
<p><strong>输入输出操作</strong><br>完成 CPU 与外部设备交换数据或传送控制命令及状态信息</p>
<h2 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h2><p> ‘’ <strong>寻址方式</strong>是指寻找指令或指令操作数有效地址的方式 ‘’<br> 寻址方式分为<strong>指令寻址</strong>和<strong>数据寻址</strong>两类</p>
<p> 指令中数据字段代表的不是真实地址而是<strong>形式地址</strong>， 形式地址结合<strong>寻址方式</strong>可以计算真实地址<br> 如果 A 表示<strong>寄存器编号</strong>或者<strong>内存地址</strong>， 那么 (A) 表示其中保存的值</p>
<h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><ol>
<li>顺序寻址: 程序计数器PC++，自动形成下一条指令地址</li>
<li>跳跃寻址:<br>跳跃寻址的地址依然是由 PC 寄存器指出的， 指令跳跃收到 <strong>状态寄存器</strong> 和 <strong>操作数</strong>的控制，跳跃地址可以是直接由标记符得到，也可以由当前指令偏移得到；即 <strong>绝对地址</strong> 和 <strong>相对地址</strong></li>
</ol>
<h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><p>本质是如何在指令中 <strong>表示</strong> 操作数的地址，如何用这种表示计算出 <strong>操作数地址</strong></p>
<ol>
<li><p>隐含寻址<br>例如单地址指令中隐含的地址一样，操作数地址隐含在操作码的定义里</p>
</li>
<li><p>立即数寻址<br>补码表示操作数直接在指令中给出，例如 ADD 1 1<br> <strong>优点</strong> 是过程中不用访存<br> <strong>缺点</strong> 立即数长度限制了立即数范围</p>
</li>
<li><p>直接寻址<br>直接在指令中指出<strong>操作数地址</strong>的真实值<br> <strong>优点</strong> 是简单仅访问一次内存<br> <strong>缺点</strong> 是指令长度决定了地址的上限，操作数的地址修改不容易！</p>
</li>
<li><p>间接寻址<br>指令地址给出<strong>操作数地址</strong>所在<strong>储存单元的地址</strong>， 也就是需要一次间接寻址，间接寻址也可以是多次间接寻址，通过主存中取得的字的<strong>第一位</strong>的取值判断是否是取得操作数地址：</p>
<ul>
<li>取 0， 表示当前地址是操作数地址</li>
<li>取 1， 表示当前地址是操作数间址<br><strong>优点</strong> 扩大寻址范围，方便子程序返回<br><strong>缺点</strong> 多次访存， 一般扩大寻址地址的方法是寄存器间接寻址</li>
</ul>
</li>
<li><p>寄存器寻址<br>直接在指令字中给出操作数所在寄存器编号</p>
<p> <strong>优点</strong>  不访问主存，执行速度快， 支持向量矩阵运算<br> <strong>缺点</strong> 寄存器价格贵，数量有限</p>
</li>
<li><p>寄存器间接寻址<br>在指令字中给出寄存器编号，该寄存器内存储操作数的地址<br> <strong>优点</strong> 速度更快，用于扩展寻址范围<br> <strong>缺点</strong> 只能一次间址，需要访问主存</p>
</li>
<li><p>相对寻址<br>相对寻址是相对于 PC 上加上指令偏移量 A 而形成的有效地址，A 可正可负，补码表示<br> <strong>优点</strong> 操作数地址不固定，广泛用于<strong>转移指令</strong><br> <strong>缺点</strong> A 的位数决定寻址范围<br> <strong>注意</strong> PC 寄存器取下一条指令后自增，然后再加上偏移量</p>
</li>
<li><p>基址寻址<br>实际地址 EA &#x3D; (BR) + A，即基址 + 形式地址。基址寄存器是<strong>面向操作系统</strong>的，主要解决程序逻辑空间与储存器物理空间无关<br> <strong>优点</strong> 扩大寻址范围，利于多道程序设计，利于编写非线性程序（浮动程序），用于各种页表，段表实现<br> <strong>缺点</strong> 形式地址位数较短</p>
</li>
<li><p>变址寻址<br>变址寄存器寻址是 形式地址 A + 变址寄存器 IX，这里的变址寄存器区别于基址寄存器，是<strong>面向用户</strong>的，其中 IX 的位数足以表示整个存储空间<br><strong>优点</strong> 扩大寻址范围，便于编制循环程序，用于实现数组，因为指令中的 A 是<strong>固定的</strong>， 而IX是可以由用户设定的<br><strong>缺点</strong> A 不可变？硬找借口？ </p>
</li>
<li><p>堆栈寻址<br>堆栈是存储器(或专用寄存器)中一块特定的，后进先出的(LIFO) 原则管理的存储区，该存储区中 读&#x2F;写单元的地址使用一个特定<strong>寄存器SP</strong>给出的，硬堆栈&#x2F;软堆栈。<br><strong>硬堆栈</strong> 是寄存器堆栈，速度快，成本高，不适合做大容量堆栈<br><strong>软堆栈</strong> 是主存中划分的一段区域，速度稍慢，成本低，适合大容量</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">寻址方式</th>
<th align="center">有效地址</th>
<th align="center">访存次数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">隐含寻址</td>
<td align="center">程序指定</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">立即寻址</td>
<td align="center">A是操作数</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">直接寻址</td>
<td align="center">EA&#x3D;A</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">一次间接寻址</td>
<td align="center">EA&#x3D;(A)</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">寄存器寻址</td>
<td align="center">EA&#x3D;R_i</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">寄存器一次间接寻址</td>
<td align="center">EA&#x3D;(R_i)</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">相对寻址</td>
<td align="center">EA&#x3D;(PC)+A</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">基址寻址</td>
<td align="center">EA&#x3D;(BR)+A</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">变址寻址</td>
<td align="center">EA&#x3D;(IX)+A</td>
<td align="center">1</td>
</tr>
</tbody></table>
<h2 id="程序的机器码表示-汇编"><a href="#程序的机器码表示-汇编" class="headerlink" title="程序的机器码表示 - 汇编"></a>程序的机器码表示 - 汇编</h2><p>x86 处理器中包含8个32位通用寄存器</p>
<table>
<thead>
<tr>
<th align="center">寄存器名称</th>
<th align="center">位数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EAX</td>
<td align="center">32</td>
<td align="center">累加器(Accumulator)</td>
</tr>
<tr>
<td align="center">EBX</td>
<td align="center">32</td>
<td align="center">基址寄存器(Base Register)</td>
</tr>
<tr>
<td align="center">ECX</td>
<td align="center">32</td>
<td align="center">计数寄存器(Count Register)</td>
</tr>
<tr>
<td align="center">EDX</td>
<td align="center">32</td>
<td align="center">数据寄存器(Data Register)</td>
</tr>
<tr>
<td align="center">ESI</td>
<td align="center">32</td>
<td align="center">变址寄存器(Index Register)</td>
</tr>
<tr>
<td align="center">EDI</td>
<td align="center">32</td>
<td align="center">变址寄存器(Index Register)</td>
</tr>
<tr>
<td align="center">EBP</td>
<td align="center">32</td>
<td align="center">堆栈基指针(Base Pointer)</td>
</tr>
<tr>
<td align="center">ESP</td>
<td align="center">32</td>
<td align="center">堆栈顶指针(Stack Pointer)</td>
</tr>
</tbody></table>
<p><strong>说明</strong> 前四个寄存器 EAX, EBX, ECX, EDX 都是32位寄存器，但是可以仅仅访问其中的半字例如：($EAX &#x3D; AH + AL$), 除EBP和ESP外，其余寄存器的使用是比较任意的。</p>
<p>x64 汇编增加了几个寄存器和引入新的指令格式，在此仅学习 x86汇编。</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>vscode + MASM&#x2F;TASM 插件<br>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    MESG DB &quot;This is an Assembly Language Programe.&quot;, 0DH, 0AH, &quot;$&quot;</span><br><span class="line">    SPACE DB &quot; &quot;, &quot;$&quot;</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">    START:</span><br><span class="line">        MOV AX, DATA</span><br><span class="line">        MOV DS, AX              ; 将 DATA 段的段首址存入 DS</span><br><span class="line">        MOV BX, 01H             ; BX 初始值设为 1</span><br><span class="line">    AGAIN:</span><br><span class="line">        MOV DX, OFFSET MESG     ; 取欲显示的字符偏移量赋给 DX</span><br><span class="line">        MOV AH, 09H             ; 调用 9号(显示)DOS功能子程序</span><br><span class="line">        INT 21H</span><br><span class="line">        MOV CX, BX              ; 将 BX 的值赋给 CX</span><br><span class="line">        INC BX</span><br><span class="line">    NEXT:</span><br><span class="line">        MOV DX, OFFSET SPACE    ; 取空格字符偏移量赋给 DX</span><br><span class="line">        MOV AH, 09H</span><br><span class="line">        INT 21H</span><br><span class="line">        LOOP NEXT               ; 继续显示空格字符，直到 CX 为 0</span><br><span class="line">        CMP BX, 10              ; BX 与 10 比较</span><br><span class="line">        JBE AGAIN               ; 没显示 10 次，转移到 AGAIN 继续执行程序</span><br><span class="line">        MOV AH, 4CH</span><br><span class="line">        INT 21H                 ; 返回 DOS</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>

<p>右键 运行&#x2F;调试</p>
<h3 id="汇编指令格式"><a href="#汇编指令格式" class="headerlink" title="汇编指令格式"></a>汇编指令格式</h3><p>AT&amp;T格式和Intel格式区别如下</p>
<table>
<thead>
<tr>
<th align="center">项目&#x2F;区别</th>
<th align="center">AT&amp;T</th>
<th align="center">Intel</th>
</tr>
</thead>
<tbody><tr>
<td align="center">大小写</td>
<td align="center">小写</td>
<td align="center">大小写不敏感</td>
</tr>
<tr>
<td align="center">操作数</td>
<td align="center">第一个为源操作数,第二个为目的操作数</td>
<td align="center">第一个位目的操作数，第一个为源操作数</td>
</tr>
<tr>
<td align="center">前缀</td>
<td align="center">寄存器前缀%，立即数前缀$</td>
<td align="center">不需要前缀</td>
</tr>
<tr>
<td align="center">寻址</td>
<td align="center">使用”(“和”)”</td>
<td align="center">使用”[“ 和 “]”</td>
</tr>
<tr>
<td align="center">复杂寻址</td>
<td align="center">disp(base, index, scale), 表示偏移量，基址寄存器， 变址寄存器，比例因子;如 8(%edx, %eax, 2)</td>
<td align="center">[edx+eax*2+8]</td>
</tr>
<tr>
<td align="center">数据长度</td>
<td align="center">在操作码后边一个字符表示操作数大小 b-&gt;byte, w-&gt;word, l-&gt;long</td>
<td align="center">显式的注明byte ptr, word ptr, dword ptr</td>
</tr>
</tbody></table>
<p><strong>注意</strong> 由于32位或64位体系结构都是由16位扩展而来，因此用 word(字) 表示16位 </p>
<h3 id="常用机器指令"><a href="#常用机器指令" class="headerlink" title="常用机器指令"></a>常用机器指令</h3><p>汇编指令通常可以分为 <strong>数据传送指令</strong>， <strong>逻辑计算指令</strong>， <strong>控制流指令</strong><br>以下以** Intel 格式**为例介绍重要指令:<br><strong>约定</strong><br>&lt;reg32&gt; 表示eax,ebx,edx,….<br>&lt;reg16&gt; 表示ax, bx, dx<br>&lt;reg8&gt;   表示ah, al, bh,bl,…<br>&lt;mem&gt;  表示内存地址，如[eax]、[var+4]、dword ptr [eax+ebx]<br>&lt;con&gt;   表示8位、16位或32位常数</p>
<p><strong>mov 指令</strong><br>将 <strong>第二个操作数</strong>(寄存器，内存，常数内容) 复制到 <strong>第一个操作数</strong>(寄存器或内存)，不能用于内存到内存的复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">mov     &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">mov     &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">mov     &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">mov     &lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure>

<p><strong>push 指令</strong><br>将操作数压入内存的栈，常用于函数调用。ESP 是栈顶指针，压栈前 ESP-&#x3D;4，栈增长方向与内存地址增长方向相反，然后将操作数压入 ESP 指示的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push     &lt;reg32&gt;</span><br><span class="line">push     &lt;mem&gt;</span><br><span class="line">push     &lt;con32&gt;</span><br><span class="line">// 栈元素固定 32 位 eg:</span><br><span class="line">push     eax</span><br><span class="line">push     [var]</span><br></pre></td></tr></table></figure>

<p><strong>pop 指令</strong><br>将栈顶元素送出，pop指令将 ESP 地址内容出栈，再将 ESP 值加 4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop     edi</span><br><span class="line">pop     [ebx]</span><br></pre></td></tr></table></figure>

<p><strong>add&#x2F;sub 指令</strong><br>将两个操作数相加&#x2F;减，结果保存到第一个操作数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add     &lt;reg&gt;,&lt;reg&gt; / sub &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">add     &lt;reg&gt;,&lt;mem&gt; / sub &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">add     &lt;mem&gt;,&lt;reg&gt; / sub &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">add     &lt;reg&gt;,&lt;con&gt; / sub &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">add     &lt;mem&gt;,&lt;con&gt; / sub &lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure>

<p><strong>inc&#x2F;dec 指令</strong><br>操作数自增自减指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inc     &lt;reg&gt; / dec &lt;reg&gt;</span><br><span class="line">inc     &lt;mem&gt; / dec &lt;mem&gt;</span><br><span class="line">// eg:</span><br><span class="line">dec eax</span><br><span class="line">inc     dword ptr [var]</span><br></pre></td></tr></table></figure>

<p><strong>imul 指令</strong><br>带符号整数乘法指令，有两种形式 1. 两个操作数相加结果保存到<strong>第一个操作数</strong> 2. 三个操作数后两个数相加结果保存到<strong>第一个操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">imul     &lt;reg32&gt;,&lt;reg32&gt;</span><br><span class="line">imul     &lt;reg32&gt;,&lt;mem&gt;</span><br><span class="line">imul     &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;</span><br><span class="line">imul     &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;</span><br><span class="line">// tag: 这里显然不能存储到 &lt;mem&gt; 所以该过程最多只有一次非读指令访存</span><br><span class="line">//        如果乘法操作可能溢出，则编译器溢出标志 OF = 1，是CPU调溢出处理程序</span><br></pre></td></tr></table></figure>

<p><strong>idiv 指令</strong><br>带符号整数除法指令，他只有一个操作数，而被除数为 edx:eax中的内容（是拼接的64位整数），操作结果有两部分：商和余数，商-&gt;eax, 余数-&gt;edx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// (edx:eax) / op_1 = edx:eax</span><br><span class="line">idiv     &lt;reg32&gt;</span><br><span class="line">idiv     &lt;mem&gt;</span><br><span class="line">// eg:</span><br><span class="line">idiv     ebx</span><br><span class="line">idiv     dword ptr [var]</span><br></pre></td></tr></table></figure>

<p><strong>and&#x2F;or&#x2F;xor 指令</strong><br>结果放在第一个操作数里 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">and     &lt;reg&gt;,&lt;reg&gt; / or &lt;reg&gt;,&lt;reg&gt; / xor &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">and     &lt;reg&gt;,&lt;mem&gt; / or &lt;reg&gt;,&lt;mem&gt; / xor &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">and     &lt;mem&gt;,&lt;reg&gt; / or &lt;mem&gt;,&lt;reg&gt; / xor &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">and     &lt;reg&gt;,&lt;con&gt; / or &lt;reg&gt;,&lt;con&gt; / xor &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">and     &lt;mem&gt;,&lt;con&gt; / or &lt;mem&gt;,&lt;con&gt; / xor &lt;mem&gt;,&lt;con&gt;</span><br><span class="line">// eg:</span><br><span class="line">and     eax, 0fH</span><br><span class="line">xor     edx, edx</span><br></pre></td></tr></table></figure>

<p><strong>not 指令</strong><br>位反转指令，将操作数每一位反转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">not     &lt;reg&gt;</span><br><span class="line">not     &lt;mem&gt;</span><br><span class="line">// example:</span><br><span class="line">not     byte ptr [var]</span><br></pre></td></tr></table></figure>

<p><strong>neg 指令</strong><br>取负指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">neg     &lt;reg&gt;</span><br><span class="line">neg     &lt;mem&gt;</span><br><span class="line">// eg:</span><br><span class="line">neg     eax</span><br></pre></td></tr></table></figure>

<p><strong>shl&#x2F;shr 指令</strong><br>逻辑移位指令， l 为左， r 为右，第一个操作数是被移位，第二个操作数是移位位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shl     &lt;reg&gt;,&lt;con8&gt; / shr &lt;reg&gt;,&lt;con8&gt;</span><br><span class="line">shl     &lt;mem&gt;,&lt;con8&gt; / shr &lt;mem&gt;,&lt;con8&gt;</span><br><span class="line">shl     &lt;reg&gt;,&lt;cl&gt; / shr &lt;reg&gt;,&lt;cl&gt;</span><br><span class="line">shl     &lt;mem&gt;,&lt;cl&gt; / shr &lt;mem&gt;,&lt;cl&gt;</span><br><span class="line">// cl 是 8 位寄存器</span><br><span class="line">// eg：</span><br><span class="line">shl     eax, 1</span><br><span class="line">shr     ebx cl</span><br></pre></td></tr></table></figure>

<p><strong>标签</strong><br>IP 寄存器是 CPU 硬件结构，其值是不能直接指定的，只能通过控制流指令来更改，在 x86 汇编中使用标签来标记代码地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">            movesi, [ebp+8]</span><br><span class="line">begin:      xor ecx, ecx</span><br><span class="line">            mov eax, [esi]</span><br></pre></td></tr></table></figure>

<p><strong>jump 指令</strong><br>直接跳转类似 goto 语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp &lt;label&gt;</span><br><span class="line">// eg:</span><br><span class="line">jmp begin</span><br></pre></td></tr></table></figure>

<p><strong>j&lt;condition&gt; 指令</strong><br>条件转移指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">je      &lt;label&gt; (jump when equal)</span><br><span class="line">jne     &lt;label&gt; (jump when not equal)</span><br><span class="line">jz      &lt;label&gt; (jump when last result was zero)</span><br><span class="line">jg      &lt;label&gt; (jump when greater than)</span><br><span class="line">jge     &lt;label&gt; (jump when greater than or equal to)</span><br><span class="line">jl      &lt;label&gt; (jump when less than)</span><br><span class="line">jle     &lt;label&gt; (jump when less than or equal to)</span><br><span class="line">// eg:</span><br><span class="line">cmp eax, ebx</span><br><span class="line">jle done</span><br><span class="line">// tips:这里的跳转指令并不依赖某个寄存器的值，而是依赖 由cmp和test指令确定的 CPU 的状态值</span><br></pre></td></tr></table></figure>

<p><strong>cmp&#x2F;test 指令</strong><br>cmp 用于比较两个操作数的值，test 对两个数进行逐位与运算，他们不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmp     &lt;reg&gt;,&lt;reg&gt; / test &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">cmp     &lt;mem&gt;,&lt;reg&gt; / test &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">cmp     &lt;reg&gt;,&lt;mem&gt; / test &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">cmp     &lt;reg&gt;,&lt;con&gt; / test &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">// tips:cmp,test和jcondotion指令搭配使用，举例：</span><br><span class="line">cmp dword ptr [var], 10     // 比较 4 字节</span><br><span class="line">jne loop                              // 相等继续执行，否则跳转到loop </span><br><span class="line">test eax, eax                       // 测试eax 是否为0</span><br><span class="line">jz xxxx                                 // 为0则设置标志位 ZF 位1，跳转到 xxxx 处执行                               </span><br></pre></td></tr></table></figure>

<p><strong>call&#x2F;ret 指令</strong><br>用于实现子程序（过程，函数等）的调用和返回， call 指令将当前执行的指令地址<strong>入栈</strong>，然后<strong>无条件转移</strong>到有标签指示的指令。call指令还会保存调用之前的信息。 ret 实现了子程序的返回机制，ret 指令<strong>弹出栈中保存的指令地址</strong>，然后无条件<strong>转移到保存的指令地址</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call &lt;label&gt;</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<h3 id="过程调用机器表示"><a href="#过程调用机器表示" class="headerlink" title="过程调用机器表示"></a>过程调用机器表示</h3><p>使用 call&#x2F;ret 指令实现过程调用，假定过程<strong>P</strong>(调用者) 和 过程<strong>Q</strong>(被调用者)，过程调用步骤如下：</p>
<ul>
<li>P 将入口参数放在 Q 能访问到的地方</li>
<li>P 将返回地址存到特定的地方，然后将控制权转移到 Q (IP寄存器指向)</li>
<li>Q 保存 P 的现场(<strong>通用寄存器</strong>的内容)，并为自己的<strong>非静态局部变量</strong>分配空间</li>
<li>执行过程 Q</li>
<li>Q 回复 P 的现场，将结果放到 P 能访问到的地方，并释放局部变量所占空间</li>
<li>Q 取出返回地址，将控制转移到 P</li>
</ul>
<p><strong>注意   ：</strong> 上述步骤中需要为<strong>入口参数</strong>，<strong>返回地址</strong>，<strong>过程P现场</strong>，<strong>过程Q局部变量</strong>，<strong>返回结果</strong> 找到存放空间，而用户可见的寄存器数量是有限的，因此需要在内存中用一个栈来存放数据，EAX、ECX、EDX是<strong>调用者保存寄存器</strong>，其保存和恢复过程由P负责。EBX、ESI、EDI 是<strong>被调用则保存寄存器</strong>，每一个过程都有其自己的栈区，成为<strong>栈帧(Stack Frame)</strong>。寄存器 <strong>EBP指示栈底</strong>，<strong>ESP 指向栈顶</strong>，栈从高地址向低地址增长。</p>
<p><strong>例如</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用函数/过程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用者过程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">caller</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp1 = <span class="number">125</span>;</span><br><span class="line">    <span class="type">int</span> temp2 = <span class="number">80</span>;</span><br><span class="line">    <span class="type">int</span> sum = add(temp1, temp2);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 GCC 编译后 caller 过程的汇编码如下 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">    # stage 1</span><br><span class="line">    pushl       %ebp</span><br><span class="line">    movl        %esp, %ebp        # 系统栈 &amp;&amp; 用户栈</span><br><span class="line">                                  # ebp 和 esp 是 用户栈 指针</span><br><span class="line">                                  # 而 push 指令是对系统栈的操作</span><br><span class="line">                                  # 1. 将当前用户栈基址压入系统栈</span><br><span class="line">                                  # 2. 新用户栈基址设为栈顶指针</span><br><span class="line"></span><br><span class="line">    subl        $24, %esp         # 为当前过程开辟 24B 内存空间(栈帧)</span><br><span class="line">                                  # 此时 esp = ebp - 24，所以栈顶指针更小</span><br><span class="line">                                  # 这里 只用了 28B，是因为 GCC 规定栈帧必须是16B的整数倍</span><br><span class="line"></span><br><span class="line">    # stage 2 定义变量</span><br><span class="line">    movl        $125, -12(%ebp)   # 这里的变量是由 esp 向 ebp 方向依次放置</span><br><span class="line">    movl        $80, -8(%ebp)</span><br><span class="line"></span><br><span class="line">    # stage 3 传入函数参数</span><br><span class="line">    movl        -8(%ebp), %eax  </span><br><span class="line">    mov         %eax, 4(%esp)     # temp2 先入栈</span><br><span class="line">    movl        -12(%ebp), %eax    </span><br><span class="line">    movl        %eax, (%esp)      # temp1 后入栈</span><br><span class="line"></span><br><span class="line">    # stage 4 调用函数</span><br><span class="line">    call        add</span><br><span class="line"></span><br><span class="line">    # stage 5 取出函数返回值</span><br><span class="line">    movl        %eax, -4(%ebp)    # 将返回值取出到变量 sum</span><br><span class="line">    movl        -4(%ebp), %eax    # 将 sum 作为返回值</span><br><span class="line">                                  # 返回值是通过 eax 寄存器返回的，所以E(A|C|D)X寄存器是由调用者返回的</span><br><span class="line"></span><br><span class="line">    # stage 6 离开 add 函数</span><br><span class="line">    leave                         # 等价于：</span><br><span class="line">                                  # movl     %ebp, %esp</span><br><span class="line">                                  # popl     %ebp</span><br><span class="line"></span><br><span class="line">    # stage 7 退出当前 caller 过程</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>add 过程对应过程的汇编码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">push       %ebp</span><br><span class="line">mov        %esp, %ebp</span><br><span class="line">mov        0xc(%ebp), %eax          # 将参数2放入寄存器</span><br><span class="line">                                    # 这里的栈帧是有高位向低位</span><br><span class="line">                                    # 函数参数是从右往左入栈</span><br><span class="line"></span><br><span class="line">mov        0x8(%ebp), %edx          # 将参数1放入寄存器</span><br><span class="line"></span><br><span class="line">lea        (%edx, %eax, 1), %eax    # 将add_1传入add_2</span><br><span class="line">                                    # 这里是直接通过地址计算</span><br><span class="line">                                    # 使用 lea 指令是因为不占用 ALU，比较快</span><br><span class="line">                                    # 使用单指令代替了多条指令</span><br><span class="line">pop        %ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p><strong>Question</strong>：传入参数时是将参数的临时变量拷贝到了 4(%esp) 和 (%esp)，但是为什么在 add 过程中取参数时是取的 0xc(%ebp) 和 0x8(%ebp)？？</p>
<p><strong>Answer</strong>： 因为 call 指令会改变 esp 寄存器的值，会将函数返回地址入栈，然后 esp +&#x3D; 4</p>
<h3 id="选择语句机器表示"><a href="#选择语句机器表示" class="headerlink" title="选择语句机器表示"></a>选择语句机器表示</h3><p>以 c 语言为例，选择语句主要是 <strong>if-then</strong>, <strong>if-then-else</strong>, <strong>switch</strong>, 编译器条件码(标志位)设置指令各类转移指令来实现选择结构语句</p>
<ol>
<li><p><strong>条件码（标志位）</strong></p>
<p>条件码是CPU维护的状态寄存器，他们描述算术逻辑操作的<strong>属性</strong>，可以检测这些寄存器来执行分支指令：</p>
<p><strong>CF</strong> 进(借)位标志，适用于最近的无符号整数加减运算，有进(借)位 CF &#x3D; 1</p>
<p><strong>ZF</strong> 零标志，标志最近操作结果是否为0</p>
<p><strong>SF</strong> 符号标志，标志最近的带符号数运算结果，负 :SF &#x3D; 1</p>
<p><strong>OF</strong> 溢出标志，标志最近带符号数运算结果是否溢出</p>
<p>由于OF，SF对无符号数无意义， CF对带符号数无意义，常见的算术逻辑运算指令都会设置条件码</p>
</li>
<li><p><strong>IF 语句</strong></p>
<p>通用形式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(test_expr)</span><br><span class="line">    then_statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    else_statement</span><br></pre></td></tr></table></figure>

<p>翻译为 goto 语句形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test_expr;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">    <span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">then_statement</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">    else_statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>对于下面的 c 语言函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_count</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1 &gt; p2)</span><br><span class="line">        <span class="keyword">return</span> *p2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将得到以下汇编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movl     8(%ebp), %eax</span><br><span class="line">movl     12(%ebp), %edx</span><br><span class="line">cmpl     %edx %eax</span><br><span class="line">jbe      .L1</span><br><span class="line">movl     (%edx), %eax</span><br><span class="line">jmp      .L2</span><br><span class="line">.L1:</span><br><span class="line">movl     (%eax), %eax</span><br><span class="line">.L2:</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SWITCH 语句</strong></p>
<p>对于 <strong>小范围</strong> 和 <strong>小量</strong> 的选择语句，使用 <strong>跳转表</strong>，对于<strong>大范围</strong>或者<strong>大量</strong>的选择语句编译器还是会和 <strong>if-then-else</strong> 一样的方式来处理</p>
<p>跳转表即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.L12:</span><br><span class="line">    .long    .L3</span><br><span class="line">    .long    .L4</span><br><span class="line">    .long    .L5</span><br><span class="line">    .long    .L6</span><br><span class="line">    .long    .L7</span><br><span class="line">    .long    .L8</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样就可以通过 相对于 .L12 的<strong>偏移量</strong>来<strong>计算真实的跳转目的地了</strong>，这样的跳转只需一个指令来找到跳转目的，而不是多层的 if-else 嵌套，有点字典内味了。这也解释了为什么switch-case语句需要break来退出case，因为所有的case在<strong>地址上是连续</strong>的。</p>
<h3 id="循环语句机器表示"><a href="#循环语句机器表示" class="headerlink" title="循环语句机器表示"></a>循环语句机器表示</h3><p>常规的循环语句 有<strong>while</strong>,<strong>for</strong>, <strong>do-while</strong> 大多数编译器都将上述三种形式的循环语句转化为<strong>do-while</strong> 语句</p>
<p><strong>DO-WHILE 循环</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    body_statement</span><br><span class="line">    <span class="title function_">while</span><span class="params">(text_expr)</span></span><br></pre></td></tr></table></figure>

<p>goto 语句形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">    body_statement</span><br><span class="line">    t = test_expr;</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>

<p><strong>WHILE循环</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(test_expr)</span><br><span class="line">    body_statement</span><br></pre></td></tr></table></figure>

<p>在第一次执行循环体之前先执行一次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = test_expr;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    body_statement</span><br><span class="line">    <span class="title function_">while</span><span class="params">(text_expr)</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test_expr</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">    body_statement</span><br><span class="line">    t = test_expr;</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p><strong>FOR 循环</strong></p>
<p>一般形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init_expr; test_expr; update_expr)</span><br><span class="line">    body_statement</span><br></pre></td></tr></table></figure>

<p>转化为 while 循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init_expr;</span><br><span class="line"><span class="keyword">while</span>(test_expr)&#123;</span><br><span class="line">    body_statement</span><br><span class="line">    update_expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化为 goto 语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init_expr;</span><br><span class="line">t = test_expr;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    body_statement</span><br><span class="line">    update_expr;</span><br><span class="line">    t = test_expr;</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">done:   </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nsum_for</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        result += i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">==== 编译 ====&gt;</span><br><span class="line"></span><br><span class="line">movl        <span class="number">8</span>(%ebp), %ecx</span><br><span class="line">movl        $<span class="number">0</span>, %eax</span><br><span class="line">movl        $<span class="number">1</span>, %edx</span><br><span class="line">cmp         %edx, %ecx</span><br><span class="line">jg          .L2</span><br><span class="line">.L1:</span><br><span class="line">addl        %edx, %eax</span><br><span class="line">addl        $<span class="number">1</span>, %edx</span><br><span class="line">cmpl        %ecx, %edx</span><br><span class="line">jle         .L1</span><br><span class="line">.L2:</span><br></pre></td></tr></table></figure>

<p>直接按照模板即可</p>
<p>中央处理器(Central Processing Unit，简称CPU)</p>
<h2 id="CPU-功能和基本结构"><a href="#CPU-功能和基本结构" class="headerlink" title="CPU 功能和基本结构"></a>CPU 功能和基本结构</h2><h3 id="CPU-功能"><a href="#CPU-功能" class="headerlink" title="CPU 功能"></a>CPU 功能</h3><p><strong>指令控制</strong>（取指，分析，执行）</p>
<p><strong>操作控制</strong>一条指令执行，需要控制的各个门电路信号</p>
<p><strong>时间控制</strong> 系统时钟</p>
<p><strong>数据加工</strong> 算术逻辑运算</p>
<p><strong>中断处理</strong> 异常和特殊请求的处理</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>运算器</strong></p>
<p>算术逻辑单元，暂存寄存器，累加寄存器，通用寄存器组，程序状态字寄存器</p>
<p><strong>控制器</strong></p>
<p>程序计数器，指令寄存器，指令译码器，存储器地址寄存器，存储器数据寄存器</p>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="1-指令周期"><a href="#1-指令周期" class="headerlink" title="1. 指令周期"></a>1. 指令周期</h3><p><strong>取指周期</strong>： 从内存中读取指令</p>
<p>间址周期：取一次和多次间址</p>
<p>执行周期：</p>
<p>中断周期：每条指令执行完成后查询中断请求，如果有中断请求则进入中断周期</p>
<p>为了区别不同周期，使用标志触发器 FE, IND, EX, INT 表示各个周期，取 1 为有效值</p>
<h3 id="2-指令周期的数据流"><a href="#2-指令周期的数据流" class="headerlink" title="2. 指令周期的数据流"></a>2. 指令周期的数据流</h3><p>取指周期</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; MAR -&gt; 地址总线 -&gt; 主存</span><br><span class="line">CU读命令 -&gt; 控制总线 -&gt; 主存</span><br><span class="line">主存 -&gt; 数据总线 -&gt; MDR -&gt; IR</span><br><span class="line">CU控制信号 -&gt; PC+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>间地周期</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ad(IR) -&gt; MAR -&gt; 地址总线 -&gt; 主存</span><br><span class="line">CU 读命令 -&gt; 控制总线 -&gt; 主存</span><br><span class="line">主存 -&gt; 数据总线 -&gt;MDR</span><br></pre></td></tr></table></figure>

<p>中断周期</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CU控制SP<span class="number">-1</span>， SP-&gt;MAR-&gt;地址总线-&gt;主存</span><br><span class="line">CU写命令-&gt;控制总线-&gt;主存</span><br><span class="line">PC-&gt;MDR-&gt;数据总线-&gt;主存（存入断点）</span><br><span class="line">CU（中断服务程序入口） -&gt; PC</span><br></pre></td></tr></table></figure>

<h3 id="3-指令执行方案"><a href="#3-指令执行方案" class="headerlink" title="3. 指令执行方案"></a>3. 指令执行方案</h3><p>单周期：每条指令时钟周期数固定</p>
<p>多周期：每条指令使用不同周期数，但是指令只能一条执行完才能执行下一条</p>
<p>流水线：流水（参考MIPS 五级流水）</p>
<h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><h3 id="1-数据通路功能"><a href="#1-数据通路功能" class="headerlink" title="1. 数据通路功能"></a>1. 数据通路功能</h3><p>描述信息从什么地方开始，中间经过了哪些寄存器和开关，传送到哪个寄存器</p>
<h3 id="2-数据通路结构"><a href="#2-数据通路结构" class="headerlink" title="2. 数据通路结构"></a>2. 数据通路结构</h3><ul>
<li><p>CPU内单总线方式：所有东西通过公共同通路传输，冲突概率较高，性能低</p>
</li>
<li><p>CPU内三总线方式：提高效率，数据总线，地址总线，控制总线</p>
</li>
<li><p>专用数据通路方式：需要传送数据的地方直接安排连线，性能高，硬件量大</p>
</li>
</ul>
<p><strong>寄存器间数据传送</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; Bus</span><br><span class="line">Bus -&gt; MAR</span><br></pre></td></tr></table></figure>

<p><strong>主存 &amp; CPU 信息传送</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; Bus -&gt; MAR</span><br><span class="line"><span class="number">1</span> -&gt; <span class="function">R</span></span><br><span class="line"><span class="function"><span class="title">MEM</span>(<span class="params">MAR</span>) -&gt; MDR</span></span><br><span class="line"><span class="function">MDR -&gt; Bus -&gt; IR</span></span><br></pre></td></tr></table></figure>

<p><strong>执行算术逻辑运算</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ad(IR) -&gt; Bus -&gt; MAR</span><br><span class="line"><span class="number">1</span> -&gt; R</span><br><span class="line">MEM-&gt;数据线-&gt;MDR</span><br><span class="line">MDR -&gt; Bus -&gt;Y</span><br><span class="line">(ACC) + (Y) -&gt; Z</span><br><span class="line">Z -&gt; ACC </span><br></pre></td></tr></table></figure>

<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>计算机的五大功能部件 </p>
<ul>
<li><p>控制器部件</p>
</li>
<li><p>运算器部件</p>
</li>
<li><p>输入设备 &#x2F; 输出设备</p>
</li>
<li><p>内存储器</p>
</li>
</ul>
<p>他们之间通过 <strong>数据总线</strong>、<strong>地址总线</strong>、<strong>控制总线</strong> 相互通信，其中输入输出设备是通过<strong>接口电路</strong>连接的</p>
<ol>
<li><p>控制器部件从数据总线接受指令</p>
</li>
<li><p>从运算器不见接受<strong>指令转移</strong>地址</p>
</li>
<li><p>送出 <strong>指令地址</strong> 到 <strong>地址总线</strong></p>
</li>
<li><p>向系统中的部件提供运行所需的<strong>控制信号</strong></p>
</li>
</ol>
<hr>
<p><strong>控制器的主要功能：</strong></p>
<ul>
<li><p><strong>取指令</strong>和指出<strong>下一条指令的地址</strong></p>
</li>
<li><p>对指令进行<strong>译码</strong> 和 <strong>测试</strong>，以产生相应操作的<strong>控制信号</strong></p>
</li>
<li><p>指挥并控制 CPU、主存、输入输出设备之间的<strong>数据流动方向</strong></p>
</li>
</ul>
<p>根据控制器产生微操作控制信号的方式不同，分为<strong>硬布线控制器</strong> 和 <strong>微程序控制器</strong>， 其中 PC 和 IR 是相同的，但是确定和表示<strong>指令执行步骤</strong>的办法和需要的<strong>控制信号</strong>是不同的</p>
<h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><p>根据指令要求、当前时序、外部和内部状态，按时间顺序发送一系列<strong>微操作控制信号</strong>（也叫做组合逻辑控制器）。</p>
<p>区别于微程序控制器使用的微指令，<strong>硬布线控制器</strong>是直接采用组合逻辑电路实现<strong>机器指令</strong>，以 “<em>使用最少零部件，去的最高速度</em>” 作为设计目标，优点是<strong>速度快</strong>（电路延迟），缺点是<strong>不易添加新的功能</strong></p>
<ol>
<li><p>硬布线控制单元图</p>
<p>硬布线控制单元，从 CU 中分离出 <strong>操作码译码器</strong>， <strong>节拍发生器</strong>，其中操作译码器将 N 位操作码翻译为 $2^N$ 位， 再输入 CU。</p>
<p><strong>节拍发生器</strong> 产生的节拍(T1, T2, T3, …) 由 <strong>机器主频</strong>(CLK) 分频得到，CU 使用 <strong>操作码</strong>， <strong>节拍信号</strong>， <strong>状态标志</strong> 在不同的节拍输出不同的控制信号（微操作命令 $C_i$）</p>
<p><strong>使用节拍的原因</strong> 首先信号发出到稳定需要一个极短的时间间隔，所以 CPU 需要有一个最短时间（类似于我们的普朗克时间），其次，一个 <strong>机器指令</strong>，需要由多个微操作来完成，微操作按照<strong>一定的顺序</strong>生效，所以需要<strong>节拍</strong> 来区分微操作顺序 例如：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">操作A -&gt; 操作B -&gt; 操作C</span><br><span class="line"></span><br><span class="line">out = T1 * A + T2 * B + T3 * C</span><br></pre></td></tr></table></figure>

<p>按节拍顺序执行操作，总之技巧是<strong>通过逻辑组合控制各个开关,结合节拍器控制顺序（详见4）</strong></p>
</li>
<li><p>硬布线控制器的<strong>时序系统</strong>和<strong>微操作</strong></p>
<ul>
<li><p>时钟周期：时钟信号控制的节拍发生器，每个节拍的宽度正好是时钟周期，每个节拍内可以<strong>完成一个&#x2F;几个需要同时完成的操作</strong></p>
</li>
<li><p>机器周期：所有指令执行的<strong>基准时间</strong>（完成一个基本操作需要的时间），通常取存取周期作为基准时间，在存储字长等于指令字长时，存取周期 &#x3D; 机器周期</p>
<p>一个机器周期内，完成若干微操作，通过时钟信号控制产生每个微操作</p>
</li>
<li><p>指令周期：取出并执行一条指令的时间</p>
</li>
<li><p>微操作命令分析：指令分为三个周期 <strong>取值周期</strong>-&gt;<strong>间址周期</strong>-&gt;<strong>执行周期</strong></p>
<p><strong>取址</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PC       -&gt;     MAR</span><br><span class="line"><span class="number">1</span>        -&gt;     <span class="function">R</span></span><br><span class="line"><span class="function"><span class="title">M</span><span class="params">(MAR)</span>   -&gt;     MDR</span></span><br><span class="line"><span class="function">MDR      -&gt;     IR</span></span><br><span class="line"><span class="function"><span class="title">OP</span><span class="params">(IR)</span>   -&gt;     <span class="title">CU</span></span></span><br><span class="line"><span class="function"><span class="params">(PC)</span> + 1 -&gt;     PC</span></span><br></pre></td></tr></table></figure>

<p><strong>间址周期</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Ad</span>(IR)   -&gt;    MAR</span><br><span class="line"><span class="number">1</span>        -&gt;    <span class="function">R</span></span><br><span class="line"><span class="function"><span class="title">M</span><span class="params">(MAR)</span>   -&gt;    MDR</span></span><br></pre></td></tr></table></figure>

<p><strong>执行周期</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a. 非访存指令</span><br><span class="line">CLA    <span class="comment">// 清ACC</span></span><br><span class="line">COM    <span class="comment">// 取反</span></span><br><span class="line">SHR    <span class="comment">// 算术右移</span></span><br><span class="line">CSL    <span class="comment">// 循环左移</span></span><br><span class="line">STOP   <span class="comment">// 停机指令</span></span><br><span class="line">b. 访存指令</span><br><span class="line">ADD X  <span class="comment">// 加法指令</span></span><br><span class="line">Ad(IR) -&gt; MAR, <span class="number">1</span> -&gt; <span class="function">R</span></span><br><span class="line"><span class="function"><span class="title">M</span>(<span class="params">MAR</span>) -&gt; <span class="title">MDR</span></span></span><br><span class="line"><span class="function">(<span class="params">ACC</span>) + (<span class="params">MDR</span>) -&gt; ACC</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">STA X  <span class="comment">// 存数指令</span></span></span><br><span class="line"><span class="function"><span class="title">Ad</span>(<span class="params">IR</span>) -&gt; MAR, 1 -&gt; W</span></span><br><span class="line"><span class="function">ACC -&gt; MDR</span></span><br><span class="line"><span class="function">MDR -&gt; <span class="title">M</span>(<span class="params">MAR</span>)</span></span><br><span class="line"><span class="function">LDA X  <span class="comment">// 取数指令</span></span></span><br><span class="line"><span class="function"><span class="title">Ad</span>(<span class="params">IR</span>) -&gt; MAR, 1 -&gt; R</span></span><br><span class="line"><span class="function"><span class="title">M</span>(<span class="params">MAR</span>) -&gt; MDR</span></span><br><span class="line"><span class="function">MDR -&gt; ACC</span></span><br><span class="line"><span class="function">c. 转移指令</span></span><br><span class="line"><span class="function">JMP X</span>     =&gt;    Ad(IR) -&gt; PC</span><br><span class="line">BAN X     =&gt;    A0 * Ad(IR) + (~A0) * (PC) -&gt; PC</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CPU 控制方式</p>
<p>控制一条指令本质是依次执行一个确定的<strong>微操作序列</strong>， 不同指令对应的微操作<strong>数量</strong>和<strong>复杂度</strong>不一样,因此每条指令执行时间不相同，使用以下三种方法控制：</p>
<p><strong>同步控制</strong></p>
<p>所有控制信号都来自统一系统时钟，一<strong>最长</strong>微操作和<strong>最繁琐</strong>微操作为标准，采取<strong>统一</strong>、<strong>相同时间间隔</strong>、<strong>相同节拍数</strong> 作为机器周期来运行不同指令</p>
<p>特点：简单，速度慢（因为短命令也需要经过长周期）</p>
<p><strong>异步控制</strong></p>
<p>不存在 <em>基准信号</em>，各个部件按照自身固有速度工作，通过异步应答方式交流</p>
<p>特点：快速，控制复杂</p>
<p><strong>联合控制</strong></p>
<p>介于同步和异步之间，对不同的指令的微操作实行<strong>大部分采用同步控制</strong>，<strong>小部分采用异步控制</strong></p>
</li>
<li><p>硬布线控制单元设计步骤</p>
<p><strong>步骤一:</strong>  列出微操作命令时间表</p>
<p>以下是 CLR， COM， SHR 等10条机器指令微操作命令的时间表，观察表结构，共有<strong>工作周期标记</strong>、<strong>节拍</strong>、<strong>状态条件</strong>、<strong>微操作命令信号</strong>、<strong>微操作命令</strong>表项，其中一个工作周期可能包含多个节拍， 其中一个节拍内可以完成多个<strong>独立的微操作命令（不独立的命令会造成冲突）</strong></p>
<p><img src="https://xuaii.github.io/post-images/1662435646503.JPG"></p>
<p><img src="https://xuaii.github.io/post-images/1662435655639.JPG"></p>
<p><strong>步骤二:</strong>  微操作信号综合</p>
<p>$$<br>微操作控制信号 &#x3D; 机器周期 \land 节拍 \land 脉冲 \land 操作码 \land 机器状态条件<br>$$</p>
<p>根据表构造逻辑表达式，然后经过化简整理得到可用现有门电路实现的微操作命令逻辑表达式：</p>
<p><img src="https://xuaii.github.io/post-images/1662435665517.JPG"></p>
<p><strong>步骤三:</strong> 绘制微操作命令组合电路图（没什么技巧，就嗯画）</p>
<p><img src="https://xuaii.github.io/post-images/1662435671505.JPG"></p>
</li>
</ol>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>在电路和机器指令之间添加了一层<strong>微程序</strong>，根据机器指令生成<strong>微指令序列</strong>（微程序），使用微程序来实现机器指令功能，而微程序是存储在 <strong>控制存储器（CM in CPU）</strong> 中的指令序列，优点是<strong>规整</strong>、<strong>灵活</strong>、<strong>可维护</strong>，缺点是每次都要从 <strong>CM</strong> 中取微指令，<strong>速度慢</strong></p>
<ol>
<li><p>微程序控制<strong>基本概念</strong></p>
<p>就是把微操作信号 <strong>代码化</strong>， 使每条机器指令转化为一段微程序存入<strong>控制存储器</strong>中（CM），微程序包含若干微指令，每条微指令对应1&#x2F;n个微操作。</p>
<p><strong>微命令 &amp; 微操作</strong> ： 机器指令 -&gt; 微操作序列，在微程序控制计算机中，将控制部件向执行部件发送的<strong>控制命令</strong>称为<strong>微命令</strong>，例如：打开或关闭某个门电位信号，微操作是微命令的执行过程。</p>
<p>注意微命令的 <strong>相容</strong> 和 <strong>相斥</strong></p>
<p><strong>微指令 &amp; 微周期</strong>：微指令是若干微命令的集合（命令就是一位，指令就是一行），存放为微指令的控制存储器单元地址成为<strong>微地址</strong>，微指令包含两部分信息：</p>
</li>
</ol>
<ul>
<li><p>操作控制字段：控制信号</p>
</li>
<li><p>顺序控制字段：下一条微指令地址</p>
<p>微周期是指读取并执行一条微指令花费的时间</p>
<p> <strong>主存储器 &amp; 控制存储器</strong>：主存是在 CPU 外部的RAM， 控制存储器是在 CPU 内部的ROM</p>
<p> <strong>程序 &amp; 微程序</strong>： 微程序是机器指令的实时<strong>解释器</strong>，是在CPU 制造时预先设计和存储的，对程序员透明的</p>
<p> <strong>相关寄存器</strong>：<strong>地址寄存器(MAR)</strong>， <strong>微地址寄存器(CMAR)</strong>，<strong>指令寄存器(IR)</strong>，<strong>微指令寄存器(CMDR &#x2F; $\mu$IR)</strong></p>
</li>
</ul>
<ol start="2">
<li><p>微程序控制器<strong>组成</strong>和<strong>工作过程</strong></p>
<p><strong>组成</strong></p>
<p>控制存储器，微指令寄存器，微地址形成部件（产生最初地址和后继地址），微地址寄存器</p>
<p><img src="https://xuaii.github.io/post-images/1662435681568.png"></p>
<p><strong>工作过程</strong></p>
<p>取微指令公共操作 <strong>&#x3D;&#x3D;&gt;</strong> 机器开始时，自动将取指微程序入口地址送入 CMAR，并取址；一般时 CM 的 0号地址，该微程序完成后 主存中取出的机器指令就存储在 IR 中</p>
<p>IR 操作码 &#x3D;&#x3D;&gt; 微地址形成部件 &#x3D;&#x3D;&gt; 微程序入口地址 &#x3D;&#x3D;&gt; CMAR</p>
<p>从CM 中逐条取出指令并执行，执行完一段微程序后回到<strong>取址微程序入口</strong>，周而复始</p>
</li>
<li><p>微指令的<strong>编码方式</strong></p>
<p><strong>直接编码</strong> ： 无需译码，每一位表示一个微命令，简单直观快速，并行性好，缺点是控制存储器容量变大</p>
<p><strong>字段直接编码</strong>：将微指令的微命令分成若干<strong>小段</strong>，把互斥性微命令组合在同一字段，把相容性微命令组合在不同字段，每个字段独立编码，各个字段编码单独定义，互不干扰</p>
<p>优点：缩短字长</p>
<p>缺点：通过译码电路减速</p>
<p>分段原则</p>
<ul>
<li><p>互斥命令同段，相容命令不同段</p>
</li>
<li><p>每个段信息为不能太多</p>
</li>
<li><p>每个小段留出一个状态表示无命令（000），因此状态数 &#x3D; $2^N - 1$</p>
</li>
</ul>
<p><strong>字段间接编码</strong>：一个字段某些命令需要由另一些字段来解释，进一步减小了字长，削弱了并行能力，通常作为辅助手段</p>
</li>
<li><p>微指令的<strong>地址形成方式</strong></p>
<p>有两种基本类型</p>
<ul>
<li><p>直接由微指令的下地址字段指出（断定方式）</p>
</li>
<li><p>根据机器指令的操作码形成，通过微地址形成部件形成</p>
</li>
</ul>
<p>几种额外类型：</p>
<ul>
<li><p>增量计数 (CMAR) + 1 -&gt; CMAR, 连续存放</p>
</li>
<li><p>根据标志位决定微指令分支转移地址</p>
</li>
<li><p>通过测试网络形成</p>
</li>
<li><p>由硬件直接产生微程序入口地址</p>
</li>
</ul>
<p>加电后第一条微指令地址可以由专门的硬件电路产生</p>
</li>
<li><p>微指令的<strong>格式</strong></p>
<ul>
<li><p>水平型微指令： 指令中一位对应一个控制信号，优点：程序短，执行速度快；缺点：微指令长，编写微程序麻烦</p>
</li>
<li><p>垂直型微指令：采用类似机器指令的 操作数 | 操作码 | 操作码 的结构，优点：微指令短，简单，规整，便于编写；缺点是微程序长执行速度慢</p>
</li>
<li><p>混合型微指令：在垂直型的基础上增加一些不太复杂的并行操作，性能折中</p>
</li>
</ul>
</li>
<li><p>微程序<strong>控制单元</strong>的<strong>设计步骤</strong></p>
<p><strong>写出微操作命令的节拍安排</strong> 这里与之前的微操作表的区别是：</p>
<ul>
<li><p>取指阶段需要将 IR的操作码送往微地址形成部件, OP(IR) -&gt; CMAR</p>
</li>
<li><p>每条微指令执行完成后都需要形成后继微指令 , 微地址形成部件 -&gt; CMAR</p>
</li>
</ul>
<p><strong>确定微指令格式</strong> 微指令编码方式，后继指令形成方式，微指令字长</p>
<p>一般根据微操作个数决定编码方式，确定微指令操作控制字段位数，</p>
<p>由微指令数决定微指令顺序控制字段位数</p>
<p>按操作控制字段位数和顺序控制字段位数决定微指令字长</p>
</li>
<li><p><strong>动态微程序设计</strong>和<strong>毫微程序设计</strong></p>
<p>动态微程序就是可以更改的微程序，一般使用 EPROM，豪微程序试就是在微程序和电路之间再增加一层解释程序</p>
</li>
</ol>
<h2 id="异常和中断机制"><a href="#异常和中断机制" class="headerlink" title="异常和中断机制"></a>异常和中断机制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>异常</strong> 是 CPU 内部产生的意外事件，被称为内中断，是内部检测，与执行的指令相关的同步事件</p>
<p><strong>中断</strong> 是 CPU 发出的中断请求，被称为外中断，由外部设备触发，与当前执行指令无关</p>
<p>描述如下：</p>
<p>CPU 在执行用户程序<strong>第 i 条指令是检测到异常事件</strong> 或 <strong>第 i 条指令后发现一个中断请求信号</strong>，则 CPU 打断当前用户程序，然后转到相应的<strong>异常或中断处理程序</strong>去执行。</p>
<ul>
<li><p>若异常或中断处理程序能解决相应问题，则在处理程序的最后 CPU 指向异常或中断返回指令，回到被打断的用户程序第 i 条指令或 第 i + 1 条指令继续执行</p>
</li>
<li><p>若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序</p>
</li>
</ul>
<p>一般来说，对终端和异常的具体处理由操作系统（和驱动程序）完成</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>异常的分类</strong></p>
<ol>
<li><p>故障（Fault）：在故障指令启动后，指令结束前被检查到的异常事件，例如：<em>译码时出现非法操作码</em>；<em>取数据时发生缺页缺段</em>；<em>除数为0</em>；其中有的能通过磁盘调入主存来解决，像除数为0这样的异常不能解决并回到原断点继续执行，必须终止进程的执行</p>
</li>
<li><p>自陷（Trap）：是<strong>预先安排</strong>的一种异常，事先在程序中用一条特殊的指令或通过特殊标志的设定来人为造成陷阱，执行到被设置了陷阱的指令时，CPU 在执行完自陷指令后，自动根据不同陷阱进行相应处理，然后返回自陷指令的下一条执行。</p>
<p>特别的，如果当前指令是转移指令，那不会返回到下一条指令继续执行，而是返回到目标指令继续执行</p>
<p>例如：<strong>程序断点调试</strong>， <strong>系统调用指令</strong>，<strong>条件自陷指令</strong>都属于陷阱指令，执行到这些指令时，无条件的或有条件的<strong>自动调出操作系统内核程序</strong>进行执行</p>
<p><strong>故障异常</strong>和<strong>自陷异常</strong>属于<strong>程序性异常</strong></p>
</li>
<li><p>终止（Abort）：指令执行过程中发生了使计算机无法继续执行的硬件故障，如<strong>控制器出错</strong>，<strong>存储器校验错误</strong>等，程序无法继续执行，只能终止，此时调出中断服务程序来重启系统，这种异常和故障<strong>不由特定指令造成</strong>，而是<strong>随机发生</strong>的，属于硬件异常</p>
</li>
</ol>
<p><strong>中断的分类</strong></p>
<ol>
<li><p>可屏蔽中断：通过<strong>可屏蔽中断请求线INTR</strong>  向 CPU 发送的中断请求，CPU可通过在中断控制器中设置相应的屏蔽字来屏蔽或不屏蔽它，被屏蔽的中断请求不会送到 CPU</p>
</li>
<li><p>不可屏蔽中断：通过专门的 <strong>不可屏蔽中断请求线NMI</strong> 向 CPU 发出中断请求，通常是紧急的硬件故障，如电源掉电</p>
</li>
</ol>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>过程为 ： 关中断 -&gt; 保存断点和程序状态 -&gt; 识别异常和中断并转移到相应的处理程序</p>
<ul>
<li><p>**<strong>关中断</strong> </p>
<p>在保存断点和程序状态期间不能被新的中断打断，通过设置<strong>中断允许(IF)触发器</strong> 来实现禁止响应新的中断：</p>
</li>
<li><p>IF &#x3D;&#x3D; 1 开中断，允许响应中断</p>
</li>
<li><p>IF &#x3D;&#x3D; 0 关中断，不允许响应中断</p>
</li>
<li><p><strong>保存断点和程序状态</strong></p>
</li>
</ul>
<p>将程序断点（返回地址）送到栈或特定寄存器，通常保存在栈中（为了支持<strong>异常或中断的嵌套</strong>），状态字寄存器 PSWR 也需要保存到栈或者特定寄存器中。</p>
<ul>
<li><strong>识别异常和中断并转移到相应处理程序</strong></li>
</ul>
<p>异常大多数采用软件识别，中断由硬件识别和软件识别两种方式</p>
<p><strong>软件识别</strong>是 CPU 设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或终端查询程序，按优先级查询异常状态寄存器，以检查中断或异常的类型，先查询到的先处理，然后转到内核中相应处理程序</p>
<p><strong>硬件识别</strong>也就是<strong>向量中断</strong>，异常或中断程序的首地址称为<strong>中断向量</strong>，所有中断向量存放在<strong>中断向量表</strong>中，每个异常或中断都被指定一个<strong>中断类型号</strong>，在中断向量表中类型号和中断向量一一对应，因为可以根据类型号快速找到对应的处理程序。</p>
<p>中断或异常的响应是<strong>不可被打断</strong>的。中断响应结束后 CPU 就从 PC 中取出中断服务程序的第一条指令开始执行，直到中断返回，整个过程是由软硬件协同完成的</p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="*指令流水线"></a>*指令流水线</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>MIPS 指令流水将指令分成以下五个阶段，每一个时钟到来就会有一条指令进入流水</p>
<ul>
<li><p>取指(IF) 从存储器&#x2F;Cache中取指令（PC，指令寄存器，下一条指令地址计算逻辑）</p>
</li>
<li><p>译码(ID) 对指令进行译码，（操作控制器，去操作数逻辑，立即数符号扩展）</p>
</li>
<li><p>执行(EX) 执行运算&#x2F;计算地址，（ALU，分支地址计算模块）</p>
</li>
<li><p>访存(MEM) 访问存储器，（数据存储器读写模块）</p>
</li>
<li><p>写回(WB) 将计算结果写回寄存器堆， （寄存器写入控制模块）</p>
</li>
</ul>
<p>区分阶段的企图是，划分 CPU 运行过程中的阶段，分析他们的关联性方便<strong>同时多条指令在不同部件上</strong>运行</p>
<p>流水原则：流水阶段个数以最复杂指令所用的功能段个数为准，流水长度以最耗时操作花费时间为准</p>
<p>便于流水的<strong>指令集特征</strong>：</p>
<ul>
<li><p>指令长度尽量一致，简化取指，译码</p>
</li>
<li><p>指令格式尽量规整，比如第几位是寄存器编号，第几位是地址，这样方便指令未知时直接通过<strong>位数</strong>取操作数</p>
</li>
<li><p>采用 Load &#x2F; Store 指令，这样可以包访存指令的地址计算和运算指令的执行步骤规整在同一周期（不懂什么意思）</p>
</li>
<li><p>数据和指令对齐存放，减少访存次数</p>
</li>
</ul>
<p><strong>大量连续任务</strong>才能提高流水效率，流水<strong>延长单个指令</strong>执行时间，<strong>缩短整体</strong>执行时间</p>
<p><em>Tips:流水线需要多个锁存器来存储上一流水阶段的计算结果，控制信号，等来进行下一阶段计算</em></p>
<p><img src="https://xuaii.github.io/post-images/1662522792155.JPG"></p>
<h3 id="2-流水线冒险"><a href="#2-流水线冒险" class="headerlink" title="2. 流水线冒险"></a>2. 流水线冒险</h3><p><strong>结构冒险</strong> 多条指令同时访问同一资源（例如：存储器，取指和访存都要访问）</p>
<p>解决：</p>
<ul>
<li><p>访存时流水暂停</p>
</li>
<li><p>区分数据存储器 和 指令存储器（事实上 L1 cache 就是这样区分的）</p>
</li>
</ul>
<p><strong>数据冒险</strong></p>
<p>分为 <em>写后读</em>、 <em>读后写</em>、 <em>写后写</em> 三种</p>
<p>解决：</p>
<ul>
<li><p>流水暂停(stall，硬件实现), NOP空指令(编译器实现)</p>
</li>
<li><p>数据旁路技术（数据前推）</p>
</li>
<li><p>编译优化调整指令顺序</p>
</li>
</ul>
<p><strong>控制冒险</strong></p>
<p><em>指令跳转</em>、<em>调用过程</em>、<em>返回</em>等会改变 PC 寄存器值的指令，会导致<strong>控制冒险</strong></p>
<p>以前采用延迟槽方法（即在跳转指令后插入无论如何都要执行的指令），现代 CPU 都使用<strong>分支预测</strong>的方法，预测成功什么都不会发生，预测失败就<strong>清空流水线</strong></p>
<p>解决：</p>
<ul>
<li><p>分支预测 （分为动态和静态预测）</p>
</li>
<li><p>预取转移成功和不成功两个方向的指令</p>
</li>
<li><p>加快提前形成条件码</p>
</li>
<li><p>提高转移方向的<strong>猜准率</strong></p>
</li>
</ul>
<h3 id="3-性能指标"><a href="#3-性能指标" class="headerlink" title="3. 性能指标"></a>3. 性能指标</h3><p><strong>流水线吞吐率(TP)</strong></p>
<p>$$<br>TP &#x3D; \frac{n}{T_k} &#x3D; \frac{n}{(k+n-1)<em>\Delta t}\<br>TP_{max} &#x3D; \lim\limits_{n\rightarrow\infty}\frac{n}{(k+n-1)</em>\Delta t} &#x3D; \frac{1}{\Delta t}<br>$$</p>
<p><strong>流水线加速比(S)</strong></p>
<p>$$<br>S &#x3D; \frac{T_0}{T_k} &#x3D; \frac{kn\Delta t}{(k+n-1)<em>\Delta t}\<br>S_{max} &#x3D; \lim\limits_{n\rightarrow\infty}\frac{kn\Delta t}{(k+n-1)</em>\Delta t} &#x3D; k<br>$$</p>
<p>其中，n 是指令数量， k 是流水阶段数， $\Delta t$ 是时钟周期</p>
<h3 id="4-高级流水线技术"><a href="#4-高级流水线技术" class="headerlink" title="4. 高级流水线技术"></a>4. 高级流水线技术</h3><p>处理机一次发射多条指令的<strong>多发射技术</strong>，增加流水线级数的<strong>超流水线技术</strong></p>
<p>超标量流水线技术：不能调整指令执行顺序，并行执行指令搭配</p>
<p>超长指令字技术：也称静态多发射技术，编译程序挖掘程序潜在并行性，将多条能并行的指令组合成一条具有多个操作码的指令（几百位），需要多个部件处理</p>
<p>超流水线技术：增加级数，每级的操作量减小，纳闷呢时钟周期就可以减小，但是依然是一个周期进入一条指令，总的来讲效率提高</p>
<h2 id="多处理器基本概念"><a href="#多处理器基本概念" class="headerlink" title="多处理器基本概念"></a>多处理器基本概念</h2><h3 id="SISD、SIMD、MIMD"><a href="#SISD、SIMD、MIMD" class="headerlink" title="SISD、SIMD、MIMD"></a>SISD、SIMD、MIMD</h3><p><strong>SISD</strong> 是传统的串行计算机结构，包含一个处理器一个存储器，指令按规定顺序执行，SISD 为了提高效率采用流水的方式，之前的内容大都是 SISD 结构</p>
<p><strong>SIMD</strong> 是指一个指令同时对多个数据流进行处理，成为<strong>数据级并行技术</strong>，通常由<strong>一个指令控制部件</strong>、<strong>多个处理单元</strong>组成，每个单元执行同一条指令，但每个处理单元都有自己的地址寄存器，因此每个单元都有不同的数据地址，因此，<strong>不同处理单元在不同数据集上执行相同的指令</strong>。</p>
<p>一个应用程序被编译后可能按SISD在串行硬件上执行，也可能按SIMD 组织并运行于并行硬件上</p>
<p>SIMD 在使用 for 循环处理数组时最有效，例如：对16对数据进行运算的 SIMD 指令如果在16个ALU中同时运算，只需要一次运算时间就能完成。SIMD 在使用 case-switch 语句时效率最低，此时每个执行单元必须<strong>根据不同数据执行不同操作</strong>。</p>
<p><strong>MISD</strong> 是同时执行多条指令，处理同一个数据，实际上不存在这样的计算机</p>
<p><strong>MIMD</strong> 同时执行多条指令处理不同数据，分为<strong>多计算机系统</strong> 和 <strong>多处理器系统</strong></p>
<p>多计算机系统中每个计算机节点都具有各自私有的存储器，和独立的主存空间，不能相关通过存取指令访问。需要通过消息传递进行数据传送。</p>
<p>多处理器系统是<strong>共享多处理器系统SMP</strong>的简称，它共享单一地址空间，通过存取指令访问多有存储器</p>
<h3 id="硬件多线程"><a href="#硬件多线程" class="headerlink" title="硬件多线程"></a>硬件多线程</h3><p>目的减小线程切换开销</p>
<ol>
<li><p>细粒度多线程</p>
<p>多个线程之间轮流交换执行指令，线程间指令不相关，可以乱序并行执行。处理器能在<strong>每个时钟周期</strong>切换线程</p>
</li>
<li><p>粗粒度多线程</p>
<p>在线程出现较大开销阻塞时切换线程，如 cache 缺失。这种情况下，当发生流水阻塞时，必须清除被阻塞的流水线，新的线程指令开始执行前需要重载流水线，因此开销很大</p>
</li>
<li><p>同时多线程（SMT）</p>
<p>是上述两种多线程技术的变体。在实现指令级并行的同时，实现线程级并行，也就是说，在一个时钟周期内，发射多个不同线程中的多条指令执行。Intel 中的<strong>超线程技术</strong>就是同时对线程，即在一个单处理器或单个核中设置两套线程状态部件，共享高速缓存和功能部件。</p>
</li>
</ol>
<h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><p>多个处理单元集成到单个CPU，每个核可以有自己的 cache，也可以共享 cache，共享主存储器</p>
<h3 id="共享内存多处理器"><a href="#共享内存多处理器" class="headerlink" title="共享内存多处理器"></a>共享内存多处理器</h3><p>通过存储器中的共享变量相互通信，可以在各个处理器自己的虚拟地址空间单独运行</p>
<ul>
<li><p>统一存储访问（UMA）多处理器：分为<strong>基于总线</strong>，<strong>基于交叉开关网络</strong>，<strong>基于多级交换网络</strong> 连接等几种处理器</p>
</li>
<li><p>非统一存储访问（NUMA）多处理器：处理器中不带高速缓存时被称为 NC-NUMA，带有一致性高速缓存时被称为 CC-NUMA</p>
</li>
</ul>
<p>最初内存控制器没有整合进 CPU， 需要通过北桥的内存控制器访问内存，这种架构随着 多核 CPU 的发展而达到瓶颈（争用前端总线），所以NUMA 架构诞生，每个 CPU 分配一个内存区域，而 CPU 之间通过 QPI 总线相连，CPU 通过 QPI 访问其他CPU的远程内存。</p>
<p>由于内存共享， 对于共享变量需要使用同步机制，例如对变量加锁 3</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/06/02/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%8A%80%E6%9C%AF/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2025-12-13 06:32:43
            </span>
            
          </div>
          <div class="post-foot-prev">
            
              <a href="/2024/06/02/%E4%B8%80%E7%A7%8D%E7%BC%93%E5%8A%A8%E6%9B%B2%E7%BA%BF/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-text">指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A9%E5%B1%95"><span class="toc-text">指令扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="toc-text">指令操作类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">指令寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-text">指令寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-text">数据寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81%E8%A1%A8%E7%A4%BA-%E6%B1%87%E7%BC%96"><span class="toc-text">程序的机器码表示 - 汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">环境配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-text">汇编指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">常用机器指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%99%A8%E8%A1%A8%E7%A4%BA"><span class="toc-text">过程调用机器表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5%E6%9C%BA%E5%99%A8%E8%A1%A8%E7%A4%BA"><span class="toc-text">选择语句机器表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E6%9C%BA%E5%99%A8%E8%A1%A8%E7%A4%BA"><span class="toc-text">循环语句机器表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">CPU 功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E5%8A%9F%E8%83%BD"><span class="toc-text">CPU 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-text">1. 指令周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">2. 指令周期的数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="toc-text">3. 指令执行方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">数据通路的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%8A%9F%E8%83%BD"><span class="toc-text">1. 数据通路功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%BB%93%E6%9E%84"><span class="toc-text">2. 数据通路结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">硬布线控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">微程序控制器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-text">异常和中断机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94"><span class="toc-text">响应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">*指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%92%E9%99%A9"><span class="toc-text">2. 流水线冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">3. 性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%AB%98%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-text">4. 高级流水线技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">多处理器基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SISD%E3%80%81SIMD%E3%80%81MIMD"><span class="toc-text">SISD、SIMD、MIMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">硬件多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">多核处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">共享内存多处理器</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80 + '&url=' + http%3A%2F%2Fdev.quijoo.site%3A8002%2F2024%2F06%2F02%2F%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%259F%25BA%25E7%25A1%2580%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://dev.quijoo.site:8002/2024/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
