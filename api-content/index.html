{"posts":[{"title":"一个基于内网穿透的网络房间","content":"突发奇想，希望做一个P2P的应用，应该是快速和低延迟的，或许用于传输文件，或许用于语音，聊天。 使用 c++ zmq 来实现内网穿透和数据传输，然后以广播模式将数据广播。使用 python 写处理数据的线程。 房间 房间的实体在服务端，客户端可以使用命令创建房间，服务端返回房间号。将房间号分享给另一个客户端，另一个客户端使用命令加入房间。 成功加入房间后的客户端开启两个新的线程（接受/发送）。在 python 端实现具体的协议。 房间可以设置模式 1 v 1 模式，两个客户端，相互发送信息 n v n 模式，这个处理比较复杂 如果共有 n 个客户端在房间中，那么每个客户端的发送线程都是广播，每个客户端需要有 n - 1个接受线程（有点离谱了，卧槽），如果是基于服务器的，那么应该在服务器端实现数据综合，但是 p2p要么选择一个主客户端充当服务器，要么就硬转发。（tips:先实现1v1模式吧 首先需要使用可靠传输，并且是基于 UDP 的可靠传输，那么就不能使用 ZMQ(base on TCP) 修改方案为： 那就不保证可靠传输，而是基于 UDP 在python 端实现可靠传输，为了实现跨平台 socket 库使用 别人封装好的 CppSockets Client: socket_recv ----&gt; zmq_broadcast ----&gt; python_recv | | v socket_send----&gt; zmq_recv --------&gt; python_reply ","link":"https://xuaii.github.io/post/yi-ge-ji-yu-nei-wang-chuan-tou-de-wang-luo-fang-jian/"},{"title":"[转载] P2P内网穿透技术","content":"原文 当今互联网到处存在着一些中间件(Middle Boxes),如NAT和防火墙,导致两个(不在同一内网)中的客户端无法直接通信. 这些问题即便是到了IPV6时代也会存在,因为即使不需要NAT,但还有其他中间件如防火墙阻挡了链接的建立. 目前部署的中间件多都是在C/S架构上设计的,其中相对隐匿的客户机主动向周知的服务端(拥有静态IP地址和DNS名称)发起链接请求. 大多数中间件实现了一种非对称的通讯模型,即内网中的主机可以初始化对外的链接,而外网的主机却不能初始化对内网的链接, 除非经过中间件管理员特殊配置. 前言 在中间件为常见的NAPT的情况下（也是本文主要讨论的）,内网中的客户端没有单独的公网IP地址, 而是通过NAPT转换,和其他同一内网用户共享一个公网IP. 这种内网主机隐藏在中间件后的不可访问性对于一些客户端软件如浏览器来说 并不是一个问题,因为其只需要初始化对外的链接,从某方面来看反而还对隐私保护有好处. 然而在P2P应用中, 内网主机（客户端）需要对另外的终端（Peer）直接建立链接,但是发起者和响应者可能在不同的中间件后面, 两者都没有公网IP地址. 而外部对NAT公网IP和端口主动的链接或数据都会因内网未请求被丢弃掉. 本文讨论的就是如何跨越NAT实现内网主机直接通讯的问题. 一些术语 防火墙(Firewall) 防火墙主要限制内网和公网的通讯,通常丢弃未经许可的数据包. 防火墙会检测(但是不修改)试图进入内网数据包的IP地址和TCP/UDP端口信息. 网络地址转换器(NAT) NAT不止检查进入数据包的头部,而且对其进行修改,从而实现同一内网中不同主机共用更少的公网IP（通常是一个）. 基本NAT(Basic NAT) 基本NAT会将内网主机的IP地址映射为一个公网IP,不改变其TCP/UDP端口号. 基本NAT通常只有在当NAT有公网IP池的时候才有用. 网络地址-端口转换器(NAPT) 到目前为止最常见的即为NAPT,其检测并修改出入数据包的IP地址和端口号,从而允许多个内网主机同时共享一个公网IP地址. 锥形NAT(Cone NAT) 在建立了一对（公网IP,公网端口）和（内网IP,内网端口）二元组的绑定之后,只要还有一个会话还是激活的,Cone NAT会重用这组绑定用于接下来该应用程序的所有会话（同一内网IP和端口）. 例如,假设客户端A建立了两个连续的对外会话,从相同的内部端点（10.0.0.1:1234）到两个不同的外部服务端S1和S2. Cone NAT只为两个会话映射了一个公网端点（155.99.25.11:62000）, 确保客户端端口的“身份”在地址转换的时候保持不变. 由于基本NAT和防火墙都不改变数据包的端口号,因此这些类型的中间件也可以看作是退化的Cone NAT. Server S1 Server S2 18.181.0.31:1235 138.76.29.7:1235 | | | | +----------------------+----------------------+ | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 155.99.25.11:62000 v | v 155.99.25.11:62000 v | Cone NAT 155.99.25.11 | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 10.0.0.1:1234 v | v 10.0.0.1:1234 v | Client A 10.0.0.1:1234 其中Cone NAT根据NAT如何接收已经建立的（公网IP,公网端口）对的输入数据还可以细分为以下三类： 1. 全锥形NAT(Full Cone NAT) 在一个新会话建立了公网/内网端口绑定之后,全锥形NAT接下来会接受对应公网端口的所有数据,无论是来自哪个（公网）终端. 全锥NAT有时候也被称为“混杂”NAT（promiscuous NAT）. 2. 受限锥形NAT(Restricted Cone NAT) 受限锥形NAT只会转发符合某个条件的输入数据包. 条件为：外部（源）IP地址匹配内网主机之前发送一个或多个数据包的结点的IP地址. AT通过限制输入数据包为一组“已知的”外部IP地址,有效地精简了防火墙的规则. 3. 端口受限锥形NAT(Port-Restricted Cone NAT) 端口受限锥形NAT也类似,只当外部数据包的IP地址和端口号都匹配内网主机发送过的地址和端口号时才进行转发. 端口受限锥形NAT为内部结点提供了和对称NAT相同等级的保护,以隔离未关联的数据. 4. 对称NAT(Symmetric NAT) 对称NAT正好相反,不在所有公网-内网对的会话中维持一个固定的端口绑定. 其为每个新的会话开辟一个新的端口. 如下图所示： Server S1 Server S2 18.181.0.31:1235 138.76.29.7:1235 | | | | +----------------------+----------------------+ | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 155.99.25.11:62000 v | v 155.99.25.11:62001 v | Symmetric NAT 155.99.25.11 | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 10.0.0.1:1234 v | v 10.0.0.1:1234 v | Client A 10.0.0.1:1234 P2P通信技术 根据客户端的不同,客户端之间进行P2P传输的方法也略有不同,这里介绍了现有的穿越中间件进行P2P通信的几种技术. 中继（Relaying） 这是最可靠但也是最低效的一种P2P通信实现. 其原理是通过一个有公网IP的服务器中间人对两个内网客户端的通信数据进行中继和转发. 如下图所示： Server S | | +----------------------+----------------------+ | | NAT A NAT B | | | | Client A Client B 客户端A和客户端B不直接通信,而是先都与服务端S建立链接,然后再通过S和对方建立的通路来中继传递的数据. 这钟方法的缺陷很明显, 当链接的客户端变多之后,会显著增加服务器的负担,完全没体现出P2P的优势. 但这种方法的好处是能保证成功,因此在实践中也常作为一种备选方案. 逆向链接（Connection reversal） 第二种方法在当两个端点中有一个不存在中间件的时候有效. 例如,客户端A在NAT之后而客户端B拥有全局IP地址,如下图： Server S 18.181.0.31:1235 | | +----------------------+----------------------+ | | NAT A | 155.99.25.11:62000 | | | | | Client A Client B 10.0.0.1:1234 138.76.29.7:1234 客户端A内网地址为10.0.0.1,且应用程序正在使用TCP端口1234. A和服务器S建立了一个链接,服务器的IP地址为18.181.0.31,监听1235端口. NAT A给客户端A分配了TCP端口62000,地址为NAT的公网IP地址155.99.25.11, 作为客户端A对外当前会话的临时IP和端口. 因此S认为客户端A就是155.99.25.11:62000. 而B由于有公网地址,所以对S来说B就是138.76.29.7:1234. 当客户端B想要发起一个对客户端A的P2P链接时,要么链接A的外网地址155.99.25.11:62000,要么链接A的内网地址10.0.0.1:1234,然而两种方式链接都会失败. 链接10.0.0.1:1234失败自不用说,为什么链接155.99.25.11:62000也会失败呢？来自B的TCP SYN握手请求到达NAT A的时候会被拒绝,因为对NAT A来说只有外出的链接才是允许的. 在直接链接A失败之后,B可以通过S向A中继一个链接请求,从而从A方向“逆向“地建立起A-B之间的点对点链接. 很多当前的P2P系统都实现了这种技术,但其局限性也是很明显的,只有当其中一方有公网IP时链接才能建立. 越来越多的情况下, 通信的双方都在NAT之后,因此就要用到我们下面介绍的第三种技术了. UDP打洞（UDP hole punching） 第三种P2P通信技术,被广泛采用的,名为“P2P打洞“. P2P打洞技术依赖于通常防火墙和Cone NAT允许正当的P2P应用程序在中间件中打洞且与对方建立直接链接的特性. 下面主要考虑两种常见的场景,以及应用程序如何设计去完美地处理这些情况. 第一种场景代表了大多数情况,即两个需要直接链接的客户端处在两个不同的NAT之后； 第二种场景是两个客户端在同一个NAT之后,但客户端自己可能并不知道(比如同一ISP下面的不同子网). 端点在不同的NAT之后 假设客户端A和客户端B的地址都是内网地址,且在不同的NAT后面. A、B上运行的P2P应用程序和服务器S都使用了UDP端口1234,A和B分别初始化了 与Server的UDP通信,地址映射如图所示: Server S 18.181.0.31:1234 | | +----------------------+----------------------+ | | NAT A NAT B 155.99.25.11:62000 138.76.29.7:31000 | | | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 现在假设客户端A打算与客户端B直接建立一个UDP通信会话. 如果A直接给B的公网地址138.76.29.7:31000发送UDP数据,NAT B将很可能会无视进入的 数据（除非是Full Cone NAT）,因为源地址和端口与S不匹配,而最初只与S建立过会话. B往A直接发信息也类似. 假设A开始给B的公网地址发送UDP数据的同时,给服务器S发送一个中继请求,要求B开始给A的公网地址发送UDP信息. A往B的输出信息会导致NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话,B往A亦然. 一旦新的UDP会话在两个方向都打开之后,客户端A和客户端B就能直接通讯, 而无须再通过引导服务器S了. UDP打洞技术有许多有用的性质. 一旦一个的P2P链接建立,链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞, 极大减少了服务器的负载. 应用程序不需要知道中间件具体是什么（如果有的话）,因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路. 端点在相同的NAT之后 现在考虑这样一种情景,两个客户端A和B正好在同一个NAT之后（而且可能他们自己并不知道）,因此在同一个内网网段之内. 客户端A和服务器S建立了一个UDP会话,NAT为此分配了公网端口62000,B同样和S建立会话,分配到了端口62001,如下图： Server S 18.181.0.31:1234 | | NAT A-S 155.99.25.11:62000 B-S 155.99.25.11:62001 | +----------------------+----------------------+ | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 假设A和B使用了上节介绍的UDP打洞技术来建立P2P通路,那么会发生什么呢？首先A和B会得到由S观测到的对方的公网IP和端口号,然后给对方的地址发送信息. 两个客户端只有在NAT允许内网主机对内网其他主机发起UDP会话的时候才能正常通信,我们把这种情况称之为&quot;回环传输“(loopback transmission),因为从内部 到达NAT的数据会被“回送”到内网中而不是转发到外网. 例如,当A发送一个UDP数据包给B的公网地址时,数据包最初有源IP地址和端口地址10.0.0.1:1234和 目的地址155.99.25.11:62001,NAT收到包后,将其转换为源155.99.25.11:62000（A的公网地址）和目的10.1.1.3:1234,然后再转发给B. 即便NAT支持 回环传输,这种转换和转发在此情况下也是没必要的,且有可能会增加A与B的对话延时和加重NAT的负担. 对于这个情况,优化方案是很直观的. 当A和B最初通过S交换地址信息时,他们应该包含自身的IP地址和端口号（从自己看）,同时也包含从服务器看的自己的 地址和端口号. 然后客户端同时开始从对方已知的两个的地址中同时开始互相发送数据,并使用第一个成功通信的地址作为对方地址. 如果两个客户端在同一个 NAT后,发送到对方内网地址的数据最有可能先到达,从而可以建立一条不经过NAT的通信链路；如果两个客户端在不同的NAT之后,发送给对方内网地址的数据包 根本就到达不了对方,但仍然可以通过公网地址来建立通路. 值得一提的是,虽然这些数据包通过某种方式验证,但是在不同NAT的情况下完全有可能会导致A往B 发送的信息发送到其他A内网网段中无关的结点上去的. 端点在多级NAT之后 在一些拓朴结构中,可能会存在多级NAT设备,在这种情况下,如果没有关于拓朴的具体信息, 两个Peer要建立“最优”的P2P链接是不可能的,下面来说为什么. 以下图为例： Server S 18.181.0.31:1234 | | NAT X A-S 155.99.25.11:62000 B-S 155.99.25.11:62001 | | +----------------------+----------------------+ | | NAT A NAT B 192.168.1.1:30000 192.168.1.2:31000 | | | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 假设NAT X是一个网络提供商ISP部署的工业级NAT,其下子网共用一个公网地址155.99.25.11,NAT A和NAT B分别是其下不同用户的网关部署的NAT. 只有服务器S 和NAT X有全局的路由地址. Client A在NAT A的子网中,同时Client B在NAT B的子网中,每经过一级NAT都要进行一次网络地址转换. 现在假设A和B打算建立直接P2P链接,用一般的方法（通过Server S来打洞）自然是没问题的,那能不能优化呢？一种想当然的优化办法是A直接把信息发送给NAT B的 内网地址192.168.1.2:31000,且B通过NAT B把信息发送给A的路由地址192.168.1.1:30000,不幸的是,A和B都没有办法得知这两个目的地址,因为S只看见了客户端 ‵全局‵地址155.99.25.11. 退一步说,即便A和B通过某种方法得知了那些地址,我们也无法保证他们是可用的. 因为ISP分配的子网地址可能和NAT A B分配的子网地址 域相冲突. 因此客户端没有其他选择,只能使用S来进行打洞并进行回环传输. 固定端口绑定 UDP打洞技术有一个主要的条件：只有当两个NAT都是Cone NAT（或者非NAT的防火墙）时才能工作. 因为其维持了一个给定的（内网IP,内网UDP）二元组 和（公网IP, 公网UDP）二元组固定的端口绑定,只要该UDP端口还在使用中,就不会变化. 如果像对称NAT一样,给每个新会话分配一个新的公网端口,就 会导致UDP应用程序无法使用跟外部端点已经打通了的通信链路. 由于Cone NAT是当今最广泛使用的,尽管有一小部分的对称NAT是不支持打洞的,UDP打洞 技术也还是被广泛采纳应用. 具体实现 一般的网络编程,都是客户端比服务端要难,因为要处理与服务器的通信同时还要处理来自用户的事件；对于P2P客户端来说更是如此,因为P2P客户端不止作 为客户端,同时也作为对等连接的服务器端. 这里的大体思路是,输入命令传输给服务器之后,接收来自服务器的反馈,并执行相应代码. 例如A想要与B建立 通信链路,先给服务器发送punch命令以及给B发送数据,服务器接到命令后给B发送punch_requst信息以及A的端点信息,B收到之后向A发送数据打通通路,然 后A与B就可以进行P2P通信了. 经测试,打通通路后即便把服务器关闭,A与B也能正常通信. 一个UDP打洞的例子见P2P-Over-MiddleBoxes-Demo TCP打洞(TCP Hole Punching) 关于TCP打洞,有一点需要提的是,因为TCP是基于连接的,所以任何未经连接而发送的数据都会被丢弃,这导致在recv的时候是无法直接从peer端读取数据. 其实这对UDP也一样,如果对UDP的socket进行了connect,其也会忽略连接之外的数据,详见connect(2). 所以,如果我们要进行TCP打洞,通常需要重用本地的endpoint来发起新的TCP连接,这样才能将已经打开的NAT利用起来. 具体来说,则是要设置socket的 SO_REUSEADDR或SO_REUSEPORT属性,根据系统不同,其实现也不尽一致. 一般来说,TCP打洞的步骤如下： A 发送 SYN 到 B(出口地址,下同）,从而创建NAT A的一组映射 B 发送 SYN 到 A, 创建NAT B的一组映射 根据时序不同,两个SYN中有一个会被对方的NAT丢弃,另一个成功通过NAT 通过NAT的SYN报文被其中一方收到,即返回SYNACK, 完成握手 至此,TCP的打洞成功,获得一个不依赖于服务器的链接 由于TCP连接是由操作系统控制的, 而不是由应用控制的, 而且TCP包的序列号是随机生成, 所以TCP打洞的成功率就相对较低. 因此如果NAT对接收到的包进行TCP序列号检测时若没有现有的连接可以对应, 该TCP包很可能会被NAT丢弃掉. ","link":"https://xuaii.github.io/post/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"title":"[AI] 将复杂计算放到外部计算设备","content":"由于本机需要运行游戏进程，再额外运行神经网络，这样做非常卷，所以使用一台额外的计算机来推理（在网吧直接开两台电脑🤡） 现在有两种数据传输的方案： 使用采集卡 能采集高帧率画面的采集卡售价已经超过1000RMB了，所以很不划算 将游戏主机记为 A，推理主机记为 B，该方案，A 只需要运行一个控制鼠标移动的小程序（几乎没有消耗，可以直接纯 Python实现），主机 A 需要捕获采集卡的视频，并且进行推理，将目标列表数据通过 TCP/UDP 传输到主机A。两台主机需要通过采集卡和RJ45连接 进程间通信的方式 优点是成本低，只用连接一根网线，缺点是速度可能会慢） 该方法在主机A运行屏幕捕获和鼠标更新进程，在主机B运行推理进程 A-&gt;B : 剪裁后的 cv::Mat (320 x 320) B-&gt;A : 鼠标控制数据 以 90 fps的推理速度来计算 data=90×320×320×248=27,648,000(B/s)=27,000(KB/s)=26.4(MB/s)data = \\frac{90 \\times 320 \\times 320 \\times 24}{8} = 27,648,000(B/s)=27,000(KB/s) = 26.4(MB/s) data=890×320×320×24​=27,648,000(B/s)=27,000(KB/s)=26.4(MB/s) 所以进程间 以网线连接 使用UDP 通信，需要保证26.4 MB/s 的上传速度，不清楚这会不会导致过度占用网卡，导致游戏进程掉包 本地两台 PC 之间的传输时延低于 1ms， 对于本应用可以忽略不计 我们考虑每一帧的情况 data=1×320×320×248=307,200(B/frame)=300(KB/frame)=0.293(MB/frame)data = \\frac{1 \\times 320 \\times 320 \\times 24}{8} = 307,200(B/frame)=300(KB/frame) = 0.293(MB/frame) data=81×320×320×24​=307,200(B/frame)=300(KB/frame)=0.293(MB/frame) 传输方法 // send Mat img = imread(&quot;img/1.jpg&quot;); int imgSize = img.cols*img.rows*img.channels(); char *pos = (char*)img.data; int total = 0; while (total &lt; imgSize) { int sizelen = send(sockfd, pos+total, imgSize-total, 0); total = total + sizelen; } // recieve if ((connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1) { printf(&quot;accept socket error: %s(errno: %d)&quot;,strerror(errno),errno); } char buf[320 * 320 * 3]; // 图片宽高 memset(buf, 0, sizeof(buf)); int total = 0; while(total &lt; 320 * 320 * 3) { long len = recv(connfd, buf+total, 320 * 320 * 3-total, 0); // 注意偏移量 total = total + len; } cout &lt;&lt; &quot;接收长度为: &quot; &lt;&lt; total &lt;&lt; endl; Mat img(320 * 320, CV_8UC3, buf); 在开始开发之前需要测试网络和性能瓶颈 时延计算 timeDelay=grabTime+cropTime+TransportTime1+InferenceTime+TransportTime2timeDelay = grabTime + cropTime + TransportTime_1 + InferenceTime + TransportTime_2 timeDelay=grabTime+cropTime+TransportTime1​+InferenceTime+TransportTime2​ 使用一个ZeroMQ 的头文件only版本就行了（非常方便） 这样就能单机运行和多机运行了（设置启动脚本即可） tips: cppzmq 只是一个 c++ 的wrapper，其本质还是 基于c 的libzmq 使用cppzmq 需要先编译 libzmq，并且将 libzmq/include/zmq.h 和 cppzmq/* 添加到包含目录 将 libzmq/&lt;build_dir&gt;/lib/添加到库目录 将以下文件作为链接器输入 wsock32.lib ws2_32.lib Iphlpapi.lib libzmq-v143-mt-s-4_3_5.lib libzmq-v143-mt-4_3_5.exp testutil.lib testutil-static.lib unity.lib 经过测试，使用 cppzmq 在本地计算机能完成 1ms 内的数据传输，目标数据的传输需要使用 json 进行序列化！ ","link":"https://xuaii.github.io/post/ai-zi-miao-jiang-fu-za-ji-suan-fang-dao-wai-bu-ji-suan-she-bei/"},{"title":"C++ 矩阵库Eigen3学习","content":"上来第一个Demo我就没看懂 #include &lt;iostream&gt; #include &lt;Eigen/Dense&gt; using Eigen::MatrixXd; using Eigen::VectorXd; int main() { MatrixXd m = MatrixXd::Random(3,3); m = (m + MatrixXd::Constant(3,3,1.2)) * 50; std::cout &lt;&lt; &quot;m =&quot; &lt;&lt; std::endl &lt;&lt; m &lt;&lt; std::endl; VectorXd v(3); v &lt;&lt; 1, 2, 3; // 这是一个很方便的实现 std::cout &lt;&lt; &quot;m * v =&quot; &lt;&lt; std::endl &lt;&lt; m * v &lt;&lt; std::endl; } 这里的 v &lt;&lt; 1, 2, 3; 是什么原理，&lt;&lt; 操作符的优先级比逗号表达式的优先级更高，所以是怎么实现的呢？查阅资料后发现，原来是相当 v&lt;&lt;1; v&lt;&lt;2; v&lt;&lt;3; 下面是具体实现： #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template &lt;typename T&gt; class DemoVector:public vector&lt;T&gt; { private: class CommaInputWapper { public: CommaInputWapper()=delete; explicit CommaInputWapper(DemoVector&lt;T&gt;* const sp):_sp(sp){} CommaInputWapper&amp; operator,(const T&amp; val) { _sp-&gt;push_back(val); return *this; } private: DemoVector&lt;T&gt;* const _sp; }; public: DemoVector()=default; CommaInputWapper operator&lt;&lt;(const T&amp; val) { vector&lt;T&gt;::clear(); vector&lt;T&gt;::push_back(val); return CommaInputWapper(this); } }; template &lt;typename T&gt; ostream&amp; operator&lt;&lt;(ostream&amp; out,const vector&lt;T&gt;&amp; v) { if(!v.empty()) out&lt;&lt;v[0]; for(typename vector&lt;T&gt;::size_type i=1; i&lt;v.size(); ++i) { out&lt;&lt;&quot; &quot;&lt;&lt;v[i]; } return out; } int main() { DemoVector&lt;int&gt; dv1; dv1&lt;&lt;1,2,3,4,5,6; cout&lt;&lt;dv1&lt;&lt;endl; return 0; } ","link":"https://xuaii.github.io/post/c-ju-zhen-ku-eigen3-xue-xi/"},{"title":"[云云] 游戏 BOSS AI 设计","content":"前言 最近听朋友吹了一下魂系列游戏的BOSS，它读指令，会预判，会假动作。但是在多次重复的对战中依然会暴露出一些特定的行为模式，这是因为传统AI设计依然依赖于静态结构的状态机和行为树。并且这样的 AI 设计确实能让BOSS 看起来不笨，但受限于静态结构需要人为设计AI 结构，AI的复杂度提升意味着更多的时间投入。 对于低成本游戏来说这简直是天方夜谭。前段时间做了 FPS AIM AI，看到了我最爱的 FPS 游戏被 AI毁掉的未来，但是 AI 在游戏方面除了替代人类，就不能带来更好的游戏体验么？于是萌生了一个利用机器学习生成更加聪明和捉摸不透的 BOSS 的想法。 诚然，游戏 BOSS 不应该只需要捉摸不透和聪明，每个 BOSS 需要有他独特的品质，比如阴险狡诈的BOSS会在使用很多阴招，类似火影中斑这样的 BOSS 就只能用一些正面的攻击，诸如此类的讨论太多太杂，我想一次解决一个问题，仅仅是让 AI 更聪明，如果 AI 能学习对战数据，那么跟着枭雄能学到枭雄的对战方式，跟着小人能学到小人的阴险技巧。 进一步思考 战斗实体 需要实现两个可操作，可对战 的游戏角色，因为需要记录对战数据集，所以即使是 BOSS 也不能仅仅设计程序驱动的API，它需要被设计成一个既能被程序控制，也能被玩家控制的实体，也就是说对于对战实体，我们需要约定一组通用的操作接口（可以是状态切换方式）。 战斗环境 需要设计和记录一组 AI 可采集的环境变量，例如目前所处的位置信息，周围的掩体信息，可用技能信息，敌人位置信息，敌人可用技能信息等，这些信息将在每一次有效决策前被记录（例如连续移动，闪避，使用技能等），需要将采集到的信息进行某种编码，这种编码能归一化各个环境变量的scale并且能有效表达其对应的战场信息，这种编码的设计关系到 AI 是否能在堆栈中学习到东西 训练数据 将一场对战的所有环境信息和决策信息按时间轴顺序排列，得到一场对战的数据集，我们需要设计一种机器学习结构在其中学习到有用的信息并且能表现数据集的特征，还有一个重要的目标是胜利，游戏对战不像是回合制的博弈，我们的每一个决策来带的局部胜利会很大的影响最终的战斗结果，所以衡量一场战斗的损失不能单单从结果考虑，而应该结合战斗过程中每一步，或者间隔几步的损失。 随机性 为了使得战斗更加丰富，我们需要为模型增加随机因素，并且为玩家的环境信息添加更多的权重（使得不同玩家更可能得到不同的游戏体验。 实现难点 通用接口，这意味着即使是 BOSS 也需要设计等同于玩家的复杂的动画状态机，并且通过一个同等复杂的状态机来约束各个状态之间的转换 如何编码战斗环境状态？如何表达战斗实体之间的距离？如何表达实体之间的障碍物？如何表达实体的可移动空间大小？如何过滤无效操作？如何编码编码各个技能，使得模型感知到不同技能的不同作用？如何编码对战实体状态（血量，药物，技能储备等）。更进一步说按照游戏设计的角度，包括距离，优势位置，障碍，血量，技能，物品 都被当作资源看待，那么编码问题就转换为 如何统一的表达游戏资源？ 学习模型的设计，首先内嵌于游戏的深度学习推理模型应该占用更小的内存和计算资源，所以不能采用复杂的计算模型，应该采用传统机器学习方法 / 轻量的深度学习方法？？（这里我不太懂，需要做一下调研，什么样的学习模型适合对战游戏） 实现细节 // 云云的就等考研完之后，复习一下机器学习相关的算法再继续云了。 // 或许先学学强化学习相关的方法？？ // c# 有一个 ML.NET 所以可以实现平台无关的方案（unity， godot， 。。 只要使用c#的引擎都通用，或者使用 C++来做，这样几乎所有引擎都通用） // c++机器学习库：mlpack, 矩阵库：Eigen3， 并行后端 openCL，CUDA 线性代数库：ViennaCL，Armadillo， 数值优化库 ensmallen， 序列化库cereal ","link":"https://xuaii.github.io/post/yun-yun-you-xi-boss-ai-she-ji/"},{"title":"[GUI 框架] imGUI in c++","content":"imgui 是一个轻量级UI框架，常用于游戏引擎，这是我一直很喜欢的一个 UI 框架，但是一直没有机会学习，趁这次机会 上手操作一下 之前做了 AI 自瞄，界面不太灵活，虽然实现了python脚本系统，但是并没有实现热重载，并且软件启动时需要分配 GPU 内存，重复的启动再关闭开销很大。为了用户能更好地配置参数和测试，需要一个UI： 显示系统输出消息 python 模块热重载功能 暂停启动功能 UI 和 AI 将运行在两个线程，UI线程仅提供控制功能 UI界面 整体呈现命令行窗口的样式 主要区域用于实现指令： 开始，暂停，结束指令 重载脚本指令 调整参数指令 更换模型指令 然后有一个附窗口用于实现 视频展示， 是否开启视频展示，目标检测状态显示 UI 窗口仅仅负责发送指令 其中，仅仅在开启 / 暂停状态显示 AI 状态和视频窗口 设置一个结构来控制当前程序状态，启动窗口后启动线程 struct ProgramState { bool enableInference; bool enablePreview; bool enableScript; bool reloadScript; bool reloadModel; } github 存储库里的 demo 已经很完备了，完全可以参考着写，在此就不过多赘述了，但是要记录一个小坑： 想要实现游戏外 overlay 时，需要将window 的绘制窗口调为透明和不可交互，并且将 ImGUI 的子窗口移动到相同位置，与父窗口分离。 这个隐藏绘制窗口的方法时设置 某种颜色为透明色，并且透明的区域是不可交互的，但是在DX12下时无效的，仅仅在 DX9是有效的（或许是有更好的解决方案，但是我没有找到 ","link":"https://xuaii.github.io/post/gui-kuang-jia-imgui-in-c/"},{"title":"[转载] c++多线程调用python","content":"脚本语言是快速编写富有弹性的代码的重要方法之一，在 Unix 系统自动化管理中已经应用了多种脚本语言。现在，在许多应用开发中，也提供了脚本层，这大大方便用户实现通用任务自动处理或者编写应用扩展，许多成功的应用，诸如 GIMP、Emacs、MS Office、PhotoShop、AutoCAD 等都应用了脚本技术。在某种意义上，一切皆可脚本化。 在另一篇文章中，我们已经介绍了如何在 C 应用中嵌入 Python 语言，通过这项技术，可以让应用的高级用户来修改或定制化他们的程序，你可以充分利用 Python 的语言能力而不用自己去实现嵌入语言。Python 是一个不错的的选择，因为它提供了干净直观的 C 语言 API。关于如何在 C 应用中嵌入 Python 解释器，你可以参考：让Python成为嵌入式语言一文。 现在我们来更深入地探讨一些问题。 鉴于许多复杂的应用都会利用多线程技术，本文将着重介绍如何创建线程安全的界面来调用Python解释器。 这里的所有例子都是用 Python 2.7.2，所有的 Python 函数都以extern “C”定义，因此对于 C 和 C++，其使用是别无二致的。 Python C 和线程 在C程序中创建执行线程是很简单的。在 Linux 中，通常的做法是使用 POSIX 线程（pthread) API 并调用 pthread_create 函数。关于如何使用 pthreads，你可以参考 Felix Garcia 和Javier Fernandez 著的 “POSIX Thread Libraries”一文。为了支持多线程， Python 使用了互斥使访问内部数据结构串行化。这种互斥即 “全局解释器锁 – global interpreter lock”，当某个线程想使用 Python 的C API的时候，它必须获得 全局解释器锁，这避免了会导致解析器状态崩溃的竞争条件（race condition)。 互斥的锁定和释放是通过 PyEval_AcquireLock 和 Eval_ReleaseLock 来描述的。调用了 PyEval_AcquireLock 之后，可以安全地假定你的线程已经持有了锁，其他相关线程不是被阻塞就是在执行与 Python 解析器无关的代码。现在你可以任意调用 Python 函数了。一旦取得了锁，你必须确保调用 PyEval_ReleaseLock 来释放它，否则就会导致线程死锁并冻结其他 Python 线程。 更复杂的情况是，每个运行 Python 的线程维护着自己的状态信息。这些和特定线程相关的数据存储在称为 PyThreadState 的对象中。当在多线程应用中用 C 语言调用 Python API 函数时，你必须维护自己的 PyThreadState 对象以便能安全地执行并发的 Python 代码。 如果你对开发多线程应用相当有经验，你可能会发现全局解释器锁的概念相当不方便。不过，现在它已经不像首次出现时那样糟糕了。当 Python 对脚本进行解释时，它会定期切换出当前 PyThreadState 对象并释放全局解释器锁，从而将控制权释放给其他线程。之前被阻塞的线程可以试图锁定全局解释器锁从而被运行。有些时候，原来的线程会再次获得全局解释器锁再次切回解释器。 这意味着当调用 PyEval_SimpleString 时，即使你持有全局解释器锁，其他线程仍有机会被执行，这样的副作用无可避免。另外，当你调用以 C 语言写就的 Python 模块（包括许多内置模块） 存在着将控制权释放给其他线程的可能性。基于这个原因，当你用两个 C 线程来执行计算密集的 Python 脚本，它们确实能分享 CPU 时间并发运行，但由于全局解释器锁的存在，在多处理器的计算机上，Python 无法通过线程充分计算机的 CPU 处理能力。 启用线程支持 在多线程的 C 程序使用 Python API 之前，必须调用一些初始化例程。如果编译解释器库时启用了多线程支持（通常情况如此），你就有了一个是否启用线程的运行时选项。除非你计划使用线程，否则不建议启用该选项。未启用该选项，Python 可以避免因互斥锁定其内部数据结构而产生的系统开销。但是如果你打算用 Python 来扩展多线程应用，你就需要在初始化解释器的时候启用线程支持。我个人建议，应该在主线程执行时就初始化 Python，最好是在应用程序启动的时候，就调用下面两行代码： // initialize Python Py_Initialize(); // initialize thread support PyEval_InitThreads(); 这两个函数都返回 void，所以无需检查错误代码。现在，我们可以假定 Python 解释器已准备好执行 Python 代码。Py_Initialize 分配解释器库使用的全局资源。调用PyEval_InitThreads 则启用运行时线程支持。这导致 Python 启用其内部的互斥锁机制，用于解释器内代码关键部分的系列化访问。此函数的另一个作用是锁定全局解释器锁。该函数完成后，需要由用户负责释放该锁。不过，在释放锁之前, 你应该捕获当前 PyThreadState 对象的指针。后续创建新的 Python 线程以及结束使用 Python 时要正确关闭解释器，都需要用到该对象。下面这段代码用来捕获 PyThreadState 对象指针: PyThreadState * mainThreadState = NULL; // save a pointer to the main PyThreadState object mainThreadState = PyThreadState_Get(); // release the lock PyEval_ReleaseLock(); 创建新的执行线程 在 Python 里，每个执行 Python 代码的线程都需要一个 PyThreadState 对象。解释器使用此对象来管理每个线程独立的数据空间。理论上，这意味着一个线程中的动作不会牵涉到另一个线程的状态。例如，你在一个线程中抛出异常，其他 Python 代码片段仍会继续运行，就好象什么事情都没有发生一样。你必须帮助 Python 管理每个线程的数据。为此，你需要为每个执行 Python 代码的 C 线程手工创建一个 PyThreadState 对象.要创建 PyThreadState 对象，你需要用到既有的 PyInterpreterState 对象。PyInterpreterState 对象带有为所有参与的线程所共享的信息。当你初始化 Python 时，它就会创建一个 PyInterpreterState 对象，并将它附加在主线程的 PyThreadState 对象上。你可以使用该解释器对象为你自己的 C 现成创建新的 PyThreadState。请参考下面代码 // get the global lock PyEval_AcquireLock(); // get a reference to the PyInterpreterState PyInterpreterState * mainInterpreterState = mainThreadState-&gt;interp; // create a thread state object for this thread PyThreadState * myThreadState = PyThreadState_New(mainInterpreterState); // free the lock PyEval_ReleaseLock(); 执行 Python 代码 现在我们已创建 PyThreadState 对象，你的 C 线程就可以开始使用 Python API 执行 Python 脚本。从 C 线程执行 Python 代码时，你必须遵守一些简单的规则。首先，您在进行任何会改变当前线程状态的操作前必须持有全局解释器锁。第二，必须在执行任何 Python 代码之前，必须将该线程特定的 PyThreadState 对象加载到解释器。一旦您已经满足这些条件，您可以通过诸如 PyEval_SimpleString 函数来执行任意的 Python 代码，并记得在执行结束时切出 PyThreadState 对象并释放全局解释器锁。请参考下面代码，注意代码中“锁定、 切换、 执行、 切换，解锁”的对称关系： // grab the global interpreter lock PyEval_AcquireLock(); // swap in my thread state PyThreadState_Swap(myThreadState); // execute some python code PyEval_SimpleString(&quot;import sys\\n&quot;); PyEval_SimpleString(&quot;sys.stdout.write(‘Hello from a C thread!\\n‘)\\n&quot;); // clear the thread state PyThreadState_Swap(NULL); // release our hold on the global interpreter PyEval_ReleaseLock(); 清除线程 一旦你的 C 线程不再需要 Python 解释器，你必须释放相关资源。为此，需要删除该线程的 PyThreadState 对象，相关代码如下： // grab the lock PyEval_AcquireLock(); // swap my thread state out of the interpreter PyThreadState_Swap(NULL); // clear out any cruft from thread state object PyThreadState_Clear(myThreadState); // delete my thread state object PyThreadState_Delete(myThreadState); // release the lock PyEval_ReleaseLock(); 通过使用 Python API ，这个线程很有效率地完成了上述工作。现在你可以安全地调用 pthread_ext 来结束该线程的运行。 关闭解释器 一旦应用不在需要 Python 解释器，你可以用下面的代码将 Python 关闭掉： // shut down the interpreter PyEval_AcquireLock(); Py_Finalize(); 注意：因为 Python 已经被关系，这里就不需要释放锁。请确保在调用 Py_Finalize 之前用 PyThreadState_Clear 和 PyThreadState_Delete 删除掉所有线程状态对象。 小结： 作为嵌入式语言，Python 是一个不错的选择。Python 解释器同时支持嵌入和扩展，它允许 C 应用程序代码和嵌入的 Python 脚本之间的双向通信。此外，多线程支持促进了与多线程应用程序的集成，而且不影响性能。 你可以从本文的后面下载有关案例Python embedded HTTP Server (29)，该案例实现了一个内嵌 Python 解释器的多线程 HTTP 服务器。此外我推荐您去 http://www.python.org/docs/api/ 阅读有关的 Python C API 文档。另外 Python 解释器本身的代码也是一个很有价值的参考。 ","link":"https://xuaii.github.io/post/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"title":"[AI] Auxiliary positioning and tracker","content":"参考列表 Python embedding c++多线程调用python yolov7-ncnn Yolo-FastestV2 ncnn教程 ncnn 环境 opencv之Mat格式数据转换成onnxruntime的输入tensor处理的c++写法 Tracker - Norfair FPS游戏的鼠标灵敏度换算方法 phoboslab/jsmpeg-vnc 桌面复制 API - Win32 apps | Microsoft Learn桌面复制 API - Win32 apps | Microsoft Learn 最近看到有些 FPS 游戏主播被锤外挂，不禁有些感叹 人菜逼事多。所以产生了研究AI自瞄原理的想法。首先做AI自瞄不是想开挂，而是对于反外挂而言 只有了解Hacker才能Anti-Hacker。 总体思路 传统的 FPS 游戏外挂需要读内存、改内存，因此很容易被检测。而 AI 自瞄只读取游戏画面(可以通过屏幕捕获、外置摄像头)，通过目标检测方法 准确的识别出游戏中的目标的类型和位置，然后通过各种移动准星的方法将准星移动到目标位置，AI 自瞄系统应该仅提供基础设施（识别系统、脚本系统、配置系统），玩家可以自定义视频输入方式，通过脚本系统定义 &quot;如何瞄准敌人&quot;（添加抖动等），定义识别系统的参数。 // 为了高效运行，外挂的运行时使 C/C++，脚本系统使用 Python / C# 但是，将屏幕捕获交给玩家会加重识别系统的的任务（识别敌人 + 识别屏幕），再加上坐标变换后降低了准确度，为了使识别准确度尽可能提高，将采用捕获屏幕作为输入。 github 项目地址 读取游戏画面 windows 屏幕抓取技术总结 总结了windows 下各个平台的屏幕抓取性能开销对比，但是和我实测的数据有些偏差，在我实测中 DXGI 几乎不消耗 CPU/GPU 资源，GDI方案消耗大量的 CPU 资源。但是在启动了 APEX 的情况下 DXGI 仅能达到 90fps， GDI 能达到 200fps，所以我们的方案采用 GDI 方法，GDI 抓屏参考(几乎是copy)了 phoboslab/jsmpeg-vnc: A low latency, high framerate screen sharing server for Windows and client for browsers 的grabber方法，并且取得很高的效率。 #ifndef GRABBER_H #define GRABBER_H #define WIN32_LEAN_AND_MEAN #include &lt;Windows.h&gt; typedef struct { int x, y, width, height; } grabber_crop_area_t; typedef struct { HWND window; HDC windowDC; HDC memoryDC; HBITMAP bitmap; BITMAPINFOHEADER bitmapInfo; int width; int height; void *pixels; grabber_crop_area_t crop; } grabber_t; grabber_t *grabber_create(HWND window, grabber_crop_area_t crop); void grabber_destroy(grabber_t *self); void *grabber_grab(grabber_t *self); #endif 该实现需要先获取 windows 窗口句柄，然后初始化 grabber #include &lt;Windows.h&gt; ... HWND handle = FindWindow(NULL, TEXT(&quot;Apex Legends&quot;)); if(!handle) return -1; grabber_crop_area_t crop { 0, 0, 0, 0 }; grabber_t * grabber = grabber_create(handle, crop); ... while(1) { void* data = grabber_grab(grabber); ... } 这里踩的坑是 void* 是一个字节数组，也就是 uchar* 数组而在 grabber.c 中设置了 bitmapInfo.biBitCount = 32; bitmapInfo.biCompression = BI_RGB; 我们不需要 A 通道数据，所以设置 bitmapInfo.biBitCount = 24 这意味着要将 grabber 捕获到的数据是 RGB 格式的用 opencv 读取需要格式 CV_8U3C: void* pixel = grabber_grab(grabber); // 8U3C -&gt; 3 通道每通道 8 位 cv::Mat frame = cv::Mat(cv::Size{ grabber-&gt;width, grabber-&gt;height }, CV_8UC3); frame.data = (uchar*)pixel; 由于opencv 的格式是 BGR，神经网络输入格式是 RGB；将 cv::Mat 转为 ncnn::Mat 时需要进行格式转换： ncnn::Mat in = ncnn::Mat::from_pixels_resize(croped.data, ncnn::Mat::PIXEL_BGR2RGB, croped.cols, croped.rows, target_size, target_size); 这里可以直接从 void* 转换到 ncnn::Mat , 为了测试方便还是先转换成 cv::Mat 方便使用 cv::imshow() 显示到窗口。 识别目标 识别目标 是最重要的一环，也是踩坑最多的一环。神经网络训练时框架太笨重，不适合用于软件嵌入，现有的推理框架： NCNN：腾讯的产品，号称 &quot;0 依赖&quot;，运行时确实不需要 .dll 开发时需要 protobuf，vulkan。在移动平台等边缘设备优化是最好的，很适合用于 嵌入应用. MNN、MACE、TF-lite、Paddle-lite 这些都类似 NCNN 主打移动端推理 TensorRT：Nvidia 的框架，一般来说 Nvidia 下用该框架时最快的依赖 cuda,cudann TensorRT-For-YOLO-Series/main.cpp at main · Linaom1214/TensorRT-For-YOLO-Series (github.com) OpenVINO：Intel家的，缺点很明显不支持 AMD CPU 对于 AI 自瞄来说最好的选择是 NCNN 或者 TensorRT（但是开始这个项目之前没怎么了解过，先后使用了libtorch、OnnxRuntime、NCNN、TensorRT） 为了方便后续添加功能，例如移动端的实现，采用 Tensorrt 和 NCNN 两种实现。 模型使用 最新的 Yolov7， 准确率高，速度快，在不启动游戏的情况下 RTX2060 可以有120fps 的推理速度。 GitHub - WongKinYiu/yolov7: Implementation of paper - YOLOv7: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors 给出了模型训练和模型导出的方法，NCNN/TensorRT 的使用可以在 Github 找到大量的Demo，拿到Demo搞清楚输入输出即可。 这一环最麻烦的是数据格式的转换 BGR -&gt; RGB : 可以由 cv::Mat.convertTo, ncnn::Mat.resize 等方法 NHWC -&gt; NCHW: cv::dnn::blobFromImage, transposeND, 三层 for 循环硬转，tensorflow/pytorch 的轴旋转方法 调用track脚本 这里使用 Python 脚本来处理神经网络的输出和鼠标移动，由于不同的用户需求不同，例如 鼠标平滑，定位精度，拉枪速度，鼠标吸附等，process 方法将在每一个推理帧的最后被调用。 def process(targets) -&gt; (float, float): for target in target: print(target) return (1.1, 2.0) 脚本需要和c++交互，process 方法需要被c++调用并捕获输出值，c++ 调用python需要include Python.h 头文件，需要添加 &lt;python_dir&gt;/libs 库文件， 最后程序打包时需要将 python39.dll 添加到 .exe 文件目录，可以使用更小的 embed 版本来将 python 嵌入到应用（只占用10mb） #define PY_SSIZE_T_CLEAN #include &lt;Python.h&gt; int main() { Py_SetPythonHome(std::wstring(config.pythonHome.begin(), config.pythonHome.end()).c_str()); Py_Initialize();//初始化python PyObject *pModule = NULL, *pFunc = NULL, *pArg = NULL; pModule = PyImport_ImportModule(&quot;core&quot;);//引入模块 pFunc = PyObject_GetAttrString(pModule, &quot;process&quot;);//直接获取模块中的函数 PyObject* list = PyList_New(0); Py_INCREF(list); for (auto&amp; obj : boxes) { PyList_Append(list, Py_BuildValue(&quot;(f,f,f,f,f)&quot;, (obj.x1 + obj.x2) / 2, (obj.y1 + obj.y2) / 2, obj.x2 - obj.x1, obj.y2 - obj.y1, obj.score)); } PyDict_SetItemString(dict, &quot;target_list&quot;, list); Py_DECREF(list); PyDict_SetItemString(dict, &quot;mouse_left_button&quot;, Py_BuildValue(&quot;b&quot;, KEY_DOWN(VK_LBUTTON))); PyDict_SetItemString(dict, &quot;mouse_middle_button&quot;, Py_BuildValue(&quot;b&quot;, KEY_DOWN(VK_MBUTTON))); PyDict_SetItemString(dict, &quot;mouse_right_button&quot;, Py_BuildValue(&quot;b&quot;, KEY_DOWN(VK_RBUTTON))); PyDict_SetItemString(dict, &quot;mouse_ctrl_button&quot;, Py_BuildValue(&quot;b&quot;, KEY_DOWN(VK_CONTROL))); PyObject* args = PyTuple_New(1); PyTuple_SetItem(args, 0, dict); PyObject* pRet = PyObject_CallObject(pFunc, args); if (!pRet) return; if (PyErr_Occurred()) { PyErr_Print(); } Py_Finalize(); //释放python return 0; } python 端需要获取非激活窗口的键盘或者鼠标状态需要使用pyhook， 但是在 c++ 可以很简单的获得： #define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME) &amp; 0x8000) KEY_DOWN(VK_LBUTTON); KEY_DOWN(VK_MBUTTON); KEY_DOWN(VK_RBUTTON); KEY_DOWN(VK_CONTROL); 并通过 c++ 传递给 python 更新准星位置 参考了这位老哥的鼠标定位方法 FPS游戏（AI自瞄原理） - 哔哩哔哩 (bilibili.com) 但是这里给出的计算方式是有偏差的, 但是利用 角度替代像素 是正确的，游戏引擎中相机的角度是使用欧拉角来计算的, 一般第一人称游戏使用鼠标的 水平输出(HorizontalInput) 和 竖直输出(VerticalInput) 来控制摄像机转动，这一位置，所以对于不同的游戏 XInput 的大小和相机转动的欧拉角可能不一样，也就是说我们定义一个单位: 像素角(fa)=转动一弧度移动的像素(pixel/rad)像素角(fa) = 转动一弧度移动的像素(pixel/rad) 像素角(fa)=转动一弧度移动的像素(pixel/rad) 像素角的计算和测量 fa=游戏水平转动一周需要的像素×2×π360×游戏内灵敏度×ADSfa = \\frac{游戏水平转动一周需要的像素\\times 2 \\times \\pi}{360} \\times 游戏内灵敏度 \\times ADS fa=360游戏水平转动一周需要的像素×2×π​×游戏内灵敏度×ADS 所以只需要测量游戏内水平转动一周需要移动的像素即可(游戏内瞄准一个点不断地改变pixel 的值，直到相机画面不会抖一下)，不同倍镜下的 fa 值是不同的需要单独测量。 import win32api import win32con pixel = 10909 for i in range(pixel) { win32api.mouse_event(xxx, 1, 0, 0, 0) } 现在有了 fa 的值之后，再来计算如何将鼠标移动到频幕上的点 Point(x, y), 首先计算目标点和屏幕某点 P 的偏移向量 offset(x, y)但是，真实的移动是发生在游戏空间的 3D 世界。 也就是需要将视角方向从OB 调整到OG方向，借鉴 水平像素转角度方法可以先将视线 OB 调整到 OC，再从OC调整到OG，这个过程中 相机到视平面的距离是不变的。 为了保持距离不变，所以是先从 OB -&gt; OI -&gt; OK，所以将三维的转动过程转化为两次二维的转动 dis2screen=AB=half_screen_widthtan⁡fov2θx=∠BAI=arctan⁡BCABarctan⁡offsetxdis2screenθy=∠CAG=arctan⁡CGAC=arctan⁡CGAB2+BC2=arctan⁡offsetydis2screen2+offsetx2dis2screen = AB = \\frac{half\\_screen\\_width}{\\tan{\\frac{fov}{2}}} \\\\ \\quad\\\\ \\quad\\\\ \\theta_x = \\angle{BAI} = \\arctan{\\frac{BC}{AB}} \\arctan{\\frac{offset_x}{dis2screen}} \\quad\\\\ \\quad\\\\ \\quad\\\\ \\quad\\\\ \\theta_y = \\angle{CAG} = \\arctan{\\frac{CG}{AC}} = \\arctan{\\frac{CG}{\\sqrt{AB^2+BC^2}}} = \\arctan{\\frac{offset_y}{\\sqrt{dis2screen^2 + offset_x^2}}} dis2screen=AB=tan2fov​half_screen_width​θx​=∠BAI=arctanABBC​arctandis2screenoffsetx​​θy​=∠CAG=arctanACCG​=arctanAB2+BC2​CG​=arctandis2screen2+offsetx2​​offsety​​ 这样就得到了两个方向的偏转角(θx,θy)(\\theta_x, \\theta_y)(θx​,θy​)，所以根据之前测量得到的 fa 值，可以得到鼠标的像素偏移值： pixeli=θi×fa游戏内灵敏度×FOVpixel_i = \\theta_i \\times \\frac{fa}{游戏内灵敏度\\times FOV} pixeli​=θi​×游戏内灵敏度×FOVfa​ 所以就可以由屏幕偏移量 offset 得到鼠标偏移量 pixel， 此外需要能够移动鼠标的方法，在 python 环境下，常规的自动化库方法都是无效的，鼠标驱动层的移动应该是有效的但是麻烦，win32api 也是有效的，不过需要以管理员权限启动程序。 import win32api import win32con win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, int(pixel_x), int(pixel_y), 0, 0) 使用 Json 读取配置 使用简单又方便的 nlohmann/json: JSON for Modern C++ (github.com)，只有 .hpp 头文件 std::cout &lt;&lt; &quot;# init config ...&quot; &lt;&lt; std::endl; // ----------------------- config ----------------------- std::ifstream f = std::ifstream(); json json_data;; Config config; // 需要根据当前运行环境构造文件全名 try { f.open(&quot;./config.json&quot;); json_data = json::parse(f); std::cout &lt;&lt; &quot;[init] load config from: &quot; &lt;&lt; &quot;config.json&quot; &lt;&lt; std::endl; config.windowName = json_data[&quot;windowName&quot;]; config.classNamesPath = json_data[&quot;classNamesPath&quot;]; config.pythonHome = json_data[&quot;pythonHome&quot;]; config.debug = json_data[&quot;debug&quot;]; config.detectorName = json_data[&quot;detectorName&quot;]; config.paramPath = json_data[&quot;paramPath&quot;]; config.binPath = json_data[&quot;binPath&quot;]; config.boxThreshold = json_data[&quot;boxThreshold&quot;]; config.nmsThreshold = json_data[&quot;nmsThreshold&quot;]; config.useGPU = true; config.mouseMovementDelay = json_data[&quot;mouseMovementDelay&quot;]; config.receptiveField = json_data[&quot;receptiveField&quot;]; } catch (std::exception&amp; e) { std::cout &lt;&lt; &quot;配置文件读取失败&quot; &lt;&lt; std::endl; return -1; } ","link":"https://xuaii.github.io/post/you-xi-wai-gua-ai-zi-miao/"},{"title":"[Godot] Geometry 对象使用","content":"之前一直忽略了官方文档中的API列表，很多常用的操作都有现成的API，不需要自己去写，记录一下常用的 Geometry 对象使用方法。 Geometry 为用户提供了一组辅助函数，用于创建、剪裁、最近邻、判断位置/相交、缩放、其他 几何操作。 // 好像缺少曲面细分等操作 创建几何形状 Array build_box_planes ( Vector3 extents ); // 生成面状胶囊 Array build_capsule_planes ( float radius, float height, int sides, int lats, Vector3.Axis axis=2 ); // 生成切面圆柱体 Array build_cylinder_planes ( float radius, float height, int sides, Vector3.Axis axis=2 ); 剪裁 该类操作可能导致产生外部多边形（边界）和内部多边形（孔），可以通过调用 is_polygon_clockwise来区分。 // 使用平面剪裁多边形 PoolVector3Array clip_polygon ( PoolVector3Array points, Plane plane ); /* 将polygon_a与polygon_b进行对比，并返回一个被剪切的多边形数组。这在多边形之间执行OPERATION_DIFFERENCE。如果polygon_b与polygon_a完全重合，则返回一个空数组。 */ Array clip_polygons_2d ( PoolVector2Array polygon_a, PoolVector2Array polygon_b ); /* 将polyline与polygon相对应，并返回一个折线数组。在折线和多边形之间执行OPERATION_DIFFERENCE。这个操作可以被认为是用一个封闭的形状切割一条折线。 */ Array clip_polyline_with_polygon_2d ( PoolVector2Array polyline, PoolVector2Array polygon ); // 相互排除由 polygon_a 和 polygon_b（见 intersect_polygons_2d）的交叉点定义的公共区域，并返回一个排除的多边形数组。这在多边形之间执行了 **OPERATION_XOR**。换句话说，返回多边形之间除公共区域外的所有区域。 Array exclude_polygons_2d ( PoolVector2Array polygon_a, PoolVector2Array polygon_b ) // 给出一个Vector2s的数组，以逆时针的顺序返回凸面的点的列表。最后一个点与第一个点相同。 // 将任意多边形分解为多个凸包 PoolVector2Array convex_hull_2d ( PoolVector2Array points ) // 将polygon_a与polygon_b相交并返回相交的多边形数组。这在多边形之间执行OPERATION_INTERSECTION。换句话说，返回多边形共享的公共区域。如果没有发生相交，则返回一个空数组。 Array intersect_polygons_2d ( PoolVector2Array polygon_a, PoolVector2Array polygon_b ) // 将polyline与polygon相交，并返回相交的折线数组。这在折线和多边形之间执行了OPERATION_INTERSECTION。这个操作可以被认为是用一个封闭的形状砍断一条线。 Array intersect_polyline_with_polygon_2d ( PoolVector2Array polyline, PoolVector2Array polygon ) // 检查两行（from_a，dir_a）和（from_b，dir_b）是否相交。如果是，则将相交点返回为Vector2。如果没有交叉，则返回一个空的Variant。 // 注意：线是使用方向向量而不是终点指定的。 Variant line_intersects_line_2d ( Vector2 from_a, Vector2 dir_a, Vector2 from_b, Vector2 dir_b ) // 合并（结合）polygon_a 和 polygon_b，并返回一个合并的多边形数组。在多边形之间执行 OPERATION_UNION。 Array merge_polygons_2d ( PoolVector2Array polygon_a, PoolVector2Array polygon_b ) // 合并（结合）polygon_a 和 polygon_b，并返回一个合并的多边形数组。在多边形之间执行 OPERATION_UNION。 Array merge_polygons_2d ( PoolVector2Array polygon_a, PoolVector2Array polygon_b ) 最近邻 // 返回3D部份（s1, s2）上离point最近的3D点。返回的点将总是在指定的部份内。 Vector3 get_closest_point_to_segment ( Vector3 point, Vector3 s1, Vector3 s2 ) // 返回2D段（s1, s2）上最接近point的2D点。返回的点将总是在指定的线段内。 Vector2 get_closest_point_to_segment_2d ( Vector2 point, Vector2 s1, Vector2 s2 ) // 返回由（s1, s2）定义的三维直线上最接近 point的三维点。返回的点可以在线段内（s1, s2），也可以在线段外，即在线段延伸的某处。 Vector3 get_closest_point_to_segment_uncapped ( Vector3 point, Vector3 s1, Vector3 s2 ) // 返回由（s1, s2）定义的二维线上最接近point的二维点。返回的点可以在线段（s1, s2）内，也可以在线段外，即在从线段延伸出来的某处。 Vector2 get_closest_point_to_segment_uncapped_2d ( Vector2 point, Vector2 s1, Vector2 s2 ) // 给定两个 3D 线段 (p1，p2) 和 (q1，q2)，到这两个线段上最接近的两个点。返回一个 PoolVector3Array，其中包含 (p1，p2) 上的这个点以及 (q1，q2) 上的伴随点. PoolVector3Array get_closest_points_between_segments ( Vector3 p1, Vector3 p2, Vector3 q1, Vector3 q2 ) // 给定两个 2D 线段 (p1，q1) 和 (p2，q2)，找到这两个线段上最接近的两个点。返回一个 PoolVector2Array，其中包含 (p1，q1) 上的这个点以及 (p2, q2) 上的伴随点. PoolVector2Array get_closest_points_between_segments_2d ( Vector2 p1, Vector2 q1, Vector2 p2, Vector2 q2 ) 判断位置/相交 // 返回true时，point位于圆的内部或者正好位于圆的边界上，否则将返回false。 bool is_point_in_circle ( Vector2 point, Vector2 circle_position, float circle_radius ) // 返回true时，point位于多边形polygon的内部或者正好位于多边形的边界上，否则将返回false。 bool is_point_in_polygon ( Vector2 point, PoolVector2Array polygon ) // 如果多边形 polygon 的顶点按顺时针顺序排序，则返回 true，否则返回 false。 bool is_polygon_clockwise ( PoolVector2Array polygon ) // 如果点point在a、b和c所指定的三角形内，则返回。 bool point_is_inside_triangle ( Vector2 point, Vector2 a, Vector2 b, Vector2 c ) const // 测试从from开始，方向为dir的3D射线是否与a、b和c指定的三角形相交。如果是，返回相交点为Vector3。如果没有发生相交，将返回一个空的Variant。 Variant ray_intersects_triangle ( Vector3 from, Vector3 dir, Vector3 a, Vector3 b, Vector3 c ) // 给出2D线段（segment_from，segment_to），返回线段上与圆心为 circle_position 、半径为 circle_radius 圆的相交位置（以0到1之间的数字）。如果线段没有与圆相交，则返回-1（如果延伸线段的线段与圆相交，但线段没有相交，也是这种情况）。 float segment_intersects_circle ( Vector2 segment_from, Vector2 segment_to, Vector2 circle_position, float circle_radius ) // 给定一个通过数组 planes 中的 Planes 定义的凸面体，测试线段（from，to）是否与该面体相交。如果找到相交点，返回一个PoolVector3Array，包含相交点和凸面体的法线。如果没有找到相交点，返回的数组为空。 PoolVector3Array segment_intersects_convex ( Vector3 from, Vector3 to, Array planes ) // 检查线段（from，to）是否与高度 height 的圆柱体相交，圆柱体以原点为中心，半径为 radius。如果没有，返回一个空的 PoolVector3Array。如果发生了相交，返回的数组包含相交点和圆柱体在相交点的法线。 PoolVector3Array segment_intersects_cylinder ( Vector3 from, Vector3 to, float height, float radius ) // 检查两段（from_a, to_a）和（from_b, to_b）是否相交。如果是，返回相交点为Vector2。如果没有发生相交，返回一个空的Variant。 Variant segment_intersects_segment_2d ( Vector2 from_a, Vector2 to_a, Vector2 from_b, Vector2 to_b ) // 检查线段（from，to）是否与球心为 sphere_position、半径为 sphere_radius 的球体相交。如果没有，返回一个空的 PoolVector3Array。如果相交，返回一个包含交点和交点处球体法线的 PoolVector3Array。 PoolVector3Array segment_intersects_sphere ( Vector3 from, Vector3 to, Vector3 sphere_position, float sphere_radius ) // 测试段（from，to）是否与三角形a，b，c相交。如果是，返回相交点为Vector3。如果没有发生相交，则返回一个空的Variant。 Variant segment_intersects_triangle ( Vector3 from, Vector3 to, Vector3 a, Vector3 b, Vector3 c ) 缩放 Array offset_polygon_2d ( PoolVector2Array polygon, float delta, PolyJoinType join_type=0 ) // 通过 delta 单位（像素）膨胀或缩小多边形 polygon。如果 delta 是正数，使多边形向外增长。如果 delta 是负数，则使多边形向内收缩。返回一个多边形数组，因为膨胀或缩小可能导致多个离散的多边形。如果 delta 为负数，并且其绝对值大约超过了多边形的最小边界矩形尺寸，则返回一个空数组。 // 每个多边形的顶点将按照 join_type 确定的方式进行圆角处理，见 PolyJoinType。 // 注意：要具体平移多边形的顶点，请使用 Transform2D.xform 方法。 // eg: var polygon = PoolVector2Array([ Vector2(0, 0), Vector2(100, 0), Vector2(100, 100), Vector2(0, 100) ] ) var offset = Vector2(50, 50) polygon = Transform2D(0, offset).xform(polygon) print(polygon) #打印出 [Vector2(50, 50), Vector2(150, 50), Vector2(150, 150), Vector2(50, 150)] 。 // 通过delta单位（像素）对多边形线polyline进行充气或放气，产生多边形。如果delta为正数，则使多段线向外增长。返回一个多边形数组，因为充气/放气可能导致多个离散的多边形。如果delta为负数，返回一个空数组。 // 每个多边形的顶点将由join_type决定，见PolyJoinType。 // 每个多边形的端点将由end_type决定，见PolyEndType。 Array offset_polyline_2d ( PoolVector2Array polyline, float delta, PolyJoinType join_type=0, PolyEndType end_type=3 ) 其他 // 给定表示图块的Vector2数组，构建一个地图集。返回的字典有两个键：points是Vector2的向量，用于指定每个图块的位置，size包含整个图集的整体大小，作为Vector2。 // 不太明白这个有什么用 Dictionary make_atlas ( PoolVector2Array sizes ) // 对由离散的 point 点集合指定的区域进行三角化，使得任何点都不在任何结果三角形的外接圆内。返回一个 PoolIntArray，其中每个三角形由 point 点的三个连续的点索引组成（即返回的数组将有 n * 3 元素，n 是找到的三角形的数量）。如果三角化没有成功，将返回一个空的 PoolIntArray。 PoolIntArray triangulate_delaunay_2d ( PoolVector2Array points ) // 对多边形 polygon 中的点指定的多边形进行三角化。返回一个 PoolIntArray，其中每个三角形由 polygon 中三个连续的点索引组成（即返回的数组将有 n * 3 个元素，n 是找到的三角形的数量）。如果三角化没有成功，将返回一个空的 PoolIntArray。 PoolIntArray triangulate_polygon ( PoolVector2Array polygon ) ","link":"https://xuaii.github.io/post/godot-geometry/"},{"title":"算法学习列表","content":"参考列表 Wialliam Fiset's Algorithms Keon's Algorithms Xtaci's Algorithms Labuladong's Fucking-Algorithms Geekxh's Hello-Algorithms Algorithm-Visualizer Justjavac's Free-Programming-Books Imarvinle's Awesome-CS-Books Jeffe's Algorithms Course 主要关注其中 操作系统、算法、图形学、设计模式、游戏引擎、C#、 C/C++ 、编译器中间语言、元编程 Jeffe's Crouse 用于学习，Wialliam Fiset's Algorithms, Keon's Algorithms, Xtaci's Algorithms 用于拓展补充，labuladong 的算法小抄, 小浩算法 用于练习 这是一个利用空闲时间学习的长期计划，或许需要几年时间，学不完没关系，学一点赚一点，加油！ 数据结构 Balance Trees AVL Tree (recursive) Red Black Tree (recursive) Binary Search Tree Splay Tree Dynamic Array Dynamic Array (integer only, fast) Fenwick Tree Fenwick Tree (range query, point update) (range update, point query) Fibonacci Heap Hashtable Hashtable (double hashing) Hashtable (linear probing) Hashtable (quadratic probing) Hashtable (sparate chaning) Linked List Priority Queue Min Binary Heap Min Indexed Binary Heap (sorted key-value pairs, similar to hash-table) Min D-Heap Min Indexed D-Heap (sorted key-value pairs, similar to hash table) Queue Queue (integer only, fixed size, fast) Queue (linked list, generic) Segment Tree Segement Tree (array based, compact) Segment Tree (linked list generic) Sparse Table Stack Stack (integer only, fixed size, fast) Stack (linked list, generic) Stack (array, generic) Suffix Array Suffix Array (O(n^2logn)) Suffix Array (O(nlog^2(n)) Suffix Array (O(nlogn)) Trie Union Find 数组 Array shuffle 2D Array 动态编程 Coin change problem Edit distance (iterative) Edit distance (recursive) Knapsack 0/1 Knapsack unbounded (0/inf) Maximum contiguous subarray Longest Common Subsequence (LCS) Longest Increasing Subsequence (LIS) Longest Palindrome Subsequence (LPS) Traveling Salesman Problem (dynamic programming, iterative) Traveling Salesman Problem (dynamic programming, recursive) Minimum Weight Perfect Matching (iterative, complete graph) Examples: Adhoc Magic Cows Narrow Art Gallery Tiling problems Tiling Dominoes Tiling Dominoes and Trominoes Mountain Scenes 计算几何 Angle between 2D vectors - O(1) Angle between 3D vectors - O(1) Circle-circle intersection point(s) - O(1) Circle-line intersection point(s) - O(1) Circle-line segment intersection point(s) - O(1) Circle-point tangent line(s) - O(1) Closest pair of points (line sweeping algorithm) - O(nlog(n)) Collinear points test (are three 2D points on the same line) - O(1) Convex hull (Graham Scan algorithm) - O(nlog(n)) Convex hull (Monotone chain algorithm) - O(nlog(n)) Convex polygon area - O(n) Convex polygon cut - O(n) Convex polygon contains points - O(log(n)) Coplanar points test (are four 3D points on the same plane) - O(1) Line class (handy infinite line class) - O(1) Line-circle intersection point(s) - O(1) Line segment-circle intersection point(s) - O(1) Line segment to general form (ax + by = c) - O(1) Line segment-line segment intersection - O(1) Longitude-Latitude geographic distance - O(1) Point is inside triangle check - O(1) Point rotation about point - O(1) Triangle area algorithms - O(1) [UNTESTED] Circle-circle intersection area - O(1) [UNTESTED] Circular segment area - O(1) 图论 Tree algorithms 🎥 Rooting an undirected tree - O(V+E) 🎥 Identifying isomorphic trees - O(?) 🎥 Tree center(s) - O(V+E) Tree diameter - O(V+E) 🎥 Lowest Common Ancestor (LCA, Euler tour) - O(1) queries, O(nlogn) preprocessing Network flow 🎥 Lowest Common Ancestor (LCA, Euler tour) - O(1) queries, O(nlogn) preprocessing **Network flow** Bipartite graph verification (adjacency list) - O(V+E) 🎥 Max flow & Min cut (Ford-Fulkerson with DFS, adjacency list) - O(fE) Max flow & Min cut (Ford-Fulkerson with DFS, adjacency matrix) - O(fV2) 🎥 Max flow & Min cut (Edmonds-Karp, adjacency list) - O(VE2) 🎥 Max flow & Min cut (Capacity scaling, adjacency list) - O(E2log2(U)) 🎥 Max flow & Min cut (Dinic's, adjacency list) - O(EV2) or O(E√V) for bipartite graphs Maximum Cardinality Bipartite Matching (augmenting path algorithm, adjacency list) - O(VE) Min Cost Max Flow (Bellman-Ford, adjacency list) - O(E2V2) Min Cost Max Flow (Johnson's algorithm, adjacency list) - O(E2Vlog(V)) Main graph theory algorithms Min Cost Max Flow (Johnson's algorithm, adjacency list) - O(E2Vlog(V)) **Main graph theory algorithms** Articulation points/cut vertices (adjacency list) - O(V+E) Bellman-Ford (edge list, negative cycles, fast & optimized) - O(VE) 🎥 Bellman-Ford (adjacency list, negative cycles) - O(VE) Bellman-Ford (adjacency matrix, negative cycles) - O(V3) 🎥 Breadth first search (adjacency list) - O(V+E) Breadth first search (adjacency list, fast queue) - O(V+E) Bridges/cut edges (adjacency list) - O(V+E) Find connected components (adjacency list, union find) - O(Elog(E)) Find connected components (adjacency list, DFS) - O(V+E) Depth first search (adjacency list, iterative) - O(V+E) Depth first search (adjacency list, iterative, fast stack) - O(V+E) 🎥 Depth first search (adjacency list, recursive) - O(V+E) 🎥 Dijkstra's shortest path (adjacency list, lazy implementation) - O(Elog(V)) 🎥 Dijkstra's shortest path (adjacency list, eager implementation + D-ary heap) - O(ElogE/V(V)) 🎥 Eulerian Path (directed edges) - O(E+V) 🎥 Floyd Warshall algorithm (adjacency matrix, negative cycle check) - O(V3) Graph diameter (adjacency list) - O(VE) 🎥 Kahn's algorithm (topological sort, adjacency list) - O(E+V) Kruskal's min spanning tree algorithm (edge list, union find) - O(Elog(E)) 🎥 Kruskal's min spanning tree algorithm (edge list, union find, lazy sorting) - O(Elog(E)) Kosaraju's strongly connected components algorithm (adjacency list) - O(V+E) 🎥 Prim's min spanning tree algorithm (lazy version, adjacency list) - O(Elog(E)) Prim's min spanning tree algorithm (lazy version, adjacency matrix) - O(V2) 🎥 Prim's min spanning tree algorithm (eager version, adjacency list) - O(Elog(V)) Steiner tree (minimum spanning tree generalization) - O(V3 + V2 _ 2T + V _ 3T) 🎥 Tarjan's strongly connected components algorithm (adjacency list) - O(V+E) 🎥 Topological sort (acyclic graph, adjacency list) - O(V+E) Topological sort (acyclic graph, adjacency matrix) - O(V2) Traveling Salesman Problem (brute force) - O(n!) 🎥 Traveling Salesman Problem (dynamic programming, iterative) - O(n22n) Traveling Salesman Problem (dynamic programming, recursive) - O(n22n) 线性代数 Freivald's algorithm (matrix multiplication verification) - O(kn2) Gaussian elimination (solve system of linear equations) - O(cr2) Gaussian elimination (modular version, prime finite field) - O(cr2) Linear recurrence solver (finds nth term in a recurrence relation) - O(m3log(n)) Matrix determinant (Laplace/cofactor expansion) - O((n+2)!) Matrix inverse - O(n3) Matrix multiplication - O(n3) Matrix power - O(n3log(p)) Square matrix rotation - O(n2) 数学 Arbitrary Integer [UNTESTED] Chinese remainder theorem Prime number sieve (sieve of Eratosthenes) - O(nlog(log(n))) Prime number sieve (sieve of Eratosthenes, compressed) - O(nlog(log(n))) Prime test(trial division) Prime test(Miller-Rabin's method) Totient function (phi function, relatively prime number count) - O(n1/4) Totient function using sieve (phi function, relatively prime number count) - O(nlog(log(n))) Extended euclidean algorithm - ~O(log(a + b)) Greatest Common Divisor (GCD) - ~O(log(a + b)) Fast Fourier transform (quick polynomial multiplication) - O(nlog(n)) Fast Fourier transform (quick polynomial multiplication, complex numbers) - O(nlog(n)) Primality check - O(√n) Primality check (Rabin-Miller) - O(k) Least Common Multiple (LCM) - ~O(log(a + b)) Modular inverse - ~O(log(a + b)) Prime factorization (pollard rho) - O(n1/4) Relatively prime check (coprimality check) - ~O(log(a + b)) 搜索算法 Binary search (real numbers) - O(log(n)) Interpolation search (discrete discrete) - O(n) or O(log(log(n))) with uniform input Ternary search (real numbers) - O(log(n)) Ternary search (discrete numbers) - O(log(n)) 排序算法 Bubble sort - O(n2) Bucket sort - Θ(n + k) Counting sort - O(n + k) Heapsort - O(nlog(n)) Insertion sort - O(n2) Mergesort - O(nlog(n)) Quicksort (in-place, Hoare partitioning) - Θ(nlog(n)) Quicksort3 (Dutch National Flag algorithm) - Θ(nlog(n)) Selection sort - O(n2) Radix sort - O(n*w) 字符串算法 Booth's algorithm (finds lexicographically smallest string rotation) - O(n) Knuth-Morris-Pratt algorithm (finds pattern matches in text) - O(n+m) Longest Common Prefix (LCP) array - O(nlog(n)) bounded by SA construction, otherwise O(n) 🎥 Longest Common Substring (LCS) - O(nlog(n)) bounded by SA construction, otherwise O(n) 🎥 Longest Repeated Substring (LRS) - O(nlog(n)) Manacher's algorithm (finds all palindromes in text) - O(n) Rabin-Karp algorithm (finds pattern match positions in text) - O(n+m) Substring verification with suffix array - O(nlog(n)) SA construction and O(mlog(n)) per query 其他 Bit manipulations - O(1) List permutations - O(n!) 🎥 Power set (set of all subsets) - O(2n) Set combinations - O(n choose r) Set combinations with repetition - O((n+r-1) choose r) Sliding Window Minimum/Maximum - O(1) Square Root Decomposition - O(1) point updates, O(√n) range queries Unique set combinations - O(n choose r) Lazy Range Adder - O(1) range updates, O(n) to finalize all updates Linear congruential generator Maximum subarray problem Bit-Set Double linked list Skip list Dynamic order statistics Interval tree Prefix Tree(Trie) Suffix Tree B-Tree hash Hash by multiplication Hash table Universal hash function Perfect hash Java's string hash FNV-1a string hash SimHash Bloom Filter 密码学 SHA-1 Message Digest Algorithm MD5 Base64 Push–Relabel algorithm Huffman Coding Word segementation A* algorithm K-Means Knuth–Morris–Pratt algorithm Disjoint-Set 8-Queen Problem ","link":"https://xuaii.github.io/post/suan-fa-xue-xi-lie-biao/"},{"title":"C# 10 新特性","content":"C# 10 向 C# 语言添加了以下功能和增强功能： 1. 记录结构 2. 结构类型的改进 C# 10 引入了与结构类型相关的以下改进： 可以在结构类型中声明实例无参数构造函数，并在声明实例字段或属性时对它们进行初始化。 with 表达式的左侧操作数可以是任何结构类型，也可以是匿名（引用）类型。 3. 内插字符串处理程序 可以创建一种类型，该类型从内插字符串表达式生成结果字符串。 .NET 库在许多 API 中都使用此功能。 可以按照本教程生成一个内插字符串处理程序。就是说不用拼接字符串，直接 Format，早该有了啊，怎么现在才有？？？ 4. global using 指令 5. 文件范围的命名空间声明 可使用 namespace 声明的新形式，声明所有后续声明都是已声明的命名空间的成员： namespace MyNamespace; 6. 扩展属性模式 7. 对 Lambda 表达式的改进 C# 10 包括了对 Lambda 表达式的处理方式的许多改进： Lambda 表达式可以具有自然类型，这使编译器可从 Lambda 表达式或方法组推断委托类型。 如果编译器无法推断返回类型，Lambda 表达式可以声明该类型。 属性可应用于 Lambda 表达式。 这些功能使 Lambda 表达式更类似于方法和本地函数。 在不声明委托类型的变量的情况下，这些改进使得人们可以更容易使用 Lambda 表达式，并且它们可以与新的 ASP.NET Core 最小 API 更无缝地工作。 8. 可使用 const 内插字符串 9. 记录类型可密封 ToString() 在 C# 10 中，在记录类型中重写 ToString 时可以添加 sealed 修饰符。 密封 ToString 方法可阻止编译器为任何派生的记录类型合成 ToString 方法。 sealedToString 确保了所有派生记录类型都使用某个通用基记录类型中定义的 ToString 方法。 若要详细了解此功能，请阅读有关记录的文章。 10. 改进型明确赋值 11. 在同一析构中可同时进行赋值和声明 c# 的解构 此更改取消了早期 C# 版本中的限制。 以前，析构可以将所有值赋给现有变量，或将新声明的变量初始化： // Initialization: (int x, int y) = point; // assignment: int x1 = 0; int y1 = 0; (x1, y1) = point; C# 10 取消了此限制： int x = 0; (x, int y) = point; 12. 可在方法上使用 AsyncMethodBuilder 属性 13. CallerArgumentExpression 属性 可以使用 System.Runtime.CompilerServices.CallerArgumentExpressionAttribute 来指定编译器用另一个实参的文本表示形式替换的形参。 此功能使库可以创建更具体的诊断。 以下代码测试条件。 如果条件为 false，则异常消息包含传递给 condition 的参数的文本表示形式： public static void Validate(bool condition, [CallerArgumentExpression(&quot;condition&quot;)] string? message=null) { if (!condition) { throw new InvalidOperationException($&quot;Argument failed validation: &lt;{message}&gt;&quot;); } } 这个挺牛的，可以在函数形参的地方检查实参名字。 14. 增强的 #line pragma 15. 警告波 6 ","link":"https://xuaii.github.io/post/c-10-xin-te-xing/"},{"title":"[Idea] XR 游戏灵感","content":"最近 Nreal Air 眼睛发售，看到有玩家自制的 游戏王AR 游戏，能将怪物真的召唤到场地，非常震撼，于是思考能不能将传统的游戏类型用AR来表达呢？ 很自然的想到了 马里奥赛车：实况，借鉴这样的思路可以想到一种全新的游戏类型，以马里奥：奥德赛为例，AR眼睛首先识别出所在场景中所有的物体，这里主要包括以下类别： 平台 常见可交互物体（例如放在茶几上的书📕📖） 游戏通过识别出的几何体来构建场景🌃，按照模板关卡程序生成关卡，在各个物体的背后埋藏小惊喜（可以在现实中移动物体，可以操作马里奥与物体交互），这些物体都是程序预设的可交互物体模型，玩家通过发现各个现实场景中的潜在的关卡模板，然后进行闯关，通过关卡即可收集该关卡模板，并能够与朋友分享🧑‍🤝‍🧑 这个想法需要解决以下技术难点： 稳定的识别出预设物体 通过一个只包含3D几何体的场景，生成关卡 要决定哪些物体将变为平台，哪些能将玩家吹起来，哪些是移动平台，等 要决定在什么放置金币🪙，放置怪物，放置惊喜 需要程序来决定如何通过金币，惊喜，来引导玩家走向终点 如果现有的场景无法构建出关卡，还要决定在什么位置添加平台，辅助完成关卡 玩家如何操作角色（手柄🕹🎮？手势？APP？） 其中最复杂的应该是生成场景的规则？这是一个复杂的工程，想到这里就不往下想了🧠，想也想不明白，等着任天堂做吧？交给你了任天堂💕！ ","link":"https://xuaii.github.io/post/idea-xr-you-xi-ling-gan/"},{"title":"[挖坑] Godot 联网 HTTP && RPC","content":"读教程 ","link":"https://xuaii.github.io/post/wa-keng-godot-lian-wang-http-and-rpc/"},{"title":"[挖坑] c++ / c# / python 的 Lambda 表达式","content":" c++ 功能最多了 c# 只能引用捕获，不能值捕获，真尼玛抽象 python 这个b东西也是引用，没有值捕获 ","link":"https://xuaii.github.io/post/wa-keng-c-c-python-de-lambda-biao-da-shi/"},{"title":"[计算机组成原理] 中央处理器","content":"中央处理器(Central Processing Unit，简称CPU) CPU 功能和基本结构 CPU 功能 指令控制（取指，分析，执行） 操作控制一条指令执行，需要控制的各个门电路信号 时间控制 系统时钟 数据加工 算术逻辑运算 中断处理 异常和特殊请求的处理 结构 运算器 算术逻辑单元，暂存寄存器，累加寄存器，通用寄存器组，程序状态字寄存器 控制器 程序计数器，指令寄存器，指令译码器，存储器地址寄存器，存储器数据寄存器 指令执行过程 1. 指令周期 取指周期： 从内存中读取指令 间址周期：取一次和多次间址 执行周期： 中断周期：每条指令执行完成后查询中断请求，如果有中断请求则进入中断周期 为了区别不同周期，使用标志触发器 FE, IND, EX, INT 表示各个周期，取 1 为有效值 2. 指令周期的数据流 取指周期 PC -&gt; MAR -&gt; 地址总线 -&gt; 主存 CU读命令 -&gt; 控制总线 -&gt; 主存 主存 -&gt; 数据总线 -&gt; MDR -&gt; IR CU控制信号 -&gt; PC+1 间地周期 Ad(IR) -&gt; MAR -&gt; 地址总线 -&gt; 主存 CU 读命令 -&gt; 控制总线 -&gt; 主存 主存 -&gt; 数据总线 -&gt;MDR 中断周期 CU控制SP-1， SP-&gt;MAR-&gt;地址总线-&gt;主存 CU写命令-&gt;控制总线-&gt;主存 PC-&gt;MDR-&gt;数据总线-&gt;主存（存入断点） CU（中断服务程序入口） -&gt; PC 3. 指令执行方案 单周期：每条指令时钟周期数固定 多周期：每条指令使用不同周期数，但是指令只能一条执行完才能执行下一条 流水线：流水（参考MIPS 五级流水） 数据通路的功能和基本结构 1. 数据通路功能 描述信息从什么地方开始，中间经过了哪些寄存器和开关，传送到哪个寄存器 2. 数据通路结构 CPU内单总线方式：所有东西通过公共同通路传输，冲突概率较高，性能低 CPU内三总线方式：提高效率，数据总线，地址总线，控制总线 专用数据通路方式：需要传送数据的地方直接安排连线，性能高，硬件量大 寄存器间数据传送 PC -&gt; Bus Bus -&gt; MAR 主存 &amp; CPU 信息传送 PC -&gt; Bus -&gt; MAR 1 -&gt; R MEM(MAR) -&gt; MDR MDR -&gt; Bus -&gt; IR 执行算术逻辑运算 Ad(IR) -&gt; Bus -&gt; MAR 1 -&gt; R MEM-&gt;数据线-&gt;MDR MDR -&gt; Bus -&gt;Y (ACC) + (Y) -&gt; Z Z -&gt; ACC 控制器 计算机的五大功能部件 控制器部件 运算器部件 输入设备 / 输出设备 内存储器 他们之间通过 数据总线、地址总线、控制总线 相互通信，其中输入输出设备是通过接口电路连接的 控制器部件从数据总线接受指令 从运算器不见接受指令转移地址 送出 指令地址 到 地址总线 向系统中的部件提供运行所需的控制信号 控制器的主要功能： 取指令和指出下一条指令的地址 对指令进行译码 和 测试，以产生相应操作的控制信号 指挥并控制 CPU、主存、输入输出设备之间的数据流动方向 根据控制器产生微操作控制信号的方式不同，分为硬布线控制器 和 微程序控制器， 其中 PC 和 IR 是相同的，但是确定和表示指令执行步骤的办法和需要的控制信号是不同的 硬布线控制器 根据指令要求、当前时序、外部和内部状态，按时间顺序发送一系列微操作控制信号（也叫做组合逻辑控制器）。 区别于微程序控制器使用的微指令，硬布线控制器是直接采用组合逻辑电路实现机器指令，以 “使用最少零部件，去的最高速度” 作为设计目标，优点是速度快（电路延迟），缺点是不易添加新的功能 硬布线控制单元图 硬布线控制单元，从 CU 中分离出 操作码译码器， 节拍发生器，其中操作译码器将 N 位操作码翻译为 2N2^N2N 位， 再输入 CU。 节拍发生器 产生的节拍(T1, T2, T3, ...) 由 机器主频(CLK) 分频得到，CU 使用 操作码， 节拍信号， 状态标志 在不同的节拍输出不同的控制信号（微操作命令 CiC_iCi​） 使用节拍的原因 首先信号发出到稳定需要一个极短的时间间隔，所以 CPU 需要有一个最短时间（类似于我们的普朗克时间），其次，一个 机器指令，需要由多个微操作来完成，微操作按照一定的顺序生效，所以需要节拍 来区分微操作顺序 例如： 操作A -&gt; 操作B -&gt; 操作C out = T1 * A + T2 * B + T3 * C 按节拍顺序执行操作，总之技巧是通过逻辑组合控制各个开关,结合节拍器控制顺序（详见4） 硬布线控制器的时序系统和微操作 时钟周期：时钟信号控制的节拍发生器，每个节拍的宽度正好是时钟周期，每个节拍内可以完成一个/几个需要同时完成的操作 机器周期：所有指令执行的基准时间（完成一个基本操作需要的时间），通常取存取周期作为基准时间，在存储字长等于指令字长时，存取周期 = 机器周期 一个机器周期内，完成若干微操作，通过时钟信号控制产生每个微操作 指令周期：取出并执行一条指令的时间 微操作命令分析：指令分为三个周期 取值周期-&gt;间址周期-&gt;执行周期 取址 PC -&gt; MAR 1 -&gt; R M(MAR) -&gt; MDR MDR -&gt; IR OP(IR) -&gt; CU (PC) + 1 -&gt; PC 间址周期 Ad(IR) -&gt; MAR 1 -&gt; R M(MAR) -&gt; MDR 执行周期 a. 非访存指令 CLA // 清ACC COM // 取反 SHR // 算术右移 CSL // 循环左移 STOP // 停机指令 b. 访存指令 ADD X // 加法指令 Ad(IR) -&gt; MAR, 1 -&gt; R M(MAR) -&gt; MDR (ACC) + (MDR) -&gt; ACC STA X // 存数指令 Ad(IR) -&gt; MAR, 1 -&gt; W ACC -&gt; MDR MDR -&gt; M(MAR) LDA X // 取数指令 Ad(IR) -&gt; MAR, 1 -&gt; R M(MAR) -&gt; MDR MDR -&gt; ACC c. 转移指令 JMP X =&gt; Ad(IR) -&gt; PC BAN X =&gt; A0 * Ad(IR) + (~A0) * (PC) -&gt; PC CPU 控制方式 控制一条指令本质是依次执行一个确定的微操作序列， 不同指令对应的微操作数量和复杂度不一样,因此每条指令执行时间不相同，使用以下三种方法控制： 同步控制 所有控制信号都来自统一系统时钟，一最长微操作和最繁琐微操作为标准，采取统一、相同时间间隔、相同节拍数 作为机器周期来运行不同指令 特点：简单，速度慢（因为短命令也需要经过长周期） 异步控制 不存在 基准信号，各个部件按照自身固有速度工作，通过异步应答方式交流 特点：快速，控制复杂 联合控制 介于同步和异步之间，对不同的指令的微操作实行大部分采用同步控制，小部分采用异步控制 硬布线控制单元设计步骤 步骤一: 列出微操作命令时间表 以下是 CLR， COM， SHR 等10条机器指令微操作命令的时间表，观察表结构，共有工作周期标记、节拍、状态条件、微操作命令信号、微操作命令表项，其中一个工作周期可能包含多个节拍， 其中一个节拍内可以完成多个独立的微操作命令（不独立的命令会造成冲突） 步骤二: 微操作信号综合 微操作控制信号=机器周期∧节拍∧脉冲∧操作码∧机器状态条件微操作控制信号 = 机器周期 \\land 节拍 \\land 脉冲 \\land 操作码 \\land 机器状态条件 微操作控制信号=机器周期∧节拍∧脉冲∧操作码∧机器状态条件 根据表构造逻辑表达式，然后经过化简整理得到可用现有门电路实现的微操作命令逻辑表达式： 步骤三: 绘制微操作命令组合电路图（没什么技巧，就嗯画） 微程序控制器 在电路和机器指令之间添加了一层微程序，根据机器指令生成微指令序列（微程序），使用微程序来实现机器指令功能，而微程序是存储在 控制存储器（CM in CPU） 中的指令序列，优点是规整、灵活、可维护，缺点是每次都要从 CM 中取微指令，速度慢 微程序控制基本概念 就是把微操作信号 代码化， 使每条机器指令转化为一段微程序存入控制存储器中（CM），微程序包含若干微指令，每条微指令对应1/n个微操作。 微命令 &amp; 微操作 ： 机器指令 -&gt; 微操作序列，在微程序控制计算机中，将控制部件向执行部件发送的控制命令称为微命令，例如：打开或关闭某个门电位信号，微操作是微命令的执行过程。 注意微命令的 相容 和 相斥 微指令 &amp; 微周期：微指令是若干微命令的集合（命令就是一位，指令就是一行），存放为微指令的控制存储器单元地址成为微地址，微指令包含两部分信息： 操作控制字段：控制信号 顺序控制字段：下一条微指令地址 微周期是指读取并执行一条微指令花费的时间 主存储器 &amp; 控制存储器：主存是在 CPU 外部的RAM， 控制存储器是在 CPU 内部的ROM 程序 &amp; 微程序： 微程序是机器指令的实时解释器，是在CPU 制造时预先设计和存储的，对程序员透明的 相关寄存器：地址寄存器(MAR)， 微地址寄存器(CMAR)，指令寄存器(IR)，微指令寄存器(CMDR / μ\\muμIR) 微程序控制器组成和工作过程 组成 控制存储器，微指令寄存器，微地址形成部件（产生最初地址和后继地址），微地址寄存器 工作过程 取微指令公共操作 ==&gt; 机器开始时，自动将取指微程序入口地址送入 CMAR，并取址；一般时 CM 的 0号地址，该微程序完成后 主存中取出的机器指令就存储在 IR 中 IR 操作码 ==&gt; 微地址形成部件 ==&gt; 微程序入口地址 ==&gt; CMAR 从CM 中逐条取出指令并执行，执行完一段微程序后回到取址微程序入口，周而复始 微指令的编码方式 直接编码 ： 无需译码，每一位表示一个微命令，简单直观快速，并行性好，缺点是控制存储器容量变大 字段直接编码：将微指令的微命令分成若干小段，把互斥性微命令组合在同一字段，把相容性微命令组合在不同字段，每个字段独立编码，各个字段编码单独定义，互不干扰 优点：缩短字长 缺点：通过译码电路减速 分段原则 互斥命令同段，相容命令不同段 每个段信息为不能太多 每个小段留出一个状态表示无命令（000），因此状态数 = 2N−12^N - 12N−1 字段间接编码：一个字段某些命令需要由另一些字段来解释，进一步减小了字长，削弱了并行能力，通常作为辅助手段 微指令的地址形成方式 有两种基本类型 直接由微指令的下地址字段指出（断定方式） 根据机器指令的操作码形成，通过微地址形成部件形成 几种额外类型： 增量计数 (CMAR) + 1 -&gt; CMAR, 连续存放 根据标志位决定微指令分支转移地址 通过测试网络形成 由硬件直接产生微程序入口地址 加电后第一条微指令地址可以由专门的硬件电路产生 微指令的格式 水平型微指令： 指令中一位对应一个控制信号，优点：程序短，执行速度快；缺点：微指令长，编写微程序麻烦 垂直型微指令：采用类似机器指令的 操作数 | 操作码 | 操作码 的结构，优点：微指令短，简单，规整，便于编写；缺点是微程序长执行速度慢 混合型微指令：在垂直型的基础上增加一些不太复杂的并行操作，性能折中 微程序控制单元的设计步骤 写出微操作命令的节拍安排 这里与之前的微操作表的区别是： 取指阶段需要将 IR的操作码送往微地址形成部件, OP(IR) -&gt; CMAR 每条微指令执行完成后都需要形成后继微指令 , 微地址形成部件 -&gt; CMAR 确定微指令格式 微指令编码方式，后继指令形成方式，微指令字长 一般根据微操作个数决定编码方式，确定微指令操作控制字段位数， 由微指令数决定微指令顺序控制字段位数 按操作控制字段位数和顺序控制字段位数决定微指令字长 动态微程序设计和毫微程序设计 动态微程序就是可以更改的微程序，一般使用 EPROM，豪微程序试就是在微程序和电路之间再增加一层解释程序 异常和中断机制 概念 异常 是 CPU 内部产生的意外事件，被称为内中断，是内部检测，与执行的指令相关的同步事件 中断 是 CPU 发出的中断请求，被称为外中断，由外部设备触发，与当前执行指令无关 描述如下： CPU 在执行用户程序第 i 条指令是检测到异常事件 或 第 i 条指令后发现一个中断请求信号，则 CPU 打断当前用户程序，然后转到相应的异常或中断处理程序去执行。 若异常或中断处理程序能解决相应问题，则在处理程序的最后 CPU 指向异常或中断返回指令，回到被打断的用户程序第 i 条指令或 第 i + 1 条指令继续执行 若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序 一般来说，对终端和异常的具体处理由操作系统（和驱动程序）完成 分类 异常的分类 故障（Fault）：在故障指令启动后，指令结束前被检查到的异常事件，例如：译码时出现非法操作码；取数据时发生缺页缺段；除数为0；其中有的能通过磁盘调入主存来解决，像除数为0这样的异常不能解决并回到原断点继续执行，必须终止进程的执行 自陷（Trap）：是预先安排的一种异常，事先在程序中用一条特殊的指令或通过特殊标志的设定来人为造成陷阱，执行到被设置了陷阱的指令时，CPU 在执行完自陷指令后，自动根据不同陷阱进行相应处理，然后返回自陷指令的下一条执行。 特别的，如果当前指令是转移指令，那不会返回到下一条指令继续执行，而是返回到目标指令继续执行 例如：程序断点调试， 系统调用指令，条件自陷指令都属于陷阱指令，执行到这些指令时，无条件的或有条件的自动调出操作系统内核程序进行执行 故障异常和自陷异常属于程序性异常 终止（Abort）：指令执行过程中发生了使计算机无法继续执行的硬件故障，如控制器出错，存储器校验错误等，程序无法继续执行，只能终止，此时调出中断服务程序来重启系统，这种异常和故障不由特定指令造成，而是随机发生的，属于硬件异常 中断的分类 可屏蔽中断：通过可屏蔽中断请求线INTR 向 CPU 发送的中断请求，CPU可通过在中断控制器中设置相应的屏蔽字来屏蔽或不屏蔽它，被屏蔽的中断请求不会送到 CPU 不可屏蔽中断：通过专门的 不可屏蔽中断请求线NMI 向 CPU 发出中断请求，通常是紧急的硬件故障，如电源掉电 响应 过程为 ： 关中断 -&gt; 保存断点和程序状态 -&gt; 识别异常和中断并转移到相应的处理程序 **关中断 在保存断点和程序状态期间不能被新的中断打断，通过设置中断允许(IF)触发器 来实现禁止响应新的中断： IF == 1 开中断，允许响应中断 IF == 0 关中断，不允许响应中断 保存断点和程序状态 将程序断点（返回地址）送到栈或特定寄存器，通常保存在栈中（为了支持异常或中断的嵌套），状态字寄存器 PSWR 也需要保存到栈或者特定寄存器中。 识别异常和中断并转移到相应处理程序 异常大多数采用软件识别，中断由硬件识别和软件识别两种方式 软件识别是 CPU 设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或终端查询程序，按优先级查询异常状态寄存器，以检查中断或异常的类型，先查询到的先处理，然后转到内核中相应处理程序 硬件识别也就是向量中断，异常或中断程序的首地址称为中断向量，所有中断向量存放在中断向量表中，每个异常或中断都被指定一个中断类型号，在中断向量表中类型号和中断向量一一对应，因为可以根据类型号快速找到对应的处理程序。 中断或异常的响应是不可被打断的。中断响应结束后 CPU 就从 PC 中取出中断服务程序的第一条指令开始执行，直到中断返回，整个过程是由软硬件协同完成的 *指令流水线 1. 基本概念 MIPS 指令流水将指令分成以下五个阶段，每一个时钟到来就会有一条指令进入流水 取指(IF) 从存储器/Cache中取指令（PC，指令寄存器，下一条指令地址计算逻辑） 译码(ID) 对指令进行译码，（操作控制器，去操作数逻辑，立即数符号扩展） 执行(EX) 执行运算/计算地址，（ALU，分支地址计算模块） 访存(MEM) 访问存储器，（数据存储器读写模块） 写回(WB) 将计算结果写回寄存器堆， （寄存器写入控制模块） 区分阶段的企图是，划分 CPU 运行过程中的阶段，分析他们的关联性方便同时多条指令在不同部件上运行 流水原则：流水阶段个数以最复杂指令所用的功能段个数为准，流水长度以最耗时操作花费时间为准 便于流水的指令集特征： 指令长度尽量一致，简化取指，译码 指令格式尽量规整，比如第几位是寄存器编号，第几位是地址，这样方便指令未知时直接通过位数取操作数 采用 Load / Store 指令，这样可以包访存指令的地址计算和运算指令的执行步骤规整在同一周期（不懂什么意思） 数据和指令对齐存放，减少访存次数 大量连续任务才能提高流水效率，流水延长单个指令执行时间，缩短整体执行时间 Tips:流水线需要多个锁存器来存储上一流水阶段的计算结果，控制信号，等来进行下一阶段计算 2. 流水线冒险 结构冒险 多条指令同时访问同一资源（例如：存储器，取指和访存都要访问） 解决： 访存时流水暂停 区分数据存储器 和 指令存储器（事实上 L1 cache 就是这样区分的） 数据冒险 分为 写后读、 读后写、 写后写 三种 解决： 流水暂停(stall，硬件实现), NOP空指令(编译器实现) 数据旁路技术（数据前推） 编译优化调整指令顺序 控制冒险 指令跳转、调用过程、返回等会改变 PC 寄存器值的指令，会导致控制冒险 以前采用延迟槽方法（即在跳转指令后插入无论如何都要执行的指令），现代 CPU 都使用分支预测的方法，预测成功什么都不会发生，预测失败就清空流水线 解决： 分支预测 （分为动态和静态预测） 预取转移成功和不成功两个方向的指令 加快提前形成条件码 提高转移方向的猜准率 3. 性能指标 流水线吞吐率(TP) TP=nTk=n(k+n−1)∗ΔtTPmax=lim⁡n→∞n(k+n−1)∗Δt=1ΔtTP = \\frac{n}{T_k} = \\frac{n}{(k+n-1)*\\Delta t}\\\\ TP_{max} = \\lim\\limits_{n\\rightarrow\\infty}\\frac{n}{(k+n-1)*\\Delta t} = \\frac{1}{\\Delta t} TP=Tk​n​=(k+n−1)∗Δtn​TPmax​=n→∞lim​(k+n−1)∗Δtn​=Δt1​ 流水线加速比(S) S=T0Tk=knΔt(k+n−1)∗ΔtSmax=lim⁡n→∞knΔt(k+n−1)∗Δt=kS = \\frac{T_0}{T_k} = \\frac{kn\\Delta t}{(k+n-1)*\\Delta t}\\\\ S_{max} = \\lim\\limits_{n\\rightarrow\\infty}\\frac{kn\\Delta t}{(k+n-1)*\\Delta t} = k S=Tk​T0​​=(k+n−1)∗ΔtknΔt​Smax​=n→∞lim​(k+n−1)∗ΔtknΔt​=k 其中，n 是指令数量， k 是流水阶段数， Δt\\Delta tΔt 是时钟周期 4. 高级流水线技术 处理机一次发射多条指令的多发射技术，增加流水线级数的超流水线技术 超标量流水线技术：不能调整指令执行顺序，并行执行指令搭配 超长指令字技术：也称静态多发射技术，编译程序挖掘程序潜在并行性，将多条能并行的指令组合成一条具有多个操作码的指令（几百位），需要多个部件处理 超流水线技术：增加级数，每级的操作量减小，纳闷呢时钟周期就可以减小，但是依然是一个周期进入一条指令，总的来讲效率提高 多处理器基本概念 SISD、SIMD、MIMD SISD 是传统的串行计算机结构，包含一个处理器一个存储器，指令按规定顺序执行，SISD 为了提高效率采用流水的方式，之前的内容大都是 SISD 结构 SIMD 是指一个指令同时对多个数据流进行处理，成为数据级并行技术，通常由一个指令控制部件、多个处理单元组成，每个单元执行同一条指令，但每个处理单元都有自己的地址寄存器，因此每个单元都有不同的数据地址，因此，不同处理单元在不同数据集上执行相同的指令。 一个应用程序被编译后可能按SISD在串行硬件上执行，也可能按SIMD 组织并运行于并行硬件上 SIMD 在使用 for 循环处理数组时最有效，例如：对16对数据进行运算的 SIMD 指令如果在16个ALU中同时运算，只需要一次运算时间就能完成。SIMD 在使用 case-switch 语句时效率最低，此时每个执行单元必须根据不同数据执行不同操作。 MISD 是同时执行多条指令，处理同一个数据，实际上不存在这样的计算机 MIMD 同时执行多条指令处理不同数据，分为多计算机系统 和 多处理器系统 多计算机系统中每个计算机节点都具有各自私有的存储器，和独立的主存空间，不能相关通过存取指令访问。需要通过消息传递进行数据传送。 多处理器系统是共享多处理器系统SMP的简称，它共享单一地址空间，通过存取指令访问多有存储器 硬件多线程 目的减小线程切换开销 细粒度多线程 多个线程之间轮流交换执行指令，线程间指令不相关，可以乱序并行执行。处理器能在每个时钟周期切换线程 粗粒度多线程 在线程出现较大开销阻塞时切换线程，如 cache 缺失。这种情况下，当发生流水阻塞时，必须清除被阻塞的流水线，新的线程指令开始执行前需要重载流水线，因此开销很大 同时多线程（SMT） 是上述两种多线程技术的变体。在实现指令级并行的同时，实现线程级并行，也就是说，在一个时钟周期内，发射多个不同线程中的多条指令执行。Intel 中的超线程技术就是同时对线程，即在一个单处理器或单个核中设置两套线程状态部件，共享高速缓存和功能部件。 多核处理器 多个处理单元集成到单个CPU，每个核可以有自己的 cache，也可以共享 cache，共享主存储器 共享内存多处理器 通过存储器中的共享变量相互通信，可以在各个处理器自己的虚拟地址空间单独运行 统一存储访问（UMA）多处理器：分为基于总线，基于交叉开关网络，基于多级交换网络 连接等几种处理器 非统一存储访问（NUMA）多处理器：处理器中不带高速缓存时被称为 NC-NUMA，带有一致性高速缓存时被称为 CC-NUMA 最初内存控制器没有整合进 CPU， 需要通过北桥的内存控制器访问内存，这种架构随着 多核 CPU 的发展而达到瓶颈（争用前端总线），所以NUMA 架构诞生，每个 CPU 分配一个内存区域，而 CPU 之间通过 QPI 总线相连，CPU 通过 QPI 访问其他CPU的远程内存。 由于内存共享， 对于共享变量需要使用同步机制，例如对变量加锁 3 ","link":"https://xuaii.github.io/post/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"title":"[游戏机制] 里世界机制优化","content":"在之前的文章里提到过 里世界机制 游戏机制，但是最初的版本是需要手动用右摇杆移动 &quot;透镜&quot; 来观察里世界的物体，这样的设计有以下几个缺陷： 需要控制左右摇杆和跳跃键来控制人物和移动 &quot;透镜&quot; 透镜 自由度过高，限制了关卡设计的可能性 仅仅实现了遮挡 / 显示 物体，并没有修改物体的碰撞体积 后来玩到 《塞尔达传说三角力量 2》 ，其中林克化身壁画在墙壁游走的能力给了我很大的启发：&quot;壁画林克只能在一条水平线上移动，而作者利用地形的高低差设计了很多意想不到的关卡&quot;, 这背后的思考是 &quot;通过限制玩家的能力，来增加关卡设计的可能性&quot;，回到里世界机制上，我们可以通过限制&quot;透镜&quot;的移动和玩家进入的方式来增加关卡设计的可能性： 于是，我对机制进行如下修正: 通过推箱子的形式移动透镜，而不是用右摇杆 限制透镜的进入点，而不是全开放 这样的修正可以以某种方式设计关卡，让玩家思考以何种顺序移动各个箱子能到达想要去的目标，它的本质是推箱子， 只是换上了一层 里世界 的皮 下面来构思整个机制的实现： 实现 &quot;透镜&quot; 内的物体不显示, 之外的物体显示 -&gt; 使用光照剔除 实现 &quot;透镜&quot; 内的物体与玩家碰撞，之外的物体不碰撞 -&gt; 使用 PolygenShape动态修改 实现 推箱子 机制 -&gt; 箱子内和箱子都能推动（避免死锁） 光照剔除 在之前的实现里，将里世界的所有物体放入一个单独的 CanvasLayer，再应用一个 CanvasModulate 将不透明度设置为 0， 然后用一一个 Light2D 来为里世界物体添加 透明度，这样实现玩家不能与里世界物体发生物理交互所以采用了很复杂的实现方式。 Godot Light2D 有一个 Mask 模式专门用于剔除物体，被剔除的物体需要确保 层号在 (layer_min, layer_max) 之间 光照层在 Item Cull Mask 之中 使用一个 Texture 与透镜大小相同的 Light2D 节点， 选择 Add / Mix 模式位被剔除的物体赋予颜色，同样需要确保光照层和画布层设置正确 此外，可以通过 WorldEnviroment 节点为里世界的物体增加荧光，或者设置边缘光 Shader 增加区分度。 动态碰撞体 动态碰撞体很简单，只需要每帧取碰撞体矩形 DefaultRect 透镜碰撞体矩形 LensRect，计算两个 Rect2 的 ∩ 即可 public class LensRect : Area2D { public Dictionary&lt;string, Godot.Object&gt; NearbyLens = new Dictionary&lt;string, Godot.Object&gt;(); Vector2 extent; CollisionShape2D shape; public override void _Ready() { shape = GetNode&lt;CollisionShape2D&gt;(nameof(CollisionShape2D)); extent = (shape.Shape as RectangleShape2D).Extents; } // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta) { foreach(DynamicPolygon polygon in NearbyLens.Values) { polygon.Clips(ToGlobal(shape.Position - extent), ToGlobal(shape.Position + extent)); } } void _on_LensRect_area_entered(Area2D body) { Node parent = body.GetParent(); if(parent is DynamicPolygon) { NearbyLens[parent.Name] = parent; } } void _on_LensRect_area_exited(Area2D body) { Node parent = body.GetParent(); if(parent is DynamicPolygon) { NearbyLens.Remove(parent.Name); } } } Lens 需要使用一个 Area2D 记录附近可能相交的里世界物体，在每一个物理帧调用 polygon.Clips() 更新附近里世界物体的多边形点集 对于每一个里世界物体， 只需实现 Clips 方法， 并保证碰撞体附近没有 Lens 时，碰撞体保持休眠状态 public class DynamicPolygon : KinematicBody2D { private CollisionPolygon2D shape; private Rect2 rect; public override void _Ready() { Sprite sprite = GetNode&lt;Sprite&gt;(nameof(Sprite)); shape = GetNode&lt;CollisionPolygon2D&gt;(nameof(CollisionPolygon2D)); rect = sprite.GetRect(); ; } // Called every frame. 'delta' is the elapsed time since the previous frame. public void Clips(Vector2 p1, Vector2 p2) { Rect2 _rect = new Rect2(ToLocal(p1), ToLocal(p2) - ToLocal(p1)); Rect2 inter = rect.Clip(_rect); Vector2 [] array = new Vector2[4]; Vector2 local = inter.Position; array[0] = local; array[1] = local + Vector2.Right * inter.Size.x; array[2] = local + inter.Size; array[3] = local + Vector2.Down * inter.Size.y; shape.Polygon = array; } void _on_Area2D_area_entered(Area2D area) { if (area is LensRect magic) { shape.SetDeferred(&quot;disabled&quot;, false); } } void _on_Area2D_area_exited(Area2D area) { if (area is LensRect magic) { shape.SetDeferred(&quot;disabled&quot;, true); } } } 这个地方有很多可以优化的点（下次一定），例如： 目前仅支持 矩形 Lens 和 矩形里世界物体，可以考虑支持任意多边形 可以优化同时对 多个Lens， 多个 里世界物体 更新（例如使用 ECS， 做一个 System 统一更新，效率更高，也可以做一些向量优化，maybe） 实现 其他 PhysicsBody 的里世界物体 添加 [Tool]编辑器代码，方便 Debug 推箱子 首先实现箱子类，他是一个可推动接口，实现 Push 和Stop方法, 受到重力影响 public interface IPushable { void Push(Vector2 direction); void Stop(); } public class TestMovableCube : KinematicBody2D, IPushable { private Vector2 _velocity = Vector2.Zero; [Export] private float _pushSpeed = 100f; public override void _PhysicsProcess(float delta) { _velocity += Vector2.Down * 100f; _velocity = MoveAndSlide(_velocity); } public void Push(Vector2 direction) { _velocity += _pushSpeed * direction; } public void Stop() { _velocity = Vector2.Zero; } } 其次是 玩家/怪物的Push状态, 这里在每一帧计算正在推动的物体列表， 然后每帧调用IPushable.Push() 方法，每帧开始时和退出状态时需要将所有正在推动的物体停下来（否则将做匀速直线运动） /* 状态有四个生命周期, 进入, 更新， 物理更新， 退出 有 Init 接口函数用于初始化，有 Exit() 方法用于退出当前状态 */ public class Push : StateBase { private Player target; private List&lt;IPushable&gt; cacheCubes = new List&lt;IPushable&gt;(); public override void OnEnter() { target = agent as Player; GD.Print(&quot;Enter &quot;, StateName); } public override void Update(float delta) { } public override void PhysicsUpdate(float delta) { target.GravityHandler(target.DefaultGravity.JumpGravity, delta); target.GestureHandler(); target.HorizontalHandler(); target.SnapHandler(); foreach (var cube in cacheCubes) { cube.Stop(); } cacheCubes.Clear(); for (int i = 0; i &lt; target.GetSlideCount(); i++) { // tips: Godot.Collections.Array dont support the c# interface var collision = target.GetSlideCollision(i); if (collision.Collider is IPushable pushable) { GD.Print(collision.Normal); cacheCubes.Add(pushable); pushable.Push(-collision.Normal); } } if ((!Input.IsActionPressed(&quot;ui_left&quot;) &amp;&amp; !Input.IsActionPressed(&quot;ui_right&quot;)) || target.JumpRequest() || !target.IsOnFloor() ) { Exit(); } } public override void OnExit() { foreach (var cube in cacheCubes) { cube.Stop(); } GD.Print(&quot;Exit &quot;, StateName); } } Tips: 这里为什么不让物体自己动? 而是要推动者维护一个推动列表呢？如果 IPushable 自己动，即使 Player 紧贴着 IPushable推动，IPushable仍然不能在每帧检测到有 Player 正在推它，这会导致 IPushable 移动时断断续续的（不清楚这是bug还是特性) 美化 - 添加进出口特效 由于这本来是一个原型项目，所以只实现见简单特效即可（主要是花里胡哨的我也不会），Lens的进出口使用激光门（就是两束激光） 激光实现 - RayCast2D - Position2D - Sprite - CPUParticals2D [Tool] public class Laser : RayCast2D { Sprite sprite; Position2D anchor; float default_length = 580f; Vector2 target = Vector2.Right*10; CPUParticles2D articles; public override void _Ready() { anchor = GetNode&lt;Position2D&gt;(nameof(Position2D)); sprite = anchor.GetNode&lt;Sprite&gt;(nameof(Sprite)); Enabled = true; articles = GetNode&lt;CPUParticles2D&gt;(&quot;LaserPartical&quot;); Scale = Vector2.One; } // // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta) { anchor.Rotation = anchor.Position.AngleToPoint(CastTo) + Mathf.Pi; float dis; if (!Engine.EditorHint) { if (IsColliding()) { target = GetCollisionPoint(); articles.GlobalPosition = GetCollisionPoint(); articles.Direction = GetCollisionNormal(); articles.Emitting = true; } else { articles.Emitting = false; } dis = ToLocal(target).Length(); } else { dis = CastTo.Length(); } anchor.Scale = new Vector2(dis / default_length, anchor.Scale.y); } } 激光使用了Energy Beams - Godot Shaders 的实现， 使用一个 Texture 表示一个激光，这种做法可以使用Shader 计算扰动，但是对于本题这种点到点激光，并且可能发生转动的情况下，还是很不方便，在计算起始/结束点和激光 Sprite 的Scale 的关系时不太好计算（主要是 Sprite 只能通过 Scale 调整大小而不便指定 Rect 的 Size， 好像也可以,emmm）， 激光命中的粒子就随便弄一弄就好了。 一些思考核问题 在实现过程中遇到很多问题： 被推动的箱子时主动移动还是被动移动? 箱子使用 KinamicBody 还是RigidBody（能够模拟下落，抛，旋转）? 箱子应该从内部移动还是外部移动? 是否需要设计里世界物体Mask？（例如，红箱子只能显示红色物体，绿箱子只能显示绿物体，其实应该有Mask，这样可以增加关卡设计的多样性） 是否应该设置里世界物体的显示时间？（可以增加该机制） Godot.Collections.Array 不能存放 C# 接口，会报错，不知道是 Bug还是什么？ 是否应该有其他多边形状的 Lens 和 里世界物体？ （应该有的） Lens 的矩形是否应该有很多个进出口？（为了方便机制设计，应该有，所以一个Lens有很多个 PolyShape） 是否里世界物体应该高亮（应该的，为了区分里外物体，但是还没想好高亮应该怎么做？边缘发光，荧光，虚线还是整体发光？） 是否应该区分Lens 的可推动部分和不可推动部分？（应该，有利于复杂关卡设计） ","link":"https://xuaii.github.io/post/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"title":"[计算机组成原理] 计算机指令系统","content":"指令 计算机指令是机器码，是汇编码，是硬件软件交互界面；指令长度是CPU指令长度（例如：32 位/64位） 常规的指令形式是 OP + Address * n; 指令字长和机器字长没有固定关系，通常有半指令字长，单指令字长，双指令字长，此外指令长度可以是固定的也可以是不定的，通常来说定长指令更易于处理 零地址指令 不需要操作数的指令(空操作，停机，关中断指令)， 堆栈计算机指令 一地址指令 OP(A1)→A1OP(A_1)\\rightarrow A_1OP(A1​)→A1​(自增,自减,求反求补) (ACC)OP(A−1)→ACC(ACC)OP(A-1)\\rightarrow ACC(ACC)OP(A−1)→ACC, 隐含约定地址， 计算寻址范围 二地址指令 算术指令，逻辑运算指令 指令含义 (A1)OP(A2)→A1(A_1)OP(A_2)\\rightarrow A_1(A1​)OP(A2​)→A1​ 三地址指令 (A1)OP(A2)→A3(A_1)OP(A_2)\\rightarrow A_3(A1​)OP(A2​)→A3​, 如果地址均为主存地址， 完成该类指令需要四次访存(取指令 * 1， 取操作数2， 存放结果1) 四地址指令 最后一个地址 A4A_4A4​ 是下一条将要执行的指令 指令扩展 虽然现代处理器采用大都采用定长指令，但是为了在此基础上保留指令的丰富类别，采用可变长操作码的定长指令；这意味着操作码位数长度不变，且分散在指令的不同位置，这将增加指令的译码难度，增加控制器复杂度。 指令操作类型 数据传送 寄存器之间的传送(MOV) 从内存单元读取数据到CPU寄存器(LOAD) 从CPU寄存器写数据到内存单元(STORE) 算术和逻辑 加(ADD)、 减(SUB)、 乘(MUL)、 除(DIV)、 比较(CMP)、 加1(INC)、 减1(DEC)、 与(AND)、或(OR)、 取反(NOT)、 亦或(XOR) 移位操作 算法移位、逻辑移位、循环移位 转移操作 无条件转移(JMP) 条件转移(BRANCH) 调用(CALL) 返回(RET) 陷阱(TRAP) 输入输出操作 完成 CPU 与外部设备交换数据或传送控制命令及状态信息 指令寻址方式 '' 寻址方式是指寻找指令或指令操作数有效地址的方式 '' 寻址方式分为指令寻址和数据寻址两类 指令中数据字段代表的不是真实地址而是形式地址， 形式地址结合寻址方式可以计算真实地址 如果 A 表示寄存器编号或者内存地址， 那么 (A) 表示其中保存的值 指令寻址 顺序寻址: 程序计数器PC++，自动形成下一条指令地址 跳跃寻址: 跳跃寻址的地址依然是由 PC 寄存器指出的， 指令跳跃收到 状态寄存器 和 操作数的控制，跳跃地址可以是直接由标记符得到，也可以由当前指令偏移得到；即 绝对地址 和 相对地址 数据寻址 本质是如何在指令中 表示 操作数的地址，如何用这种表示计算出 操作数地址 隐含寻址 例如单地址指令中隐含的地址一样，操作数地址隐含在操作码的定义里 立即数寻址 补码表示操作数直接在指令中给出，例如 ADD 1 1 优点 是过程中不用访存 缺点 立即数长度限制了立即数范围 直接寻址 直接在指令中指出操作数地址的真实值 优点 是简单仅访问一次内存 缺点 是指令长度决定了地址的上限，操作数的地址修改不容易！ 间接寻址 指令地址给出操作数地址所在储存单元的地址， 也就是需要一次间接寻址，间接寻址也可以是多次间接寻址，通过主存中取得的字的第一位的取值判断是否是取得操作数地址： 取 0， 表示当前地址是操作数地址 取 1， 表示当前地址是操作数间址 优点 扩大寻址范围，方便子程序返回 缺点 多次访存， 一般扩大寻址地址的方法是寄存器间接寻址 寄存器寻址 直接在指令字中给出操作数所在寄存器编号 优点 不访问主存，执行速度快， 支持向量矩阵运算 缺点 寄存器价格贵，数量有限 寄存器间接寻址 在指令字中给出寄存器编号，该寄存器内存储操作数的地址 优点 速度更快，用于扩展寻址范围 缺点 只能一次间址，需要访问主存 相对寻址 相对寻址是相对于 PC 上加上指令偏移量 A 而形成的有效地址，A 可正可负，补码表示 优点 操作数地址不固定，广泛用于转移指令 缺点 A 的位数决定寻址范围 注意 PC 寄存器取下一条指令后自增，然后再加上偏移量 基址寻址 实际地址 EA = (BR) + A，即基址 + 形式地址。基址寄存器是面向操作系统的，主要解决程序逻辑空间与储存器物理空间无关 优点 扩大寻址范围，利于多道程序设计，利于编写非线性程序（浮动程序），用于各种页表，段表实现 缺点 形式地址位数较短 变址寻址 变址寄存器寻址是 形式地址 A + 变址寄存器 IX，这里的变址寄存器区别于基址寄存器，是面向用户的，其中 IX 的位数足以表示整个存储空间 优点 扩大寻址范围，便于编制循环程序，用于实现数组，因为指令中的 A 是固定的， 而IX是可以由用户设定的 缺点 A 不可变？硬找借口？ 堆栈寻址 堆栈是存储器(或专用寄存器)中一块特定的，后进先出的(LIFO) 原则管理的存储区，该存储区中 读/写单元的地址使用一个特定寄存器SP给出的，硬堆栈/软堆栈。 硬堆栈 是寄存器堆栈，速度快，成本高，不适合做大容量堆栈 软堆栈 是主存中划分的一段区域，速度稍慢，成本低，适合大容量 寻址方式 有效地址 访存次数 隐含寻址 程序指定 0 立即寻址 A是操作数 0 直接寻址 EA=A 1 一次间接寻址 EA=(A) 2 寄存器寻址 EA=R_i 0 寄存器一次间接寻址 EA=(R_i) 1 相对寻址 EA=(PC)+A 1 基址寻址 EA=(BR)+A 1 变址寻址 EA=(IX)+A 1 程序的机器码表示 - 汇编 x86 处理器中包含8个32位通用寄存器 寄存器名称 位数 说明 EAX 32 累加器(Accumulator) EBX 32 基址寄存器(Base Register) ECX 32 计数寄存器(Count Register) EDX 32 数据寄存器(Data Register) ESI 32 变址寄存器(Index Register) EDI 32 变址寄存器(Index Register) EBP 32 堆栈基指针(Base Pointer) ESP 32 堆栈顶指针(Stack Pointer) 说明 前四个寄存器 EAX, EBX, ECX, EDX 都是32位寄存器，但是可以仅仅访问其中的半字例如：(EAX=AH+ALEAX = AH + ALEAX=AH+AL), 除EBP和ESP外，其余寄存器的使用是比较任意的。 x64 汇编增加了几个寄存器和引入新的指令格式，在此仅学习 x86汇编。 环境配置 vscode + MASM/TASM 插件 测试代码如下： DATA SEGMENT MESG DB &quot;This is an Assembly Language Programe.&quot;, 0DH, 0AH, &quot;$&quot; SPACE DB &quot; &quot;, &quot;$&quot; DATA ENDS CODE SEGMENT ASSUME CS:CODE, DS:DATA START: MOV AX, DATA MOV DS, AX ; 将 DATA 段的段首址存入 DS MOV BX, 01H ; BX 初始值设为 1 AGAIN: MOV DX, OFFSET MESG ; 取欲显示的字符偏移量赋给 DX MOV AH, 09H ; 调用 9号(显示)DOS功能子程序 INT 21H MOV CX, BX ; 将 BX 的值赋给 CX INC BX NEXT: MOV DX, OFFSET SPACE ; 取空格字符偏移量赋给 DX MOV AH, 09H INT 21H LOOP NEXT ; 继续显示空格字符，直到 CX 为 0 CMP BX, 10 ; BX 与 10 比较 JBE AGAIN ; 没显示 10 次，转移到 AGAIN 继续执行程序 MOV AH, 4CH INT 21H ; 返回 DOS CODE ENDS END START 右键 运行/调试 汇编指令格式 AT&amp;T格式和Intel格式区别如下 项目/区别 AT&amp;T Intel 大小写 小写 大小写不敏感 操作数 第一个为源操作数,第二个为目的操作数 第一个位目的操作数，第一个为源操作数 前缀 寄存器前缀%，立即数前缀$ 不需要前缀 寻址 使用&quot;(&quot;和&quot;)&quot; 使用&quot;[&quot; 和 &quot;]&quot; 复杂寻址 disp(base, index, scale), 表示偏移量，基址寄存器， 变址寄存器，比例因子;如 8(%edx, %eax, 2) [edx+eax*2+8] 数据长度 在操作码后边一个字符表示操作数大小 b-&gt;byte, w-&gt;word, l-&gt;long 显式的注明byte ptr, word ptr, dword ptr 注意 由于32位或64位体系结构都是由16位扩展而来，因此用 word(字) 表示16位 常用机器指令 汇编指令通常可以分为 数据传送指令， 逻辑计算指令， 控制流指令 以下以** Intel 格式**为例介绍重要指令: 约定 &lt;reg32&gt; 表示eax,ebx,edx,.... &lt;reg16&gt; 表示ax, bx, dx &lt;reg8&gt; 表示ah, al, bh,bl,... &lt;mem&gt; 表示内存地址，如[eax]、[var+4]、dword ptr [eax+ebx] &lt;con&gt; 表示8位、16位或32位常数 mov 指令 将 第二个操作数(寄存器，内存，常数内容) 复制到 第一个操作数(寄存器或内存)，不能用于内存到内存的复制 mov &lt;reg&gt;,&lt;reg&gt; mov &lt;reg&gt;,&lt;mem&gt; mov &lt;mem&gt;,&lt;reg&gt; mov &lt;reg&gt;,&lt;con&gt; mov &lt;mem&gt;,&lt;con&gt; push 指令 将操作数压入内存的栈，常用于函数调用。ESP 是栈顶指针，压栈前 ESP-=4，栈增长方向与内存地址增长方向相反，然后将操作数压入 ESP 指示的地址 push &lt;reg32&gt; push &lt;mem&gt; push &lt;con32&gt; // 栈元素固定 32 位 eg: push eax push [var] pop 指令 将栈顶元素送出，pop指令将 ESP 地址内容出栈，再将 ESP 值加 4 pop edi pop [ebx] add/sub 指令 将两个操作数相加/减，结果保存到第一个操作数中 add &lt;reg&gt;,&lt;reg&gt; / sub &lt;reg&gt;,&lt;reg&gt; add &lt;reg&gt;,&lt;mem&gt; / sub &lt;reg&gt;,&lt;mem&gt; add &lt;mem&gt;,&lt;reg&gt; / sub &lt;mem&gt;,&lt;reg&gt; add &lt;reg&gt;,&lt;con&gt; / sub &lt;reg&gt;,&lt;con&gt; add &lt;mem&gt;,&lt;con&gt; / sub &lt;mem&gt;,&lt;con&gt; inc/dec 指令 操作数自增自减指令 inc &lt;reg&gt; / dec &lt;reg&gt; inc &lt;mem&gt; / dec &lt;mem&gt; // eg: dec eax inc dword ptr [var] imul 指令 带符号整数乘法指令，有两种形式 1. 两个操作数相加结果保存到第一个操作数 2. 三个操作数后两个数相加结果保存到第一个操作数 imul &lt;reg32&gt;,&lt;reg32&gt; imul &lt;reg32&gt;,&lt;mem&gt; imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt; imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt; // tag: 这里显然不能存储到 &lt;mem&gt; 所以该过程最多只有一次非读指令访存 // 如果乘法操作可能溢出，则编译器溢出标志 OF = 1，是CPU调溢出处理程序 idiv 指令 带符号整数除法指令，他只有一个操作数，而被除数为 edx:eax中的内容（是拼接的64位整数），操作结果有两部分：商和余数，商-&gt;eax, 余数-&gt;edx // (edx:eax) / op_1 = edx:eax idiv &lt;reg32&gt; idiv &lt;mem&gt; // eg: idiv ebx idiv dword ptr [var] and/or/xor 指令 结果放在第一个操作数里 and &lt;reg&gt;,&lt;reg&gt; / or &lt;reg&gt;,&lt;reg&gt; / xor &lt;reg&gt;,&lt;reg&gt; and &lt;reg&gt;,&lt;mem&gt; / or &lt;reg&gt;,&lt;mem&gt; / xor &lt;reg&gt;,&lt;mem&gt; and &lt;mem&gt;,&lt;reg&gt; / or &lt;mem&gt;,&lt;reg&gt; / xor &lt;mem&gt;,&lt;reg&gt; and &lt;reg&gt;,&lt;con&gt; / or &lt;reg&gt;,&lt;con&gt; / xor &lt;reg&gt;,&lt;con&gt; and &lt;mem&gt;,&lt;con&gt; / or &lt;mem&gt;,&lt;con&gt; / xor &lt;mem&gt;,&lt;con&gt; // eg: and eax, 0fH xor edx, edx not 指令 位反转指令，将操作数每一位反转 not &lt;reg&gt; not &lt;mem&gt; // example: not byte ptr [var] neg 指令 取负指令 neg &lt;reg&gt; neg &lt;mem&gt; // eg: neg eax shl/shr 指令 逻辑移位指令， l 为左， r 为右，第一个操作数是被移位，第二个操作数是移位位数 shl &lt;reg&gt;,&lt;con8&gt; / shr &lt;reg&gt;,&lt;con8&gt; shl &lt;mem&gt;,&lt;con8&gt; / shr &lt;mem&gt;,&lt;con8&gt; shl &lt;reg&gt;,&lt;cl&gt; / shr &lt;reg&gt;,&lt;cl&gt; shl &lt;mem&gt;,&lt;cl&gt; / shr &lt;mem&gt;,&lt;cl&gt; // cl 是 8 位寄存器 // eg： shl eax, 1 shr ebx cl 标签 IP 寄存器是 CPU 硬件结构，其值是不能直接指定的，只能通过控制流指令来更改，在 x86 汇编中使用标签来标记代码地址 movesi, [ebp+8] begin: xor ecx, ecx mov eax, [esi] jump 指令 直接跳转类似 goto 语句 jmp &lt;label&gt; // eg: jmp begin j&lt;condition&gt; 指令 条件转移指令 je &lt;label&gt; (jump when equal) jne &lt;label&gt; (jump when not equal) jz &lt;label&gt; (jump when last result was zero) jg &lt;label&gt; (jump when greater than) jge &lt;label&gt; (jump when greater than or equal to) jl &lt;label&gt; (jump when less than) jle &lt;label&gt; (jump when less than or equal to) // eg: cmp eax, ebx jle done // tips:这里的跳转指令并不依赖某个寄存器的值，而是依赖 由cmp和test指令确定的 CPU 的状态值 cmp/test 指令 cmp 用于比较两个操作数的值，test 对两个数进行逐位与运算，他们不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码 cmp &lt;reg&gt;,&lt;reg&gt; / test &lt;reg&gt;,&lt;reg&gt; cmp &lt;mem&gt;,&lt;reg&gt; / test &lt;mem&gt;,&lt;reg&gt; cmp &lt;reg&gt;,&lt;mem&gt; / test &lt;reg&gt;,&lt;mem&gt; cmp &lt;reg&gt;,&lt;con&gt; / test &lt;reg&gt;,&lt;con&gt; // tips:cmp,test和jcondotion指令搭配使用，举例： cmp dword ptr [var], 10 // 比较 4 字节 jne loop // 相等继续执行，否则跳转到loop test eax, eax // 测试eax 是否为0 jz xxxx // 为0则设置标志位 ZF 位1，跳转到 xxxx 处执行 call/ret 指令 用于实现子程序（过程，函数等）的调用和返回， call 指令将当前执行的指令地址入栈，然后无条件转移到有标签指示的指令。call指令还会保存调用之前的信息。 ret 实现了子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址。 call &lt;label&gt; ret 过程调用机器表示 使用 call/ret 指令实现过程调用，假定过程P(调用者) 和 过程Q(被调用者)，过程调用步骤如下： P 将入口参数放在 Q 能访问到的地方 P 将返回地址存到特定的地方，然后将控制权转移到 Q (IP寄存器指向) Q 保存 P 的现场(通用寄存器的内容)，并为自己的非静态局部变量分配空间 执行过程 Q Q 回复 P 的现场，将结果放到 P 能访问到的地方，并释放局部变量所占空间 Q 取出返回地址，将控制转移到 P 注意 ： 上述步骤中需要为入口参数，返回地址，过程P现场，过程Q局部变量，返回结果 找到存放空间，而用户可见的寄存器数量是有限的，因此需要在内存中用一个栈来存放数据，EAX、ECX、EDX是调用者保存寄存器，其保存和恢复过程由P负责。EBX、ESI、EDI 是被调用则保存寄存器，每一个过程都有其自己的栈区，成为栈帧(Stack Frame)。寄存器 EBP指示栈底，ESP 指向栈顶，栈从高地址向低地址增长。 例如 // 被调用函数/过程 int add(int x, int y){ return x + y; } // 调用者过程 int caller(){ int temp1 = 125; int temp2 = 80; int sum = add(temp1, temp2); return sum; } 经过 GCC 编译后 caller 过程的汇编码如下 ： caller: # stage 1 pushl %ebp movl %esp, %ebp # 系统栈 &amp;&amp; 用户栈 # ebp 和 esp 是 用户栈 指针 # 而 push 指令是对系统栈的操作 # 1. 将当前用户栈基址压入系统栈 # 2. 新用户栈基址设为栈顶指针 subl $24, %esp # 为当前过程开辟 24B 内存空间(栈帧) # 此时 esp = ebp - 24，所以栈顶指针更小 # 这里 只用了 28B，是因为 GCC 规定栈帧必须是16B的整数倍 # stage 2 定义变量 movl $125, -12(%ebp) # 这里的变量是由 esp 向 ebp 方向依次放置 movl $80, -8(%ebp) # stage 3 传入函数参数 movl -8(%ebp), %eax mov %eax, 4(%esp) # temp2 先入栈 movl -12(%ebp), %eax movl %eax, (%esp) # temp1 后入栈 # stage 4 调用函数 call add # stage 5 取出函数返回值 movl %eax, -4(%ebp) # 将返回值取出到变量 sum movl -4(%ebp), %eax # 将 sum 作为返回值 # 返回值是通过 eax 寄存器返回的，所以E(A|C|D)X寄存器是由调用者返回的 # stage 6 离开 add 函数 leave # 等价于： # movl %ebp, %esp # popl %ebp # stage 7 退出当前 caller 过程 ret add 过程对应过程的汇编码如下 push %ebp mov %esp, %ebp mov 0xc(%ebp), %eax # 将参数2放入寄存器 # 这里的栈帧是有高位向低位 # 函数参数是从右往左入栈 mov 0x8(%ebp), %edx # 将参数1放入寄存器 lea (%edx, %eax, 1), %eax # 将add_1传入add_2 # 这里是直接通过地址计算 # 使用 lea 指令是因为不占用 ALU，比较快 # 使用单指令代替了多条指令 pop %ebp ret Question：传入参数时是将参数的临时变量拷贝到了 4(%esp) 和 (%esp)，但是为什么在 add 过程中取参数时是取的 0xc(%ebp) 和 0x8(%ebp)？？ Answer： 因为 call 指令会改变 esp 寄存器的值，会将函数返回地址入栈，然后 esp += 4 选择语句机器表示 以 c 语言为例，选择语句主要是 if-then, if-then-else, switch, 编译器条件码(标志位)设置指令各类转移指令来实现选择结构语句 条件码（标志位） 条件码是CPU维护的状态寄存器，他们描述算术逻辑操作的属性，可以检测这些寄存器来执行分支指令： CF 进(借)位标志，适用于最近的无符号整数加减运算，有进(借)位 CF = 1 ZF 零标志，标志最近操作结果是否为0 SF 符号标志，标志最近的带符号数运算结果，负 :SF = 1 OF 溢出标志，标志最近带符号数运算结果是否溢出 由于OF，SF对无符号数无意义， CF对带符号数无意义，常见的算术逻辑运算指令都会设置条件码 IF 语句 通用形式如下 if(test_expr) then_statement else else_statement 翻译为 goto 语句形式 t = test_expr; if(!t) goto false; then_statement goto done; false: else_statement done: 对于下面的 c 语言函数 int get_count(int *p1, int *p2) { if(p1 &gt; p2) return *p2; else return *p1; } 将得到以下汇编码 movl 8(%ebp), %eax movl 12(%ebp), %edx cmpl %edx %eax jbe .L1 movl (%edx), %eax jmp .L2 .L1: movl (%eax), %eax .L2: SWITCH 语句 对于 小范围 和 小量 的选择语句，使用 跳转表，对于大范围或者大量的选择语句编译器还是会和 if-then-else 一样的方式来处理 跳转表即： .L12: .long .L3 .long .L4 .long .L5 .long .L6 .long .L7 .long .L8 这样就可以通过 相对于 .L12 的偏移量来计算真实的跳转目的地了，这样的跳转只需一个指令来找到跳转目的，而不是多层的 if-else 嵌套，有点字典内味了。这也解释了为什么switch-case语句需要break来退出case，因为所有的case在地址上是连续的。 循环语句机器表示 常规的循环语句 有while,for, do-while 大多数编译器都将上述三种形式的循环语句转化为do-while 语句 DO-WHILE 循环 do body_statement while(text_expr) goto 语句形式 loop: body_statement t = test_expr; if(t) goto loop; WHILE循环 while(test_expr) body_statement 在第一次执行循环体之前先执行一次 t = test_expr; if(!t) goto done; do body_statement while(text_expr); done: t = test_expr if(!t) goto done; loop: body_statement t = test_expr; if(t) goto loop; done: FOR 循环 一般形式 for(init_expr; test_expr; update_expr) body_statement 转化为 while 循环 init_expr; while(test_expr){ body_statement update_expr; } 转化为 goto 语句 init_expr; t = test_expr; if(!t) goto done; loop: body_statement update_expr; t = test_expr; if(t) goto loop; done: int nsum_for(int n){ int i; int result = 0; for(i = 1; i&lt;=n; i++) result += i; return result; } ==== 编译 ====&gt; movl 8(%ebp), %ecx movl $0, %eax movl $1, %edx cmp %edx, %ecx jg .L2 .L1: addl %edx, %eax addl $1, %edx cmpl %ecx, %edx jle .L1 .L2: 直接按照模板即可 ","link":"https://xuaii.github.io/post/ji-suan-ji-zhi-ling-xi-tong/"},{"title":"[挖坑] 游戏引擎的并行架构 && 内存管理 && ECS","content":" 最近看了 GAMES104 的 实体(Entites) 组件(Components) 系统(System) 又在复习操作系统和计算机组成原理，可以试图总结一下ECS系统与缓存命中之间的关系 unity ecs ue5 mass godot ecs 实现 反面教材 某rogulike游戏后端 ecs ecs的缺点 和 优点 ecs 与 oo 的选择 抛开架构的的优化（有时候渲染成千上万的目标是伪需求 ","link":"https://xuaii.github.io/post/wa-keng-nei-cun-guan-li-and-ecs/"},{"title":"[挖坑] 将高级程序语言编译成红石电路","content":"既然我的世界是图灵完备的，那么一定可以将c/c++等静态语言编译成红石电路，只用提供一些基础的模块就能（输入输出，各种库）编译出确定的红石电路。 要通过代码控制我的世界，就要有 Minecraft 的API接口 Mine Player API 用于创建游戏机器人，通过对机器人的操作可以按照编译出的指令执行创建/设置方块，并且可以在游戏中录制建造过程，API功能如下： Entity knowledge and tracking. Block knowledge. You can query the world around you. Milliseconds to find any block. Physics and movement - handle all bounding boxes Attacking entities and using vehicles. Inventory management. Crafting, chests, dispensers, enchantment tables. Digging and building. Miscellaneous stuff such as knowing your health and whether it is raining. Activating blocks and using items. Chat. 使用 ANTLR4 将目标语言翻译成 AST 解析 AST 并生成 机器人行动指令 (RAC) 根据行动指令在我的世界中创建机器 要实现上述功能需要以下模块： 机器人控制器 该模块使用 Mine Player API 控制机器人操作方块 当接收到某个指令，需要指挥机器人行动 维护一个 世界对象，需要计算 创建/销毁 的位置 AST 解析器 遍历 AST 生成指令（这里的指令是位置无关的，例如创建一个变量，但是不需要知道在什么位置创建，需要 机器人控制器来计算合理的位置） 设计一个合适的 中间语言(RAC) 来表示机器人行为（位置无关） ","link":"https://xuaii.github.io/post/wa-keng-jiang-gao-ji-cheng-xu-yu-yan-bian-yi-cheng-hong-shi-dian-lu/"},{"title":"[挖坑] 基于c++的反射和脚本系统","content":"c++ 反射实现起来好像很麻烦，所以就干脆学习和借鉴已有的方案CPP-Reflection-code 环境搭建 安装 LLVM windows 下直接下载 .exe 版本安装即可 LLVM 安装 Boost 下载 &amp;&amp; 解压 压缩包 Boost 打开 x64 Native Tools Command Prompt for VS2022 切换到解压目录 &amp;&amp; 运行 bootstrap.bat 按输出提示 操作 将 LLVM-ROOT 和 BOOST-ROOT 添加到环境变量 &amp;&amp; 重启生效 按照 README 编译创建 vs 项目(vs2022 生成器参数&quot;Visual Studio 17 2022&quot;) 并且编译 打开 Examples 项目，选择一个测试项目作为启动项，并且运行测试！ tips 1:更换CPP-REFLECTION 项目的中 json11.cpp 和 json11.hpp json11， 不明白有代码有bug为什么能跑起来？ tips2:使用 Runtime 需要将 Source\\Runtime\\Common 和 Source\\Common\\Lib 目录添加到附加包含目录, 需要添加到 Runtime 的引用 CPP-REFLECTION 目录结构 Parser 各种语言元素类型（类，构造函数，枚举，External？，字段Field，函数，Global，Invokeable， Method），这是用于 解释AST节点 和 构造代码渲染数据 类型。 模块 Module（是一个代码集合，其中包含 classes ， globals， globalfuncs，enums 一个词法分析器？意义不明 lang-c前端语法树模型 CursorType AST语法节点类型（例如 定义 声明 表达式 等 MetaDataConfig 配置文件 MetaDataManager 类型 用于 GetProperty GetFlag GetNativeString MetaUtils 工具类，处理字符串等C++不好处理的内特容 NameSpace 列表 用于处理嵌套名字空间 预编译 -&gt; include 列表 ReflectionOptions 反射参数 ReflectionParser 用于分析代码 提取需要反射的类，最后渲染反射代码 渲染模板路径 常量 Runtime Todo 使用方法 自定义属性 enum class SliderType { Horizontal, Vertical } Meta(Enable); struct Slider : ursine::meta::MetaProperty { META_OBJECT; SliderType type; Slider(SliderType type) : type(type) { } } Meta(Enable); struct Range : ursine::meta::MetaProperty { META_OBJECT; float min, max; Range(float min, float max) : min(min) , max(max) { } } Meta(Enable); 自定义被反射类 #pragma once #include &lt;Meta.h&gt; #include &quot;TestProperties.h&quot; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;Array.h&gt; enum TestEnum { One, Two, Three, Four, Five, Eighty = 80 } Meta(Enable); struct SoundEffect { Meta(Range(0.0f, 100.0f), Slider(SliderType::Horizontal)) float volume; void Load(const std::string &amp;filename) { std::cout &lt;&lt; &quot;Loaded sound effect \\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;.&quot; &lt;&lt; std::endl; } } Meta(Enable); struct ComplexType { std::string stringValue; int intValue; float floatValue; double doubleValue; SoundEffect soundEffect; ursine::Array&lt;int&gt; arrayValue; TestEnum enumValue; ComplexType(void) = default; } Meta(Enable); 调用方法 #include &quot;TestReflectionModule.h&quot; #include &quot;TestTypes.h&quot; #include &quot;TestProperties.h&quot; #include &quot;TypeCreator.h&quot; using namespace ursine::meta; int main(void) { MetaInitialize( UsingModule( TestModule ) ); Type soundEffectType = typeof( SoundEffect ); Field volumeField = soundEffectType.GetField( &quot;volume&quot; ); // the runtime supports overloading, but by default returns the first overload Method loadMethod = soundEffectType.GetMethod( &quot;Load&quot; ); // creates an instance of a sound effect Variant effect = TypeCreator::Create( soundEffectType ); // effect.volume is now 85 volumeField.SetValue( effect, 85.0f ); // 85 -- can also use GetValue&lt;float&gt;( ) float volumeValue = volumeField.GetValue( effect ).ToFloat( ); std::cout &lt;&lt; &quot;SoundEffect.volume: &quot; &lt;&lt; volumeValue &lt;&lt; std::endl; // effect.Load is called loadMethod.Invoke( effect, std::string { &quot;Explosion.wav&quot; } ); return 0; } Reference CPP-Reflection-code CPP-Reflection-doc ","link":"https://xuaii.github.io/post/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"title":"[摘抄] 没有色彩的多崎作和他的巡礼之年","content":"——村上春树 你要记得那些大雨中为你撑伞☔的人 帮你挡住外来之物的人🧱 黑暗中默默抱紧你🫂的人 逗你笑的人🤡 陪你彻夜聊天🌃💌的人 坐车🚉来看望你的人 陪你哭过😿的人 在医院陪你🏥的人 总是以你为重💀的人 带着你四处游荡的人 说想念你的人💕 是这些人组成你生命中一点一滴的温暖 是这些温暖使你远离阴霾 是这些温暖使你成为善良🔆的人 ","link":"https://xuaii.github.io/post/zhai-chao-mei-you-se-cai-de-duo-qi-zuo-he-ta-de-xun-li-zhi-nian/"},{"title":"[挖坑] 在Godot 中使用C++","content":"Reference GDNative 自定义服务器 多线程 Mono 绑定 GDExtension in 4.0 TSCN文件格式 ","link":"https://xuaii.github.io/post/zai-godot-zhong-shi-yong-c/"},{"title":"[Godot] 缓动曲线节点设计","content":"动机 Tween 节点可以用于创建补间动画，但是由于只能指定固定缓动函数，并且不能使用 value = f(time) 的形式计算值，所以需要设计一个新的缓动函数类，并实现对应的Inspector插件 通常的缓动曲线都是选用 三角函数，或者使用贝塞尔曲线绘制的自定义曲线，为了逼近现实的运动感，这里实现一种自动控制系统里常用的二阶曲线 SecondOrderCurves 设计 首先时二阶系统需要的三个参数，在 Godot 中使用 Vector3 表示， 以及运算过程的中间变量 // 使用插件修复 Godot 不识别自定义类型的 Bug [RegisteredTypeAttribute(nameof(SecondOrderCurves), &quot;&quot;, nameof(Godot.Object))] public class SecondOrderCurves : Godot.Object { [Export] public Vector3 Parameters = Vector3.One; private Vector2 xp; private Vector2 y, yd; private float k1, k2, k3; private float T_crit; // 用于处理单时间片无法完成的模拟 } 二阶系统的参数只有三个变量，但是我们需要一个输入函数 X(y), 和得到一个响应函数Y(y)，其中输入函数是必须的，它决定以某一时刻系统的输入, 而响应函数可以在游戏运行时实时模拟。 // 输入函数由一些点组成，是折线函数 [Export] public Array&lt;Rect2&gt; points = new Array&lt;Rect2&gt;() { new Rect2(new Vector2(0, 300), new Vector2(10, 10)), new Rect2(new Vector2(200, 300), new Vector2(10, 10)), new Rect2(new Vector2(200, 150), new Vector2(10, 10)), new Rect2(new Vector2(400, 150), new Vector2(10, 10)), }; 点集是 `X(t)` 的离散表示，对于连续值得输入，需要在两个点之间进行插值，这里简单的采用线性插值 public Vector2 Interpolate(float x) { for(int i = 0; i &lt; points.Count - 1; i++) { if(points[i].GetCenter().x &lt;= x &amp;&amp; x &lt;= points[i+1].GetCenter().x) { float y1 = points[i].GetCenter().y; float y2 = points[i+1].GetCenter().y; float x1 = points[i].GetCenter().x; float x2 = points[i+1].GetCenter().x; return new Vector2(x, (y1 - y2) / (x1 - x2) * (x - x2) + y2); } } return -1 * Vector2.One; } 对于某时刻 t 一个 X(t) 对应一个X(t); 为了计算 Y(t)，这里采用逐帧计算， // 输入 X(t), 和 delta， 得到当前t时刻的Y(t) public Vector2 Interpolate(Vector2 x, float delta) { Vector2 xd = (x - xp) / delta; xp = x; int iterations = Mathf.CeilToInt(delta / T_crit); // take extra iterations if delta &gt; T_crit delta = delta / iterations; for(int i = 0; i &lt; iterations; i++) { y = y + delta * yd; yd = yd + delta * (x + k3 * xd - y - k1*yd) / k2; } return y; } 编辑器插件设计 可以参考 Godot.Curve 的实现，但是没有开放 gdscript/c# 接口，只能使用c++拓展，比较繁琐，就自行实现显示和交互逻辑。 编辑器绘图 为了能在编辑器中看到效果，需要在编辑器环境中预览响应函数 Y(t) 的形状。所以使用 point_set 存储曲线值， 表现效果如下图所示： // 只有标记为 Tool 的脚本才会在编辑器环境被加载 [Tool] public class CurveCanvas : Control { Array&lt;Vector2&gt; point_set = new Array&lt;Vector2&gt;(); Vector2 point_size = Vector2.One * 10; } 模拟每帧的Y(t) 计算： public void ReDraw(SecondOrderCurves curve = null) { // 缓存 cached if(curve != null) { cachedCurve = curve; } else { return; } point_set.Clear(); Vector2 start = Transform(cachedCurve.StartPoint); Vector2 end = Transform(cachedCurve.EndPoint); if(start.x == -1 || end.x == -1 || cachedCurve == null) { return; } // points.Sort(new PointComp()); // Godot.Collection.Array 不支持排序，需要实现一下 cachedCurve.Init(start); int iter = 200; for(int i = 0; i &lt; iter; i++) { Vector2 x = Transform(cachedCurve.Interpolate(cachedCurve.StartPoint.x + i* (cachedCurve.EndPoint.x - cachedCurve.StartPoint.x) / iter)); Vector2 point = cachedCurve.Interpolate(new Vector2(x.y, x.y), 0.01f); point_set.Add(new Vector2(x.x * RectSize.x, (1 - point.x) * RectSize.y)); } Update(); } 由于 Godot 是以右下为正，所以需要对坐标进行转换 private Vector2 Transform(Vector2 point) { return new Vector2(point.x / RectSize.x, (RectSize.y - point.y) / RectSize.y); } 使用 Godot 的绘图函数 public override void _Draw() { // 具体就不展示了，是一些繁琐的代码 DrawMesh(); DrawPoints(); DrawCurve(); DrawInteractive(); } 编辑器交互 为了能够添加/移动/删除图像上的点， 需要实现以下功能： 单击鼠标左键添加点 长按鼠标左键移动点 单机鼠标右键删除点 public override void _Process(float delta) { cover_index = cachedCurve.FindPoint(GetLocalMousePosition()); SafeDragingArray = new Rect2(GetRect().Position, GetRect().Size - Vector2.One * 10); // 退出拖动的调节 if(Dragging &amp;&amp; IsMouseIn &amp;&amp; 0 &lt;= DraggingIndex&amp;&amp; DraggingIndex &lt; cachedCurve.points.Count &amp;&amp; SafeDragingArray.HasPoint(GetLocalMousePosition())) { (cachedCurve.points[DraggingIndex]) = new Rect2(GetLocalMousePosition(), point_size); } Update(); } 监听鼠标输入，在Godot 中连接 CurveCanvas 的鼠标信号 void _on_CurveCanvas_gui_input(InputEvent @event) { if(!IsMouseIn) { return; } if(@event is InputEventMouseButton mouse) { if(mouse.ButtonIndex == (int)ButtonList.Left) { // 1. 创建节点 if(cover_index == -1 &amp;&amp; !mouse.Pressed &amp;&amp; !Dragging) { cachedCurve.points.Add(new Rect2(GetLocalMousePosition(), point_size)); } // 2. 开始拖动 if(cover_index != -1 &amp;&amp; mouse.Pressed) { Dragging = true; DraggingIndex = cover_index; } // 3. 结束拖动 if(!mouse.Pressed) { if(Dragging) ReDraw(); Dragging = false; DraggingIndex = -1; } ReDraw(); } if(mouse.ButtonIndex == (int)ButtonList.Right) { // 删除当前 cover 的节点 if(cover_index != -1 &amp;&amp; !mouse.Pressed) { cachedCurve.points.RemoveAt(cover_index); } ReDraw(); } } } 编辑器插件（踩坑） Godot 的编辑器插件功能非常多，可以添加Dock，Inspector，主屏幕，等插件。几乎可以实现编辑器阶段的的所有拓展；这里我们主要使用 Inspector 插件来编辑 SecondOrderCurves.parameters. plugin.cs 首先在 plugin.cs 中添加加载/删除 CurveEditorInspector 的代码 tips: 千万不能忘记添加[Tool]，第一次 Build 时会报错，然后再Build一次就Ok了，原因是 C# 是需要编译的而gdscript可以热更新，所以干儿子者不如亲儿子。 #if TOOLS using Godot; using System; [Tool] public class plugin : EditorPlugin { CurveEditorInspector inspector; public override void _EnterTree() { inspector = GD.Load&lt;CSharpScript&gt;(&quot;res://addons/curve_editor/CurveEditorInspector.cs&quot;).New() as CurveEditorInspector; AddInspectorPlugin(inspector); } public override void _ExitTree() { RemoveInspectorPlugin(inspector); } } #endif EditorInspectorPlugin.cs EditorInspectorPlugin 是一个大坑，它有两种主要的运行模式： 修改单属性 修改多属性 起初我不明白 AddPropertyEditor 和 AddPropertyEditorForMultipleProperties 有什么区别，他们似乎具有相似的行为。后来理解了，在 AddPropertyEditorForMultipleProperties 中指定的属性名列表和在AddPropertyEditor 中指定属性名，这样Godot就会知道需要序列化哪些字段，并且在来回切换窗口或者充气Godot后，已经被编辑的属性能够不被重置。 using Godot; using System; #if TOOLS public class CurveEditorInspector : EditorInspectorPlugin { public override bool CanHandle(Godot.Object @object) { if(@object is SecondOrderCurves) { AddPropertyEditorForMultipleProperties(&quot;&quot;, new string [] {&quot;F&quot;, &quot;Z&quot;, &quot;R&quot;}, new CurveEditorProperty()); return true; } return false; } public override bool ParseProperty(Godot.Object @object, int type, string path, int hint, string hintText, int usage) { return false; } } #endif CurveEditorProperty.cs 这里需要指出的是，Godot规定修改属性值不能直接修改 只能通过 EmitChanged(property_name, property value); 来修改，该信号会回调UpdateProperty()方法，这里可以访问到被修改的对象(GetEditedObject())和被修改对象的属名(GetEditedProperty()); 值得注意的是，Godot 会在每一此打开Inspector 时调用UpdateProperty(),这之前会重新创建并且加载Inspector 插件对象，所以需要通过被编辑对象来恢复编辑器预览参数，并且使用IsInit 保证仅调用一次; using Godot; using System; #if TOOLS public class CurveEditorProperty : EditorProperty { Control editor; SecondOrderCurves CacheCurve = null; bool IsInit = false; // 缓存被编辑对象 public override void _Ready() { editor = GD.Load&lt;PackedScene&gt;(&quot;res://addons/curve_editor/CurveEditor.tscn&quot;).Instance&lt;Control&gt;(); AddChild(editor); AddFocusable(editor); SetBottomEditor(editor); editor.Connect(&quot;PorpertyChanged&quot;, this, &quot;OnPorpertyChanged&quot;); editor.Call(&quot;Load&quot;); } void OnPorpertyChanged(Vector3 _parameters) { EmitChanged(&quot;parameters&quot;, _parameters); } public override void UpdateProperty() { if(!IsInit) { editor.Call(&quot;Load&quot;, GetEditedObject().Get(&quot;parameters&quot;)); IsInit = true; } editor.Call(&quot;Refresh&quot;, GetEditedObject()); } } #endif CurveEditor.cs 该脚本用于总结三个HSlider的变化,并且生成PorpertyChanged 事件 using Godot; using System; // 这里的tool不能缺少 [Tool] public class CurveEditor : VBoxContainer { [Signal] public delegate void PorpertyChanged(Vector3 _parameters); // move point Vector3 parameters; public void Load(Vector3 parameters) { (GetNode(&quot;F/FHSlider&quot;) as HSlider).Value = (double)parameters.x; (GetNode(&quot;Z/ZHSlider&quot;) as HSlider).Value = (double)parameters.y; (GetNode(&quot;R/RHSlider&quot;) as HSlider).Value = (double)parameters.z; } public void Refresh(SecondOrderCurves curve) { CurveCanvas canvas = GetNode&lt;CurveCanvas&gt;(&quot;CurveCanvas&quot;); canvas.ReDraw(curve); } public void _on_FHSlider_value_changed(float value) { parameters.x = value; EmitSignal(&quot;PorpertyChanged&quot;, parameters); } public void _on_ZHSlider_value_changed(float value) { parameters.y = value; EmitSignal(&quot;PorpertyChanged&quot;, parameters); } public void _on_RHSlider_value_changed(float value) { parameters.z = value; EmitSignal(&quot;PorpertyChanged&quot;, parameters); } } Show Show Way 最后展示一下运行效果 ","link":"https://xuaii.github.io/post/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"title":"游戏动画中的缓动函数","content":"情景引入 考虑以下情形，采集用户水平输入 float HorizontalInput 来控制 player 的水平位移 void Update(float delta) { velocity.x = HorizontalInput * WalkSpeed * delta; } 这样写有两个缺点： 当影响水平速度的因素不只是水平输入时，不同因素的叠加不方便。不应该是 = 而应该是 +=; 移动完全与输入一直，看起来很僵硬； 解决方案 所以需要有这么一个函数(缓动函数)，它对输入的响应由可控的延迟，但最终会与输入保持一致 // 添加示例函数1.1 为了使缓动曲线更好的模拟现实世界中由于力产生加速度的运动，这里使用一个二阶系统来描述： y+k1⋅y′+k2⋅y′′=x+k3⋅x′y + k_1\\cdot y^{&#x27;} + k_2\\cdot y^{&#x27;&#x27;} = x + k_3 \\cdot x^{&#x27;} y+k1​⋅y′+k2​⋅y′′=x+k3​⋅x′ 等价的写法： y+k1⋅dydt+k2⋅d2yd2t=x+k3⋅dxdty + k_1\\cdot \\frac{\\mathrm{d} y}{\\mathrm{d} t} + k_2\\cdot \\frac{\\mathrm{d} ^2 y}{\\mathrm{d}^2 t} = x + k_3 \\cdot \\frac{\\mathrm{d} x}{\\mathrm{d} t} y+k1​⋅dtdy​+k2​⋅d2td2y​=x+k3​⋅dtdx​ 通过调整 k1,k2,k3k_1, k_2,k_3k1​,k2​,k3​ 可以改变图像的形状， // 插入示例图像1.2 现在添加三个变量： f=12πk2,θ=k12k2,r=2k3k1f = \\frac{1}{2\\pi \\sqrt{k_2}}, \\quad \\theta = \\frac{k_1}{2\\sqrt{k_2}}, \\quad r = \\frac{2k_3}{k_1} f=2πk2​​1​,θ=2k2​​k1​​,r=k1​2k3​​ 解方程组可得： k1=θπf,k2=1(2πf)2,k3=rθ2πfk_1 = \\frac{\\theta}{\\pi f}, \\quad k_2 = \\frac{1}{(2\\pi f)^2}, \\quad k_3 = \\frac{r \\theta}{2\\pi f} k1​=πfθ​,k2​=(2πf)21​,k3​=2πfrθ​ 原二阶系统的微分方程变为： y+θπf⋅y′+1(2πf)2⋅y′′=x+rθ2πf⋅x′y +\\frac{\\theta}{\\pi f} \\cdot y^{&#x27;} + \\frac{1}{(2\\pi f)^2} \\cdot y^{&#x27;&#x27;} = x + \\frac{r \\theta}{2\\pi f} \\cdot x^{&#x27;} y+πfθ​⋅y′+(2πf)21​⋅y′′=x+2πfrθ​⋅x′ 这里 f,θ,rf, \\theta, rf,θ,r 都具有现实意义了 fff 以 hzhzhz 为单位，代表系统固有频率，它描述系统对输入变化的响应速度 θ\\thetaθ 代表系统的阻尼系数，描述了系统如何最终趋于稳定 rrr 控制系统的初始响应 当 r=0r = 0r=0 时系统需要花费一点时间才能从禁止开始加速 当 r&gt;0r &gt; 0r&gt;0 时系统立刻对变化做出反应 当 r&gt;1r &gt; 1r&gt;1 时系统变化将冲过目标 当 r&lt;0r &lt; 0r&lt;0 时系统会有抬手运动（先反向运动） 一般为机械链接设置 r=2r = 2r=2 现在只剩下最后一个问题了，如何解二阶系统？ 二阶微分方程数值解 1. 半隐式欧拉法 该方法在该问题下与复杂的 Verlet 积分法 有着相同的精度， 首先计算 x 变化率 xn+1′=xn+1−xnTx^{&#x27;}_{n+1} = \\frac{x_{n+1} - x_n}{T} \\\\ xn+1′​=Txn+1​−xn​​ 然后计算 y 的变化 {yn+1=yn+Tyn′yn+1′=yn′+Ty′′\\begin{cases} y_{n + 1} = y_{n} + Ty^{&#x27;}_{n} \\\\ \\quad\\\\ y^{&#x27;}_{n+1} = y^{&#x27;}_{n} + Ty^{&#x27;&#x27;} \\\\ \\end{cases} ⎩⎪⎨⎪⎧​yn+1​=yn​+Tyn′​yn+1′​=yn′​+Ty′′​ 由于: y′′=x+k3x′−y−k1y′k2y^{&#x27;&#x27;} = \\frac{x + k_3 x^{&#x27;} - y - k_1y^{&#x27;}}{k_2} y′′=k2​x+k3​x′−y−k1​y′​ 所以： yn+1′=yn′+T⋅xn+1+k3xn+1′−yn+1−k1yn′k2y^{&#x27;}_{n+1} = y^{&#x27;}_{n} + T\\cdot \\frac{x_{n+1} + k_3 x^{&#x27;}_{n+1} - y_{n+1} - k_1y^{&#x27;}_{n}}{k_2} yn+1′​=yn′​+T⋅k2​xn+1​+k3​xn+1′​−yn+1​−k1​yn′​​ 这存在一个问题，如果频率 fff 远大于帧率，系统将变得不稳定，会产生无穷大的值： 可以简单地设置 f 的取值范围 通过数学方法确保不发生极端情况 为了提供更多的鲁棒性，采用方案二 分析 不稳定产生的原因，该系统的本质是反馈系统，他的迭代输出将被反馈到后续的迭代用于计算，当帧间时间步长和参数相比太大时，随着时间增加，误差将逐渐累积，当超过某个临界值时，误差会开始滚雪球，迅速导致灾难性后果，为了计算该临界值，引入线性代数方法： {yn+1=yn+Tyn′yn+1′=yn′+T⋅xn+1+k3xn+1′−(yn+Tyn′)−k1yn′k2\\begin{cases} y_{n + 1} = y_{n} + Ty^{&#x27;}_{n} \\\\ \\quad \\\\ y^{&#x27;}_{n+1} = y^{&#x27;}_{n} + T\\cdot \\frac{x_{n+1} + k_3 x^{&#x27;}_{n+1} -(y_{n} + Ty^{&#x27;}_{n}) - k_1y^{&#x27;}_{n}}{k_2} \\end{cases} ⎩⎪⎨⎪⎧​yn+1​=yn​+Tyn′​yn+1′​=yn′​+T⋅k2​xn+1​+k3​xn+1′​−(yn​+Tyn′​)−k1​yn′​​​ 展开合并同类项： {yn+1=yn+Tyn′yn+1′=−Tk2yn+k2−T2−Tk1k2yn′+Tk2xn+1+Tk3k2xn+1′\\begin{cases} y_{n + 1} = y_{n} + Ty^{&#x27;}_{n} \\\\ \\quad \\\\ y^{&#x27;}_{n+1} = \\frac{-T}{k_2} y_n + \\frac{k_2 - T^2 - Tk_1}{k_2}y^{&#x27;}_{n} + \\frac{T}{k_2}x_{n+1} + \\frac{Tk_3}{k_2}x^{&#x27;}_{n+1}\\\\ \\end{cases} ⎩⎪⎨⎪⎧​yn+1​=yn​+Tyn′​yn+1′​=k2​−T​yn​+k2​k2​−T2−Tk1​​yn′​+k2​T​xn+1​+k2​Tk3​​xn+1′​​ 矩阵表示如下： [yy′]n+1=[1T−Tk2k2−T2−Tk1k2]⋅[yy′]n+[00Tk2Tk3k2]⋅[xx′]n+1\\begin{bmatrix} y\\\\ y^{&#x27;} \\end{bmatrix}_{n+1} = \\begin{bmatrix} 1 &amp; T\\\\ -\\frac{T}{k_2} &amp; \\frac{k_2 - T^2 - Tk_1}{k_2} \\end{bmatrix} \\cdot \\begin{bmatrix} y\\\\ y^{&#x27;} \\end{bmatrix}_{n} + \\begin{bmatrix} 0 &amp; 0\\\\ \\frac{T}{k_2} &amp; \\frac{Tk_3}{k_2} \\end{bmatrix} \\cdot \\begin{bmatrix} x\\\\ x^{&#x27;} \\end{bmatrix}_{n+1} [yy′​]n+1​=[1−k2​T​​Tk2​k2​−T2−Tk1​​​]⋅[yy′​]n​+[0k2​T​​0k2​Tk3​​​]⋅[xx′​]n+1​ 简写如下 Yn+1=A⋅Yn+B⋅Xn+1Y_{n+1} = A\\cdot Y_n + B\\cdot X_{n+1} Yn+1​=A⋅Yn​+B⋅Xn+1​ 分析： AAA 称为状态转移矩阵，他表示迭代是如何影响状态变量的，直观来说如果 AAA 矩阵不导致状态变量 YYY 的增长，那该反馈是稳定的；考虑AAA 作为值而非变量，利用特征值理论，记 AAA 的特征值λ\\lambdaλ 如果 λi&lt;1\\lambda_i &lt; 1λi​&lt;1, Y 将逐渐减小趋于稳定 如果 λi&gt;1\\lambda_i &gt; 1λi​&gt;1, Y 迅速增大，很快变得无法控制 计算特征值如下： det(A−λI)=0det(A - \\lambda I) = 0 det(A−λI)=0 展开后 k2λ2+(T2+Tk1−2k2)λ(k2−Tk1)=0k_2 \\lambda^2 + (T^2 + Tk_1 - 2k_2)\\lambda (k_2-Tk_1) = 0 k2​λ2+(T2+Tk1​−2k2​)λ(k2​−Tk1​)=0 解关于 λ\\lambdaλ 的二次方程 λ=−b±b2−4ac2a\\lambda = \\frac{ -b \\pm \\sqrt{b^2-4ac}}{2a} λ=2a−b±b2−4ac​​ 令 ∣λ∣&lt;1|\\lambda| &lt; 1∣λ∣&lt;1: 得: T&lt;4k2+k12−k1T &lt; \\sqrt{4k_2 + k_1^2} - k_1 T&lt;4k2​+k12​​−k1​ 这里 如果时间步长大于临界值, 将拆分为多个了迭代来计算 public classs SecondOrderDynamics { private float T_crit; // critical stable time step public SecondOrderDynamics(float f, floatz, float r, Vector x0) { // update compute constants k1 = z / (PI * f); k2 = 1 / ((2 * PI * f) * (2 * PI * f)); k3 = r * z / (2 * PI * f); T_crit = 0.8f * (sqtr(4 * k2 + k1 * k1)); xp = x0; y = x0; yd = 0; } public Vector Update(float delta, Vector x, Vector xd = null) { if(xd == null) { xd = (x - xp) / delta; xp = x; } int interations = (int)Ceil(delta / T_crit); // take extra iterations if delta &gt; T_crit delta = delta / iterations; for(int i = 0; i &lt; iterations; i++) { y = y + delta * yd; yd = yd + delta * (x + k3 * xd - y - k1*yd) / k2; } return y; } } 此外，如果想避免迭代次数过多，可以限制 k2k_2k2​ 的值（减缓运动） k2&gt;T24+Tk12k_2 &gt; \\frac{T^2}{4} + \\frac{Tk_1}{2} k2​&gt;4T2​+2Tk1​​ float k2_stable = Max(k2, 1.1f * (T*T/4 + T*k1/2)); 2.零极点匹配法（高精度）没懂 public classs SecondOrderDynamics { private Vector xp; private Vector y, yd; private float _w, _z, _d, k1, k2, k3; public SecondOrderDynamics(float f, float z, float r, Vetor x0) { _w = 2 * PI * f; _z = z; _d = _w * sqrt(Abs(z*2-1)); k1 = z / (PI * f); k2 = 1 / (_w * _w); k3 = r * z / _w; xp = x0; y = x0; yd = 0; } public Vector Update(float delta, Vector x, Vector xd = null) { if(xd == null) { float k1_stable, k2_stable; if(_w * T &lt; _z) { k1_stable = k1; k2_stable = Max(k2, T * T / 2+ T * k1 / 2, T*k1); } else { float t1 = Exp(-_z * _w * T); float alpha = 2 * t1 * (_z &lt;= 1 ? cos(T * _d) : cosh(T * _d)); float beta = t1 * t1; float t2 = T / (1 + beta -alpha); k1_stable = (1 - beta) * t2; k2_stable = T * t2; } y = y + T * yd; yd = yd + T * (x + k3*xd -y - k1*yd) / k2_stable; return y; } } } 3. 其他数值解方法（略） 参考: t3ssel8r:Giving Personality to Procedural Animations using Math ","link":"https://xuaii.github.io/post/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"title":"对《戴森球计划》的一些杂乱的想法","content":"通宵玩了戴森球计划，只玩了母星球部分（实在不想肝了 个人看法，这类型游戏没什么乐趣，但是通关卡或者达成某些阶段性的目标会产生巨大的成就感，以程序员的视角，整个游戏过程像是在玩一个巨大的计算器，不断的铺路建造的过程又像是在写代码，但它没有代码灵活（大概是既不让使用设计模式，也不让使用封装继承的感觉，就像是在手写汇编码），其中的重复性太高。 各种物资的意义仅仅是数值意义，类似在玩一个Machinations,；通常游戏会将数值隐藏在机制背后，但是基建类游戏无可避免的需要将各种数值作为主要的玩法，这会让玩家感到疲劳和困。 戴森球计划对几千上万个动画目标的处理应该是用了什么魔法，太流畅了，大概是用了GPU计算动画之类的方法，这是值得借鉴的！！ 此外，作为独立游戏，《戴森球计划》流畅，内容多，耐玩，还能打MOD。尽管不能面面俱到，但是依然是国产独立游戏的劳模了！ 鲁迅说过，游戏就是在规则下，不以容易的方式达成目标。面对挑战和克服困难本来就是游戏的一部分，那戴森球计划带来的枯燥和成就感本就是游戏的乐趣一部分！ ","link":"https://xuaii.github.io/post/dui-lesslessdai-sen-qiu-ji-hua-greatergreater-de-yi-xie-za-luan-de-xiang-fa/"},{"title":"CART回归","content":"决策树.html 导入相关库 pandas：决策树的构建涉及到数据集的一些操作，利用pandas的DataFrame数据结构可以很好方便的完成 copy :在递归时浅拷贝会导致问题,使用copy.deepcopy()进行深拷贝 matplot.pyplot:绘制决策树的划分图像 import pandas as pd import copy import matplotlib.pyplot as plt import numpy as np from math import fabs 导入数据 input = [[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]] 定义回归树的节点类Node attrList 节点剩下的属性列表 Dataset 节点划分到的数据集 left/right 左右子树 c 叶节点的预测值 description 该节点的描述（可选） attr 该节点划分属性 s 划分属性的值 考虑到使用非二叉树，在每次寻找最优化分的时候算法复杂度太高，所以此时使用二叉树就OK class Node: def __init__(self, description=&quot;&quot;, c = -1, Dataset=pd.DataFrame(), attrList=[]): self.attrList = attrList self.Dataset = Dataset self.left = None self.right = None self.c = c self.attr = &quot;&quot; self.s = -1 self.desciption = description 计算损失 ℓ=∑xi∈R1(j,s)(yi−c1)2+∑xi∈R2(j,s)(yi−c2)2\\ell = \\sum_{x_i \\in R_1(j,s)}(y_i-c_1)^2+\\sum_{x_i \\in R_2(j,s)}(y_i-c_2)^2 ℓ=xi​∈R1​(j,s)∑​(yi​−c1​)2+xi​∈R2​(j,s)∑​(yi​−c2​)2 def loss(attr, s, data): D1 = data[data[attr] &lt;= s] D1_mean = D1['label'].std() * D1.size D2 = data[data[attr] &gt; s] D2_mean = D2['label'].std() * D2.size return D1_mean + D2_mean 最小化损失 min⁡j,s(min⁡c1∑xi∈R1(j,s)(yi−c1)2+min⁡c2∑xi∈R2(j,s)(yi−c2)2)\\min_{j,s} ( \\min_{c_1} \\sum_{x_i \\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i \\in R_2(j,s)}(y_i-c_2)^2 ) j,smin​(c1​min​xi​∈R1​(j,s)∑​(yi​−c1​)2+c2​min​xi​∈R2​(j,s)∑​(yi​−c2​)2) 此处数据集不大 且 为了实现起来简单就是用了遍历所有属性的值找到最小的损失，应该还有一些方法可以优化找到最小值的过程 def findOptDiv(root): losses = [] for attr in root.attrList: for s in root.Dataset[attr]: losses.append((loss(attr, s, root.Dataset), attr, s)) minLoss = min(losses) return minLoss 二叉树的构建 在以下情况返回IF len(attrList) == 0：此时所有属性已经划分完毕， 就以该集合所有样本的label的均值作预测值 Dataset.size == 1：此时该节点的样本仅有一个 就 以该样本的label值做预测值 ELSE 将样本按最优划分划分为两个集合D1，D2，并分别构建subTree def buildTree(root): # if root.Dataset.size() &lt;= 1: # description = &quot;leaf node&quot; # c_p = root.Dataset['label'].mean() # leaf = Node(description=description, c = c_p) # 如果样本集合中只有一个样本那么该节点为叶节点，该叶节点的预测值是该唯一样本的label if root.Dataset.size == 1: root.c = root.Dataset['label'] return # 如果已经将属性分完了，那么该节点为叶节点，剩下的样本集中label的期望为该叶节点的预测值 elif len(root.attrList) == 0: root.description = &quot;leaf node&quot; root.c = root.Dataset['label'].mean() return else: # 找到最优化分 (_, attr, s) = findOptDiv(root) # 将节点的划分属性设为找到的attr root.attr = copy.deepcopy(attr) # 将按属性attr划分该节点值划分值s设为最优的s root.s = copy.deepcopy(s) # 将样本集合按照找到的最优化分划分为D1， D2 D1 = copy.deepcopy(root.Dataset[root.Dataset[attr] &lt;= s]) D2 = copy.deepcopy(root.Dataset[root.Dataset[attr] &gt; s]) # 将划分该节点属性从属性集合中删除 list_notremoved = copy.deepcopy(root.attrList) root.attrList.remove(attr) list_removed = copy.deepcopy(root.attrList) root.attrList = copy.deepcopy(list_notremoved) # 构建左子树和右子树 root.left = Node(Dataset = D1, attrList=copy.deepcopy(list_removed)) root.right = Node(Dataset = D2, attrList=copy.deepcopy(list_removed)) buildTree(root.left) buildTree(root.right) return root 预测函数 def predict(x, root): while(len(root.attrList) != 0): if x[root.attr] &lt; root.s: root = root.left else: root = root.right return root.c 评估函数 def evaluate(data_test, root): accuracy = 0 for i in range(len(data_test)): res = predict(data_test.loc[i], root) # 将回归问题转为分类问题 res = .5 if res &gt; .5 else 0 accuracy += fabs(res - data_test.loc[i][&quot;label&quot;]) return 1 - accuracy / len(data_test) data = pd.DataFrame(input, columns=['密度','含糖率',&quot;label&quot;]) root = Node(Dataset=data, attrList = ['密度','含糖率']) root = buildTree(root) 可以大致看出决策过程 先看含糖率： 小于.13 小于.666 坏瓜 大于.666 好瓜 大于.13 小于.697 0.6的概率是好瓜 大于.697 1的概率是好瓜 print(root.attr,root.s) print(root.left.attr,root.left.s,root.left.left.c,root.left.right.c) print(root.right.attr,root.right.s,root.right.left.c,root.right.right.c) 含糖率 0.103 密度 0.666 0.0 0.0 密度 0.697 0.6363636363636364 1.0 可视化和评估模型表现 s1 = root.s s21 = root.left.s s22 = root.right.s plt.plot([.2,.8],[s1,s1],'r-') plt.plot([s21,s21],[0,s1],'r-') plt.plot([s22,s22],[s1,.5],'r-') for plot in input: if plot[2] == 0: c = 'red' else: c = 'green' plt.scatter(plot[0],plot[1],c=c) print(&quot;THE ACCURACY OF REGRESSION TREE IS {}&quot;.format(evaluate(data, root))) THE ACCURACY OF REGRESSION TREE IS 0.6176470588235294 ","link":"https://xuaii.github.io/post/cart-hui-gui/"},{"title":"线性模型","content":"线性模型.html import numpy as np import matplotlib.pyplot as plt import copy from IPython import display np.random.seed(0) data = [[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]] def load_data(): X = np.array(data).T label = copy.deepcopy(X[2,:].reshape(1,17)) X[2,:] = 1 assert X.shape == (3,17) assert label.shape == (1,17) return X, label l(β)=∑i=1m(−yiβTxi+ln(1+eβTxi))l(\\beta) = \\sum_{i=1}^{m}(-y_i \\beta^Tx_i+ln(1+e^{\\beta^T x_i})) l(β)=i=1∑m​(−yi​βTxi​+ln(1+eβTxi​)) =∑i=1m−yiβTxi+∑i=1mln(1+eβTxi)= \\sum_{i=1}^{m}-y_i \\beta^Tx_i+\\sum_{i=1}^{m}ln(1+e^{\\beta^T x_i}) =i=1∑m​−yi​βTxi​+i=1∑m​ln(1+eβTxi​) =(βTX)Y+np.sum(ln(1+eYi))= (\\beta^TX)Y + np.sum(ln(1+e^{Y_i})) =(βTX)Y+np.sum(ln(1+eYi​)) 使用numpy实现如下： part_1 = np.dot(Y, label.T) part_2 = np.sum(np.ln(1+np.exp(Y))) def loss(label, Y): part_1 = -np.dot(Y, label.T) part_2 = np.sum(np.log(1+np.exp(Y))) return part_1 + part_2 前向传播 input=W,Xinput = W,Xinput=W,X output=W′TX′=WTX+boutput = W^{&#x27;T} X^{&#x27;} = W^T X+boutput=W′TX′=WTX+b def forward_propagation(W,X): Z = np.dot(W,X) A = 1/(1+np.exp(-Z)) return A 初始化参数: 使用随机初始化 n ------ 特征值数量为 m ------ 样本数量 w′=(w,b)w^{&#x27;} = (w,b)w′=(w,b) w.shape==（1,n+1）w.shape == （1,n+1）w.shape==（1,n+1） def initialization(n): return np.random.randn(1,n+1) # return np.zeros((1,n+1)) 反向传播 dw=−∑i=1mxi(yi−p1(xi;β))dw = -\\sum_{i=1}^{m}x_i(y_i-p_1(x_i;\\beta)) dw=−i=1∑m​xi​(yi​−p1​(xi​;β)) dw=−(label−Y)XTdw = -(label-Y)X^T dw=−(label−Y)XT def back_propagation(X,Y,label): return -np.dot((label-Y),X.T) 训练循环 使用梯度下降法 学习率 = 0.5 迭代次数 10000 def train(epoch=100,n = 2, learning_rate = 0.5, detial = True): X, label = load_data() W = initialization(n) losses = [] W_list = [] for i in range(0,epoch): Y = forward_propagation(W,X) l = loss(label, Y) dw = back_propagation(X,Y,label) losses.append(float(l)) W += learning_rate * dw if i % 100 == 0: W_list.append(copy.deepcopy(W)) if i % 1000 == 0 and detial ==True: print(&quot;This is {}th epoch , loss = {}&quot;.format(i, l)) return W_list, losses def draw(W): W = W[0] x = np.linspace(0.2,0.8,100) y = -(W[0] * x + W[2])/W[1] plt.plot(x,y) for plot in data: if plot[2] == 0: c = 'red' else: c = 'green' plt.scatter(plot[0],plot[1],c=c) def show(W_list): for W in W_list: plt.clf() display.clear_output(wait=True) draw(W) plt.pause(0.001) W_list,losses = train(epoch=10000,n=2,learning_rate=.01,detial=False) show(W_list[:100]) plt.plot(losses) [&lt;matplotlib.lines.Line2D at 0x7f1b3a14aa50&gt;] ","link":"https://xuaii.github.io/post/xian-xing-mo-xing/"},{"title":"Neural Network","content":"L层神经网络.html Neural Network 实现方式：采用BP算法，使用梯度下降来优化W，b 需要实现的函数如下： initial():根据用户自定义的层layer-&gt;[ n1,n2,n3,...,nmn_1, n_2,n_3,...,n_mn1​,n2​,n3​,...,nm​ ]来初始化参数W，b sigmoid():输入X∈RmxnX \\in R^{m x n}X∈Rmxn ，返回A=11+e−WX+bA = \\frac{1}{1+e^{-WX + b}}A=1+e−WX+b1​ liner_propagation():实现一层的前向传播，返回 A，并且缓存中间量Z L_layers_propagation():实现L层的前向传播，并且缓存所有中间层的A，Z predict():使用训练好的模型Ws，bs预测某一输入特征向量对应的预测值 back_propagation():实现一层的反向传播 L_back_propagation():实现L层链式反向传播 update_parameters():每一个epoch更新参数 evaulate():评估模型 model():主循环，BP算法梯度下降的循环 load_data():加载数据 在整体的设计中并没有loss函数的出现，是因为，在反向传播过过中，dloss/dW的计算并不涉及loss的值，dloss/dW的表达式中仅有y_truth 和 y_pred 链式偏微分 推导（这里是根据西瓜书上原始公式推导，所以是累计神经网络） 由于在布置编程作业之前就自己实现了一下神经网络，所以实现的是任意层数和任意数量神经元的神经网络，所以就改下参数交作业了 由于神经网络层数可能会非常多，所以在反向传播时loss对每一层的W，b求导会重复很多中间步骤 设：βi∈Rm⋅n设：\\beta^i \\in \\R^{m \\cdot n} 设：βi∈Rm⋅n Ai−1∈Rn⋅sA^{i-1} \\in \\R^{n \\cdot s} Ai−1∈Rn⋅s Zi∈Rm⋅sZ^{i} \\in \\R^{m \\cdot s} Zi∈Rm⋅s Zi=WiAi−1+bi=βiAi−1,Z^i = W^i A^{i-1} + b^i = \\beta^i A^{i-1}, Zi=WiAi−1+bi=βiAi−1, Ai=sigmoid(Zi);A^i = sigmoid(Z^i); Ai=sigmoid(Zi); ∂E∂βi=∂Zi∂βi⋅∂Ai∂Zi⋅∂E∂Ai⏞∂Ai⎵∂Zi，（1.1）\\frac{\\partial E}{\\partial \\beta^i} = \\frac{\\partial Z^i}{\\partial \\beta^i} \\cdot \\underbrace{ \\frac{\\partial A^i}{\\partial Z^i} \\cdot \\overbrace {\\frac{\\partial E}{\\partial A^i}}^{\\partial A^i} }_{\\partial Z^i} ， \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad （1.1） ∂βi∂E​=∂βi∂Zi​⋅∂Zi∂Zi∂Ai​⋅∂Ai∂E​​∂Ai​​​，（1.1） ∂E∂Ai−1=∂Zi∂Ai−1⋅∂Ai∂Zi⋅∂E∂Ai⏞∂Ai⎵∂Zi,（1.2）\\frac{\\partial E}{\\partial A^{i-1}} = \\frac{\\partial Z^i}{\\partial A^{i-1}} \\cdot \\underbrace {\\frac{\\partial A^i}{\\partial Z^i} \\cdot \\overbrace{ \\frac{\\partial E}{\\partial A^i} }^{\\partial A^i} }_{\\partial Z^i}, \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad （1.2） ∂Ai−1∂E​=∂Ai−1∂Zi​⋅∂Zi∂Zi∂Ai​⋅∂Ai∂E​​∂Ai​​​,（1.2） 其中： ∂Ai由上一层反向传播提供,\\partial A^i由上一层反向传播提供, ∂Ai由上一层反向传播提供, 现在考虑每一层反向传播的计算 已知: ∂E∂Ak,∂Ak∂Zk,其中：k是层数\\frac{\\partial E}{\\partial A^k}, \\frac{\\partial A^k}{\\partial Z^k}, \\qquad其中：k是层数 ∂Ak∂E​,∂Zk∂Ak​,其中：k是层数 求解: ∂E∂Zki,j其中：i,j∈{i,j∣i∈(1,Zk.shape[0]，j∈(1,Zk.shape[1])}\\frac{\\partial E}{\\partial {Z^k}_{i,j}} \\qquad其中： i,j \\in \\{ i,j | i \\in (1,Z^k.shape[0]， j \\in (1,Z^k.shape[1])\\} ∂Zki,j​∂E​其中：i,j∈{i,j∣i∈(1,Zk.shape[0]，j∈(1,Zk.shape[1])} 分析： 由于 （暂时忽略掉上标，仅在需要的时候添加） Z=βAZ = \\beta A Z=βA Zi,j=∑k=1nβi,kAk,jZ_{i,j} = \\sum_{k=1}^{n}\\beta_{i,k}A_{k,j} Zi,j​=k=1∑n​βi,k​Ak,j​ 该式子表明 Zi,j的值与同行βi,kZ_{i,j}的值与同行\\beta{i,k} Zi,j​的值与同行βi,k 即每一个β与Z的第a行相关即每一个\\beta与Z的第a行相关 即每一个β与Z的第a行相关 那么要计算∂E∂βa,b那么要计算\\frac{\\partial E}{\\partial \\beta_{a,b}} 那么要计算∂βa,b​∂E​ 即需要∂E∂βa,b=∑k=1s∂E∂Za,k∂Za,k∂βa,b即需要\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s}\\frac{\\partial E}{\\partial Z_{a,k}} \\frac{\\partial Z_{a,k}}{\\partial \\beta_{a,b}} 即需要∂βa,b​∂E​=k=1∑s​∂Za,k​∂E​∂βa,b​∂Za,k​​ 而：∂Za,k∂βa,b=Ab,k而：\\frac{\\partial Z_{a,k}}{\\partial \\beta_{a,b}} = A_{b,k} 而：∂βa,b​∂Za,k​​=Ab,k​ 那么：∂E∂βa,b=∑k=1s∂E∂Za,k⋅Ab,k那么：\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s}\\frac{\\partial E}{\\partial Z_{a,k}} \\cdot A_{b,k} 那么：∂βa,b​∂E​=k=1∑s​∂Za,k​∂E​⋅Ab,k​ ∂E∂βa,b=∑k=1s(∂E∂Z)a,k⋅Ab,k\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s} {(\\frac{\\partial E}{\\partial Z})}_{a,k} \\cdot A_{b,k} ∂βa,b​∂E​=k=1∑s​(∂Z∂E​)a,k​⋅Ab,k​ =∑k=1s(∂E∂Z)a,k(AT)k,b= \\sum_{k=1}^{s}(\\frac{\\partial E}{\\partial Z})_{a,k}(A^T)_{k,b} =k=1∑s​(∂Z∂E​)a,k​(AT)k,b​ 所以有：∂Eβ=dZAT所以有：\\frac{\\partial E}{\\beta} = dZ A^T 所以有：β∂E​=dZAT 由于推导的迭代式子中包含A, Z, 等前向传播产生的中间结果， 所以在前向传播时需要将它们缓存下来 import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation import sys import copy from IPython import display import time from sklearn.metrics import roc_curve, auc, accuracy_score, confusion_matrix, classification_report, roc_auc_score # 设置随机种子，避免每次的结果不一样 np.random.seed(1) %matplotlib inline 初始化函数initial(layers) input: layers -&gt; [layer_1, layer_2, layer_3, ..., layer_m] output: paramters -&gt; dict() parameters[&quot;w&quot;] = temp_w -&gt; list() parameters['layers'] = layers -&gt; list() def initial(layers): parameters = dict() temp_w = list() for i in range(1, len(layers)): temp_w.append(np.random.randn(layers[i], layers[i-1])) parameters[&quot;w&quot;] = temp_w parameters['layers'] = layers return parameters 激活函数 Sigmoid() 激活函数种类： sigmoid():&quot;S&quot;形函数f(x)=11+e−WX+bf(x) = \\frac{1}{1+e^{-WX + b}}f(x)=1+e−WX+b1​$ ReLU():线性修正单元f(x)=max(0,x)f(x) = max(0,x)f(x)=max(0,x) tanh():双曲正切函数f(x)=ex−e−xex+e−xf(x) = \\frac{e^x-e^{-x}}{e^x+e^{-x}}f(x)=ex+e−xex−e−x​ ELU: PReLU: LReLU:x负半轴斜率比较小的PReLU def sigmoid(A): return 1/(1+np.exp(-A)) 前向线性传播 Z=WX+bZ = WX + bZ=WX+b A=11+e−ZA = \\frac{1}{1+e^-Z}A=1+e−Z1​ def liner_propagation(w, A): Z = np.dot(w, A) A = sigmoid(Z) return Z, A L层的前向传播 是L次linear_propagation的叠加 由于反向传播的需要，这里的L层前向传播需要缓存每一层的A，Z到A_cache and Z_chache def L_layers_propagation(parameters, x): A_cache = list() Z_cache = list() cache = dict() A_cache.append(x) Z_cache.append(x) w = parameters[&quot;w&quot;] layers = parameters['layers'] for i in range(0, len(layers) - 1): Z, A = liner_propagation(w[i], A_cache[i]) assert Z.shape == A.shape Z_cache.append(Z) A_cache.append(A) cache[&quot;A&quot;] = A_cache cache[&quot;Z&quot;] = Z_cache return cache Loss函数（均方误差） 如果要实现任意loss函数，只会影响链式传播哦的最后一项，而不会影响链式传播的中间过程 由于最近DDL多，所以任意loss函数的实现，在寒假实现 def lossFunc(Y_pre, Y_true, method = &quot;MSE&quot;): temp = Y_pre - Y_true return .5 * np.dot(temp, temp.T) 预测函数 input = x output = y y=f(x)y = f(x)y=f(x) y&gt;.5y&gt;.5y&gt;.5 =&gt; y=1y=1y=1 y≤.5y\\le .5y≤.5 =&gt; y=0y= 0y=0 def predict(parameters, x, draw = False): Y = L_layers_propagation(parameters, x)['A'][-1] if draw == False: Y[Y &gt; .5] = 1 Y[Y &lt;= .5] = 0 return Y 反向传播函数 back_propagation 实现反向传播的难点在于求梯度 求梯度的方法如下： dx=f(x)−f(x−Δx)Δxdx = \\frac{f(x) - f(x-\\Delta x)}{\\Delta x}dx=Δxf(x)−f(x−Δx)​ 老师上课提到的这种方法会导致精确度问题 如当在梯度下降算法中设定Δx=η\\Delta x= \\etaΔx=η时该算法退化为 W := W - loss(x-learning_rate) 2.利用求偏导法则，一层一层的求偏导 使用类似 tensorflow 的 Autograd 的计算图，将每一个参数变量加入计算图中，然后可以找到变量之间的关联然后求导(实现过于复杂，对于简单的全链接网络没必要这样做) 使用高等数学中的多变量求导，结合线性代数的矩阵变换进行 实数 对 矩阵 的 链式求导 参考 矩阵求导术（下） 矩阵求导术（上） 引入克罗内克积实现矩阵的链式求导，在注释代码中是没经过花间的Kron积，运算量极大，经过化简得到简单的矩阵表达式 def back_propagation(W, A_prev, dZ): # dZA_prev = np.diag( (A_prev * (1 - A_prev)).T.flatten() ) # I = np.eye(A_prev.shape[1]) # dZ_prev = np.dot(np.dot(dZA_prev,np.kron(I, W.T)), dZ) # I = np.eye(W.shape[0]) # dW = np.dot(np.kron(A_prev, I),dZ) # print(A_prev.shape, W.shape, dZ.shape) dZ_prev = np.multiply( A_prev * (1 - A_prev), np.dot(W.T,dZ)) dW = np.dot(dZ,A_prev.T) return dZ_prev, dW def L_back_propagation(cache, parameters, y): w = parameters[&quot;w&quot;] layers = parameters[&quot;layers&quot;] L = len(layers) - 1 A = cache[&quot;A&quot;] dW_list = list() dZ_prev = A[L] * (1 - A[L]) * (A[L] - y) for i in reversed(range(0, L)): dZ_prev, dW = back_propagation(w[i], A[i], dZ_prev) dW_list.append(dW) cache[&quot;dW&quot;] = dW_list return cache 更新参数 pass def update_parameters(cache, parameters, learning_rate): w = parameters[&quot;w&quot;] layers = parameters[&quot;layers&quot;] L = len(layers) - 1 dW = cache[&quot;dW&quot;] for i in range(L): w[i] -= dW[L-i-1] * learning_rate # b[i] = b[i] - db[len(b)-i-1] * learning_rate parameters[&quot;w&quot;] = w return parameters evaulate 使用准确度作为评估标准 def evaluate(Z, Y): bools = Z == Y accuracy = np.sum(np.reshape(bools,bools.size))/Y.shape[1] return accuracy def evaluate_detial(y_t, y_p): y_test = copy.deepcopy(y_t) y_pred = copy.deepcopy(y_p) print(&quot;The roc_auc_score is {}&quot;.format(roc_auc_score(y_test, y_pred))) tpr,fpr,thresholds = roc_curve(y_test,y_pred) plt.subplot(1,2,1) plt.plot(fpr, tpr) plt.xlim([0.0, 1.0]) plt.ylim([0.0, 1.0]) plt.title('ROC curve for diabetes classifier') plt.xlabel('False Positive Rate (1 - Specificity)') plt.ylabel('True Positive Rate (Sensitivity)') plt.grid(True) # mean = np.sum(y_pred)/y_pred.shape[0] y_pred[(y_pred &lt; 0.5)] = 0 y_pred[(y_pred &gt;= 0.5)] = 1 # plt.scatter(x_test[0, :], x_test[1, :], c = y_pred[:, 0]) print(&quot;The accuracy is {}&quot;.format(accuracy_score(y_test[:,0], y_pred[:,0]))) # 计算召回， 查全率， 查准率 。。。。 target_names = ['class0','class1'] print(classification_report(y_test,y_pred,target_names = target_names)) ## 绘图 def Plot(X, label, parameters): x_min, x_max = X[0,:].min() - .5, X[0,:].max() + .5 y_min, y_max = X[1,:].min() - .5, X[1,:].max() + .5 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) Z = predict(parameters, np.c_[xx.ravel(), yy.ravel(), np.ones((yy.ravel().shape))].T) Z = Z.reshape(xx.shape) plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral) plt.scatter(X[0,:],X[1,:],c=label[0,:]) load_data 加载数据的管道 def load_data(shape = &quot;circle&quot;): X = np.random.rand(2,200) one = np.ones((1,200)) X = np.vstack((X,one)) C = [] for x in X.T: if shape == &quot;circle&quot;: # 同心圆 if (x[0]-.5)**2 + (x[1]-.5)**2 &lt; .03: C.append(1) elif (x[0]-.5)**2 + (x[1]-.5)**2 &lt; .13: C.append(0) else: C.append(1) elif shape == &quot;xor&quot;: # 四分 if (x[0] - .5)*(x[1] - .5) &gt;=0: C.append(1) else: C.append(0) x_min, x_max = X[0,:].min() - .05, X[0,:].max() + .05 y_min, y_max = X[1,:].min() - .05, X[1,:].max() + .05 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) test = np.c_[xx.ravel(), yy.ravel(), np.ones((yy.ravel().shape))].T return X, np.array(C).reshape(1,-1), test, (xx,yy) Back Propagation(BP算法的整体框架) 使用梯度下降的优化方法 其他可用的优化方法 SGD 随机梯度下降 MBGD （Mini Batch Gradient Descent）用于样本容量大，内存/现存不够的情况 Momentum 动量梯度下降 Nesterov NAG Adagrad Adaelta Adam def model(X, Y, test,canvs, layers, learning_rate = 0.01, epoch = 1000, detial = True, draw = False): parameters = initial(layers) draw_param = [] for i in range(epoch): cache = L_layers_propagation(parameters, X) cache = L_back_propagation(cache, parameters, Y) parameters = update_parameters(cache, parameters, learning_rate) if i % 500 == 0 and draw == True: # draw_param.append(copy.deepcopy(parameters)) yield predict(parameters, test, draw = True).reshape(canvs[0].shape) if i % 1000 == 0 and detial == True: print(&quot;this is {}th epoch.&quot;.format(i)) Y_predict = predict(parameters, X, draw=False) accuracy = evaluate(Y, Y_predict) print(&quot;accuracy is {}&quot;.format(accuracy)) if draw == False: return parameters 实现累计BP算法 def model_caculate(X, Y, X_test, Y_test, layers, learning_rate = 0.01, epoch = 1000, interval = 50): parameters = initial(layers) Loss = [] loss = None Acc = [] accuracy = None start = time.time() Y_predict = None for i in range(epoch): cache = L_layers_propagation(parameters, X) cache = L_back_propagation(cache, parameters, Y) loss = lossFunc(Y, cache[&quot;A&quot;][-1]) parameters = update_parameters(cache, parameters, learning_rate) if i % interval == 0: Loss.append(loss[0,0]) Y_predict = predict(parameters, X_test, draw=False) accuracy = evaluate(Y_test, Y_predict) Acc.append(accuracy) if i % (interval * 50) == 0: now = time.time() print(&quot;Calculate Dense Net:~$ {}th epoch, accuracy: {}, loss:{}, time:{}-&quot;.format(i, accuracy, loss[0,0], now - start)) start = time.time() return Loss, Acc, Y_predict X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] epoch = 25000 Loss, accuracy, Y_pred = model_caculate(X, label, X, label, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, 500) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(label.T, Y_pred.T) Calculate Dense Net:~$ 0th epoch, accuracy: 0.725, loss:21.40100100371333, time:0.0010008811950683594- Calculate Dense Net:~$ 2500th epoch, accuracy: 0.725, loss:19.748958341789084, time:0.7027204036712646- Calculate Dense Net:~$ 5000th epoch, accuracy: 0.725, loss:18.484585855571503, time:0.7009453773498535- Calculate Dense Net:~$ 7500th epoch, accuracy: 0.705, loss:16.377806924887945, time:0.6996634006500244- Calculate Dense Net:~$ 10000th epoch, accuracy: 0.87, loss:10.950215467935237, time:0.7041025161743164- Calculate Dense Net:~$ 12500th epoch, accuracy: 0.88, loss:9.160948492962692, time:0.701648473739624- Calculate Dense Net:~$ 15000th epoch, accuracy: 0.885, loss:8.84026852930535, time:0.6946816444396973- Calculate Dense Net:~$ 17500th epoch, accuracy: 0.965, loss:6.105461022050368, time:0.685279369354248- Calculate Dense Net:~$ 20000th epoch, accuracy: 0.99, loss:2.3057686501449832, time:0.7090015411376953- Calculate Dense Net:~$ 22500th epoch, accuracy: 0.99, loss:0.958385284049958, time:0.6965689659118652- The roc_auc_score is 1.0 The accuracy is 1.0 precision recall f1-score support class0 1.00 1.00 1.00 55 class1 1.00 1.00 1.00 145 micro avg 1.00 1.00 1.00 200 macro avg 1.00 1.00 1.00 200 weighted avg 1.00 1.00 1.00 200 实现标准BP算法（也就是Mini-batch = 1，这样的话在python下使用for循环喂数据会非常慢） def model_std(X, Y, X_test, Y_test, layers, learning_rate = 0.01, epoch = 1000, interval = 50): parameters = initial(layers) Loss = [] Acc = [] accuracy = None loss = None Y_pred = None start = time.time() for i in range(epoch): for j in range(0, X.shape[1]): cache = L_layers_propagation(parameters, X[:, j].reshape(3, -1)) cache = L_back_propagation(cache, parameters, Y[:, j].reshape(1, -1)) parameters = update_parameters(cache, parameters, learning_rate) if i % interval == 0: Y_pred = predict(parameters, X_test, draw = False) loss = lossFunc(Y_test, Y_pred)[0,0] Loss.append(loss) accuracy = evaluate(Y_test, Y_pred) Acc.append(accuracy) if i % (interval * 20) == 0: now = time.time() print(&quot;Stander Dense Net:~$ {}th epoch, accuracy: {}, loss:{}, time:{}&quot;.format(i, accuracy, loss, now - start)) start = time.time() return Loss, Acc, Y_pred X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] epoch = 33300 Loss,accuracy, Y_pred = model_std(X, label, X, label, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, epoch/50) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(label.T, Y_pred.T) Stander Dense Net:~$ 0th epoch, accuracy: 0.65, loss:35.0, time:0.018254756927490234 动态可视化训练过程 def main(epoch= 50000, detial=True, draw=False): X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] if draw == True: for im in model(X, label, test, canvs, layers, learning_rate=0.01, epoch= epoch, detial = detial, draw = True): plt.clf() display.clear_output(wait=True) plt.contourf(canvs[0] ,canvs[1], im, cmap=plt.cm.Spectral) plt.scatter(X[0,:], X[1,:],c=label[0,:]) plt.pause(0.01) else: parameters = model(X, label, test, canvs, layers, learning_rate=0.01, epoch= 30000, detial = detial, draw = draw) Plot(X, label, parameters) main(epoch= 20000, detial=False, draw=True) 西瓜数据集3.0α\\alphaα上的分类 导入数据 import numpy as np import copy def load(): data = np.array([[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]]) Y = copy.deepcopy(data[:, 2].reshape(-1, 1).T) data[:, 2] = 1 X = copy.deepcopy(data.T) X_test = copy.deepcopy(np.c_[X[:, 0:2],X[:, -3:-1]]) Y_test = copy.deepcopy(np.c_[Y[:, 0:2],Y[:, -3:-1]]) X_train = copy.deepcopy(X[:, 2:-2]) Y_train = copy.deepcopy(Y[:, 2:-2]) return X_train, Y_train, X_test, Y_test, X, Y X_train, Y_train, X_test, Y_test, X, Y = load() print(Y.shape) 累计BP X_train, Y_train, X_test, Y_test, X, Y = load() X_train.shape, Y_train.shape, X_test.shape, Y_test.shape layers = [3,5,1] epoch = 5500 interval = 1 Loss, accuracy, Y_pred = model_caculate(X_train, Y_train, X_test, Y_test, layers, learning_rate=0.1, epoch= epoch, interval = interval) #开始画图 x = np.linspace(0, 25000, epoch/interval) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(Y_test.T, Y_pred.T) X, label, test, canvs = load_data() X.shape, label.shape 标准BP算法 由于实现了累计误差的算法， 所以可以将样样本拆分得到mini-batch的神经网络就是标准BP算法 layers = [3,5,1] epoch = 5500 interval = 1 Loss,accuracy, Y_pred = model_std(X_train, Y_train, X_test, Y_test, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, epoch/50) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(Y_test.T, Y_pred.T) 模型比较 标准BP算法收敛更快 累计BP在python可以通过矩阵运算向量化加速,在迭代过程中震荡变小 累计BP 更占用内存，而标准BP可以一边读一边运算，收敛速度变慢但是梯度方向更准确 Minibatch = n，可以通过调节n的大小使其达到一个合适的值，其收敛速度和迭代的准确性都能提高！ 神经网络的优势 相对于决策树，线性模型，神经网络可以通过增加层数/增加神经元的方式拟合任意非线性函数 在之前的同心圆数据集中，神经网络的表达能力远远优于其他模型 \\begin{split} &amp; C(F , G) = \\frac{F \\cdot G+(1 - F\\otimes G)}{2}\\ &amp; F\\cdot G = \\vee_U(\\mu_F(u_i)\\land\\mu_G(u_i)) \\ &amp; F\\otimes G = \\vee_U(\\mu_F(u_i)\\vee\\mu_G(u_i)) \\end{split} ","link":"https://xuaii.github.io/post/neural-network/"},{"title":"SVM","content":"svm.html 线性核SVM 和 高斯核SVM SMO 算法解析 最优化目标 (1)max⁡α=∑i=1mαi−∑i=1m∑j=1mαiαjyiyjxiTxj\\max_{\\alpha} =\\sum_{i=1}^{m}\\alpha_i - \\sum_{i=1}^{m} \\sum_{j=1}^{m}\\alpha_i\\alpha_jy_iy_jx_i^Tx_j \\tag{1} αmax​=i=1∑m​αi​−i=1∑m​j=1∑m​αi​αj​yi​yj​xiT​xj​(1) (2) s.t. αi≥0,∑i=1Nαiyi=1\\text{ s.t. } \\qquad \\alpha_i \\ge 0,\\quad \\sum_{i=1}^{N}\\alpha_iy_i = 1 \\tag{2} s.t. αi​≥0,i=1∑N​αi​yi​=1(2) 约束条件 算法原理 我们可以先确定 两个αi,αj\\alpha_i,\\alpha_jαi​,αj​. 在例子中设i=1,j=2i=1 , \\quad j=2i=1,j=2. 此时最大化目标： (3)argmax⁡α1,α2W(α1,α2)=α1+α2−12K1,1y12α12−12K2,2y22α22−K1,2y1y2α1α2−y1α1∑i=3mαiyiKi,1−y2α2∑i=3mαiyiKi,2+Carg\\max_{\\alpha_1, \\alpha_2}W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 - \\frac{1}{2}K_{1,1}y_1^2\\alpha_1^2 - \\frac{1}{2}K_{2,2}y_2^2\\alpha_2^2 - K_{1,2}y_1y_2\\alpha_1\\alpha_2 - y_1\\alpha_1\\sum_{i=3}^{m}\\alpha_iy_iK_{i,1} - y_2\\alpha_2\\sum_{i=3}^{m}\\alpha_iy_iK_{i,2} + C \\tag{3} argα1​,α2​max​W(α1​,α2​)=α1​+α2​−21​K1,1​y12​α12​−21​K2,2​y22​α22​−K1,2​y1​y2​α1​α2​−y1​α1​i=3∑m​αi​yi​Ki,1​−y2​α2​i=3∑m​αi​yi​Ki,2​+C(3) 根据(2) α1y1+α2y2=−∑i=3Nαiyi=η\\alpha_1y_1 + \\alpha_2y_2 = -\\sum_{i=3}^{N}\\alpha_iy_i = \\eta α1​y1​+α2​y2​=−i=3∑N​αi​yi​=η 两边同时乘以y1,由于yi2=1y_1,由于y_i^2 = 1y1​,由于yi2​=1 (4)α1=ηy1−α2y1y2\\alpha_1 = \\eta y_1 - \\alpha_2y_1y_2 \\tag{4} α1​=ηy1​−α2​y1​y2​(4) 令： (5)v1=∑i=3NαiyiKi,1,v2=∑i=3NαiyiKi,2v_1 = \\sum^{N}_{i=3}\\alpha_iy_iK_{i,1}, \\quad v_2 = \\sum^{N}_{i=3}\\alpha_iy_iK_{i,2} \\tag{5} v1​=i=3∑N​αi​yi​Ki,1​,v2​=i=3∑N​αi​yi​Ki,2​(5) 将 (4), (5) 带入(3) (6)W(α2)=−12K1,1(η−α2y2)2−12K2,2α22−K1,2y2α2(η−α2y2)−v1(η−α2y2)−v2y2α2+α1+α2+CW(\\alpha_2) = - \\frac{1}{2}K_{1,1}(\\eta - \\alpha_2y_2)^2 - \\frac{1}{2}K_{2,2}\\alpha_2^2 - K_{1,2}y_2\\alpha_2(\\eta - \\alpha_2y_2) - v_1(\\eta - \\alpha_2y_2) - v_2y_2\\alpha_2 + \\alpha_1 + \\alpha_2 + C \\tag{6} W(α2​)=−21​K1,1​(η−α2​y2​)2−21​K2,2​α22​−K1,2​y2​α2​(η−α2​y2​)−v1​(η−α2​y2​)−v2​y2​α2​+α1​+α2​+C(6) 由于需要更新α2\\alpha_2α2​所以令dWdα=0\\frac{dW}{d\\alpha} = 0dαdW​=0 (7)∂W(α2)∂α2=−α2(K1,1+K2,2−2K1,2)+K1,1ηy2−K1,2ηy2+v1y2−v2y2−y1y2+y22=0\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -\\alpha_2(K_{1,1} + K_{2,2} - 2K_{1,2}) + K_{1,1}\\eta y_2 - K_{1,2}\\eta y_2 + v_1y_2 - v_2y_2 - y_1y_2 + y_2^2 = 0 \\tag{7} ∂α2​∂W(α2​)​=−α2​(K1,1​+K2,2​−2K1,2​)+K1,1​ηy2​−K1,2​ηy2​+v1​y2​−v2​y2​−y1​y2​+y22​=0(7) 对(7)式变形，使得α2new\\alpha_2^newα2n​ew能被α2old\\alpha_2^oldα2o​ld表示(而不是用不方便的\\eta)： SVM预测值如下(该式子不需要保留所有的x，因为很多无关的x的alpha都为0，因此alpha需要初始化为0)： (8)f(x)=∑i=1NαiyiK(xi,x)+bf(x) = \\sum_{i=1}^{N}\\alpha_iy_iK(x_i,x) + b \\tag{8} f(x)=i=1∑N​αi​yi​K(xi​,x)+b(8) 则v可以表示为： v1=∑i=3NαiyiK1,i=f(x1)−α1y1K1,1−α2y2K1,2−bv_1 = \\sum^{N}_{i=3}\\alpha_iy_iK_{1,i} = f(x_1) - \\alpha_1y_1K_{1,1} - \\alpha_2y_2K_{1,2} - b v1​=i=3∑N​αi​yi​K1,i​=f(x1​)−α1​y1​K1,1​−α2​y2​K1,2​−b v2=∑i=3NαiyiK2,i=f(x2)−α1y1K1,2−α2y2K2,2−bv_2 = \\sum^{N}_{i=3}\\alpha_iy_iK_{2,i} = f(x_2) - \\alpha_1y_1K_{1,2} - \\alpha_2y_2K_{2,2} - b v2​=i=3∑N​αi​yi​K2,i​=f(x2​)−α1​y1​K1,2​−α2​y2​K2,2​−b 已知： α1=(η−α2y2)y2\\alpha_1= (\\eta - \\alpha_2y_2)y_2 α1​=(η−α2​y2​)y2​ 可得到： (9)v1−v2=f(x1)−f(x2)−K1,1η+K1,2η+α2y2(K1,1+K2,2−2K1,2)v_1 - v_2 = f(x_1) - f(x_2) - K_{1,1}\\eta + K_{1,2}\\eta + \\alpha_2y_2(K_{1,1}+K_{2,2}-2K_{1,2}) \\tag{9} v1​−v2​=f(x1​)−f(x2​)−K1,1​η+K1,2​η+α2​y2​(K1,1​+K2,2​−2K1,2​)(9) 将(9)带入(7): ∂W(α2)∂α2=−(K1,1+K2,2−2K1,2)α2new+(K1,1+K2,2−2K1,2)α2old+y2(y2−y1+f(x1)−f(x2))\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -(K_{1,1} + K_{2,2} - 2K_{1,2})\\alpha_2^{new} + (K_{1,1} + K_{2,2}- 2K_{1,2})\\alpha_2^{old} + y_2(y_2 - y_1 + f(x_1) - f(x_2)) ∂α2​∂W(α2​)​=−(K1,1​+K2,2​−2K1,2​)α2new​+(K1,1​+K2,2​−2K1,2​)α2old​+y2​(y2​−y1​+f(x1​)−f(x2​)) 记误差项Ei=f(xi)−yiE_i = f(x_i) - y_iEi​=f(xi​)−yi​ 令θ=K1,1,+K2,2−2K1,2\\theta = K_{1,1,}+K_{2,2}-2K_{1,2}θ=K1,1,​+K2,2​−2K1,2​ 可以得到最终表达式： ∂W(α2)∂α2=−θα2new+θα2old+y2(E1−E2)=0\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -\\theta\\alpha_2^{new}+ \\theta\\alpha_2^{old}+y2(E_1-E_2) = 0 ∂α2​∂W(α2​)​=−θα2new​+θα2old​+y2(E1​−E2​)=0 得到： (10)α2new=α2old+y2(E1−E2)θ\\alpha_2^{new} = \\alpha_2^{old} + \\frac{y_2(E_1- E_2)}{\\theta} \\tag{10} α2new​=α2old​+θy2​(E1​−E2​)​(10) 到了这里，如果要更新参数，仅需计算E，和\\theta 然后计算\\alpha2 原始解的修剪 现在考虑约束条件 上面通过对一元函数求极值的方式更新了参数得到了α2new,unclipped\\alpha_2^{new,unclipped}α2new,unclipped​ 现在通过对原始解的修正得到α2new,cilpped\\alpha_2^{new,cilpped}α2new,cilpped​ (10)α2new,unclipped=α2old+y2(E1−E2)θ\\alpha_2^{new,unclipped} = \\alpha_2^{old} + \\frac{y_2(E_1- E_2)}{\\theta} \\tag{10} α2new,unclipped​=α2old​+θy2​(E1​−E2​)​(10) 约束条件（画图分析）： ify1≠y2:if \\quad y_1 \\ne y_2 :ify1​​=y2​: 上界：L=max(0,α2old−α1old)上界：\\qquad L = max(0, \\quad \\alpha_2^{old} - \\alpha_1^{old}) 上界：L=max(0,α2old​−α1old​) 下界：H=max(C,C+α2old−α1old)下界：\\qquad H = max(C, \\quad C+\\alpha_2^{old} - \\alpha_1^{old}) 下界：H=max(C,C+α2old​−α1old​) elify1=y2:elif \\quad y_1 = y_2 :elify1​=y2​: 上界：L=max(0,α2old+α1old−C)上界：\\qquad L = max(0, \\quad \\alpha_2^{old} + \\alpha_1^{old} -C) 上界：L=max(0,α2old​+α1old​−C) 下界：H=max(C,α2old+α1old)下界：\\qquad H = max(C, \\quad \\alpha_2^{old} + \\alpha_1^{old}) 下界：H=max(C,α2old​+α1old​) 更新参数都可以计算：α1new\\alpha_1^{new}α1new​ 由： α1oldy1+α2oldy2=α1newy1+α2newy2\\alpha_1^{old}y_1 + \\alpha_2^{old}y_2 = \\alpha_1^{new}y_1 + \\alpha_2^{new}y_2 α1old​y1​+α2old​y2​=α1new​y1​+α2new​y2​ 得到： α1new=α1old+y1y2(α2old−α2new)\\alpha_1^{new} = \\alpha_1^{old} + y_1y_2(\\alpha_2^{old} - \\alpha_2^{new}) α1new​=α1old​+y1​y2​(α2old​−α2new​) 最后由式(6.17)-&gt;(6.18)可得到： b=1m∑s=1m[1/ys−∑mi=1αiyixiTxs]b = \\frac{1}{m}\\sum_{s=1}^{m}[1/y_s - \\sum_{m}^{i=1}\\alpha_iy_ix_i^Tx_s] b=m1​s=1∑m​[1/ys​−m∑i=1​αi​yi​xiT​xs​] 3.启发式选择变量 上述分析是在从N个变量中已经选出两个变量进行优化的方法，下面分析如何高效地选择两个变量进行优化，使得目标函数下降的最快。 第一个变量的选择 第一个变量的选择称为外循环，首先遍历整个样本集，选择违反KKT条件的αi\\alpha_iαi​作为第一个变量 接着依据相关规则选择第二个变量(见下面分析),对这两个变量采用上述方法进行优化。 当遍历完整个样本集后，遍历非边界样本(0&lt;αi&lt;C)(0&lt;α_i&lt;C)(0&lt;αi​&lt;C)中违反KKT的αi\\alpha_iαi​作为第一个变量，同样依据相关规则选择第二个变量，对此两个变量进行优化。当遍历完非边界样本集后，再次回到遍历整个样本集中寻找，即在整个样本集与非边界样本集上来回切换，寻找违反KKT条件的αiαi作为第一个变量。直到遍历整个样本集后，没有违反KKT条件αi\\alpha_iαi​，然后退出。 边界上的样本对应的αi=0\\alpha_i = 0αi​=0或者αi=C\\alpha_i = Cαi​=C，在优化过程中很难变化，然而非边界样本0&lt;αi&lt;C0&lt;α_i&lt;C0&lt;αi​&lt;C会随着对其他变量的优化会有大的变化。 KTT条件 αi=0⟺y(i)(wTx(i)+b)≥1\\alpha_i = 0 \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b)\\ge1 αi​=0⟺y(i)(wTx(i)+b)≥1 αi=C⟺y(i)(wTx(i)+b)≤1\\alpha_i = C \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b)\\le 1 αi​=C⟺y(i)(wTx(i)+b)≤1 0&lt;αi&lt;C⟺y(i)(wTx(i)+b)=10 \\lt \\alpha_i \\lt C \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b) =1 0&lt;αi​&lt;C⟺y(i)(wTx(i)+b)=1 第二个变量的选择 SMO称第二个变量的选择过程为内循环，假设在外循环中找个第一个变量记为α1\\alpha_1α1​，第二个变量的选择希望能使α2\\alpha_2α2​有较大的变化，由于α2\\alpha_2α2​是依赖于∣E1−E2∣|E1−E2|∣E1−E2∣,当E1E1E1为正时，那么选择最小的EiEiEi作为E2E2E2,如果E1E1E1为负，选择最大EiEiEi作为E2E2E2，通常为每个样本的EiEiEi保存在一个列表中，选择最大的∣E1−E2∣|E1−E2|∣E1−E2∣来近似最大化步长。 有时按照上述的启发式选择第二个变量，不能够使得函数值有足够的下降，这时按下述步骤: 1.首先在非边界集上选择能够使函数值足够下降的样本作为第二个变量， 2.如果非边界集上没有，则在整个样本集上选择第二个变量， 3.如果整个样本集依然不存在，则重新选择第一个变量。 参考 机器学习算法实践-SVM中的SMO算法 详细推导的SMO更新参数和修剪结果的公式， 优化算法效率：例如只需最后计算b。。。。 浅谈最优化问题的KKT条件 import numpy as np import matplotlib.pyplot as plt import copy from sklearn.metrics import roc_curve, auc, accuracy_score, confusion_matrix, classification_report, roc_auc_score np.random.seed(1) 定义训练集 Xtrain∈Rn×mX_{train} \\in \\R^{n \\times m} Xtrain​∈Rn×m xi∈Rn,即每一个样本有n个特征x_i \\in \\R^n,即每一个样本有n个特征 xi​∈Rn,即每一个样本有n个特征 label∈{−1,1},二分类问题label \\in \\{-1,1\\},二分类问题 label∈{−1,1},二分类问题 多种核函数 def LinearKernel(x_i, x_j): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) return np.dot(x_i.T, x_j) def GaussKernel(x_i, x_j, sigmoid): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) if sigmoid &lt;= 0: raise Exception(&quot;sigmoid must be a positive number&quot;) return np.exp(-np.dot((x_i - x_j).T, (x_i - x_j))/(2 * sigmoid**2)) def PolyKernel(x_i, x_j, d): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) if d &lt; 0: raise Exception(&quot;d must be a Semi-positive number&quot;) return LinearKernel(x_i, x_j)**d def LaplaceKernel(x_i, x_j, s): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) if s &lt;= 0: raise Exception(&quot;sigmoid must be a positive number&quot;) # print(np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / sigmoid)) return np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / s)[0][0] def SigmoidKernel(x_i, x_j, beta, theta): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) if theta &gt;= 0: raise Exception(&quot;theta must be a negetive number&quot;) if beta &lt;= 0: raise Exception(&quot;theta must be a positive number&quot;) return np.tanh(beta * LinearKernel(x_i, x_j) + theta) def K(x_i, x_j, kernel = &quot;linear&quot;, s = .5, beta = 1, theta = -1, d = 2): # print(x_i.shape, x_j.shape) kernel = kernel.lower() try: if kernel == 'linear': return LinearKernel(x_i, x_j) elif kernel == 'gauss': return GaussKernel(x_i, x_j, s) elif kernel == 'poly': return PolyKernel(x_i, x_j, d) elif kernel == 'laplace': return LaplaceKernel(x_i, x_j, s) elif kernel == 'sigmoid': return SigmoidKernel(x_i, x_j, beta, theta) except Exception as err: print('An exception happened: ' + str(err)) if __name__ == &quot;__main__&quot;: x_i = np.ones((10,1)) x_j = np.random.randn(10,1) print(np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / 1)) print(K(x_i,x_j,kernel=&quot;Laplace&quot;, s=1)) [[0.005973]] 0.005973003723489288 生成同心圆数据 import numpy as np def load(type = &quot;circle&quot;): x = np.random.uniform(-1,1,(100,1)) y = np.random.uniform(-1,1,(100,1)) x_train = np.c_[x,y].T print(x_train.shape) label_train = np.ones((100,1)) mask = (x**2 + y**2 ) &lt; .5 label_train[mask] = -1 x1 = np.random.uniform(-1,1,(100,1)) y1 = np.random.uniform(-1,1,(100,1)) x_test = np.c_[x1,y1].T print(x_test.shape) label_test = np.ones((100,1)) mask = (x1**2 + y1**2 ) &lt; .5 label_test[mask] = -1 return x_train, label_train, x_test, label_test if __name__ == &quot;__main__&quot;: x_train, label_train, x_test, label_test = load() print(x_train.shape, label_train.shape, x_test.shape, label_test.shape) (2, 100) (2, 100) (2, 100) (100, 1) (2, 100) (100, 1) 参照第一个SMO推导笔记需要实现以下功能： 初始化参数（主要是\\alpha） 由于采用缓存（用一个列表记录）所有的Ei=yi−f(xi)E_i = y_i - f(x_i)Ei​=yi​−f(xi​) 所以每一次更新参数α\\alphaα后都需要更新Ei,EjE_i, E_jEi​,Ej​ 因为由KKT条件约束，所以需要对最后的结果进行修剪 所以需要实现 clip() f(indexi)用于实现对训练集的某一个特征向量计算预测值f(index_i)用于实现对训练集的某一个特征向量计算预测值f(indexi​)用于实现对训练集的某一个特征向量计算预测值 predict(xi)用于预测任意给定的特征向量xipredict(x_i)用于预测任意给定的特征向量x_ipredict(xi​)用于预测任意给定的特征向量xi​ select()函数的内循环和外循环用于选择最不满足KKT条件的并且能够使得更新效果最明显的αiαj\\alpha_i \\quad \\alpha_jαi​αj​ loss()用于计算E update_a2()用于更新α2\\alpha_2α2​ update_a1()使用α2\\alpha_2α2​和α1old\\alpha_1^{old}α1old​更新α1\\alpha_1α1​ SMO()是smo算法的主循环 以上函数与SMO算法紧密相关，为了方便参数，数据集，的传输将他们放到一个SMO类中实现 class SMO: def __init__(self, x, y, kernel = &quot;Laplace&quot;, C=10): self.x = copy.deepcopy(x) self.y = copy.deepcopy(y) self.m = x.shape[1] self.n = x.shape[0] self.kernel = kernel self.C = C def init(self): # self.w = np.random.randn(self.n, 1) self.b = np.zeros((1, 1)) self.a = np.zeros((self.m, 1)) E = [] for i in range(0, self.m): E.append(self.loss(i)) self.E = E # 每次更新参数后需要更新E def updateE(self, i, j): self.E[i] = self.loss(i) self.E[j] = self.loss(j) def clip(self, index_1, index_2, old_1, old_2): # get H, L alpha = self.a[index_2,:][0] if self.y[index_1, :] != self.y[index_2, :]: L = max(0.0, old_2[0] - old_1[0]) H = max(self.C, self.C + old_2[0] - old_1[0]) else: # print(&quot;----------&quot; , self.C, old_2[0], self.C + old_2[0],'-------------') L = max(0.0, old_2[0] + old_1[0] - self.C) H = max(self.C, old_2[0] + old_1[0]) if alpha &lt; L: return L elif alpha &gt; H: return H else: return alpha def f(self, x_index): k = np.zeros(self.y.shape) for i in range(0, self.m): k[i,:] = copy.deepcopy(K(self.x[:,i].reshape(-1,1), self.x[:,x_index].reshape(-1,1), kernel = self.kernel)) return np.sum(self.a * self.y * k)+self.b # 此处是选择第二个变量，第一个变量仅需要无脑便利就好了 # 需要传入第一个变量的index以计算E_1 # 是否可以将select写成一个生成器？ def select(self): for i in range(0, self.m): # label用于标志是否违反KKT label = False temp = self.y[i, :] * self.f(i) if self.a[i, :] == 0: if temp &lt; 1 : label = True elif 0 &lt; self.a[i, :] and self.a[i, :] &lt; self.C: if temp &gt; 1: label = True else: if temp != 1: label = True # 如果违反KKT条件，进入内循环选择第二个a if label == True and self.E[i] &lt;= 0: j = np.argmax(np.array(self.E)) yield i,j if label == True and self.E[i] &gt;0: j = np.argmin(np.array(self.E)) yield i,j # 需要得到边界变量的下标值 boolen = (self.a &gt; 0) &amp; (self.a &lt; self.C) edgeVar = [] for i in range(0, len(boolen)): if boolen[i] == True: edgeVar.append(i) for i in edgeVar: # label用于标志是否违反KKT label = False temp = self.y[i, :] * self.f(i) if self.a[i, :] == 0: if temp &lt; 1 : label = True elif 0 &lt; self.a[i, :] and self.a[i, :] &lt; self.C: if temp &gt; 1: label = True else: if temp != 1: label = True # 如果违反KKT条件，进入内循环选择第二个a if label == True and self.E[i] &lt;= 0: j = np.argmax(np.array(self.E)) yield i,j if label == True and self.E[i] &gt;0: j = np.argmin(np.array(self.E)) yield i,j # E_i = f(x_i) - y_i def loss(self, index): return self.f(index) - self.y[index, :] def update_a2(self, alpha2_old, index_1, index_2): theta = K(self.x[:,index_1].reshape(-1,1), self.x[:,index_1].reshape(-1,1), kernel = self.kernel) + K(self.x[:,index_2].reshape(-1,1), self.x[:,index_2].reshape(-1,1), kernel = self.kernel) - 2*K(self.x[:,index_1].reshape(-1,1), self.x[:,index_2].reshape(-1,1), kernel = self.kernel) if theta &lt; 0.001 and theta &gt;= 0: theta = 0.001 if theta &gt; -0.001 and theta &lt;0: theta = 0.001 dE = self.E[index_1] - self.E[index_2] # print(&quot;in update_a2 theta:{}, dE:{}, y2:{}&quot;.format(theta, dE, self.y[index_2])) return alpha2_old + (self.y[index_2] * dE) / theta def update_a1(self, alpha1_old, alpha2_old, alpha2_new, index_1, index_2): return alpha1_old + self.y[index_1] * self.y[index_2] * (alpha2_old - alpha2_new) def SMO(self, maxtimes): for i in range(0, maxtimes): if i % 10 == 0: print(&quot;this is {}th loop.&quot;.format(i)) for i, j in self.select(): temp = copy.deepcopy(self.a[j]) self.a[j] = self.update_a2(self.a[j], i, j) self.a[j] = self.clip(i, j, self.a[i], temp) self.a[i] = self.update_a1(self.a[i], temp, self.a[j], i, j) self.updateE(i, j) # 更新b self.b = np.sum(1/self.y)/self.m for i in range(0, self.m): self.b -= (self.f(i)/self.m) print(self.b) def predict(self, x): k = np.zeros(self.y.shape) for i in range(0, self.m): k[i,:] = copy.deepcopy(K(self.x[:,i].reshape(-1,1), x.reshape(-1,1), kernel = self.kernel)) # return k return (np.sum(self.a * self.y * k) + self.b) def predictAll(self, x_test): # get prected y y_pred = np.zeros(y_test.shape) for i in range(0, x_test.shape[1]): y_pred[i, :] = self.predict(x_test[:, i].reshape(2, -1)) return y_pred def evaluate(y_t, y_p): y_test = copy.deepcopy(y_t) y_pred = copy.deepcopy(y_p) print(&quot;The roc_auc_score is {}&quot;.format(roc_auc_score(y_test, y_pred))) tpr,fpr,thresholds = roc_curve(y_test,y_pred) plt.subplot(1,2,1) plt.plot(fpr, tpr) plt.xlim([0.0, 1.0]) plt.ylim([0.0, 1.0]) plt.title('ROC curve for diabetes classifier') plt.xlabel('False Positive Rate (1 - Specificity)') plt.ylabel('True Positive Rate (Sensitivity)') plt.grid(True) # mean = np.sum(y_pred)/y_pred.shape[0] y_pred[(y_pred &lt; 0)] = -1 y_pred[(y_pred &gt;= 0)] = 1 # plt.scatter(x_test[0, :], x_test[1, :], c = y_pred[:, 0]) print(&quot;The accuracy is {}&quot;.format(accuracy_score(y_test[:,0], y_pred[:,0]))) # 计算召回， 查全率， 查准率 。。。。 target_names = ['class0','class1'] print(classification_report(y_test,y_pred,target_names = target_names)) def draw_svm(smo): xx, yy = np.meshgrid(np.arange(-1, 1, 0.01), np.arange(-1, 1, 0.01)) zz = np.zeros((200, 200)) for i in range(0, 200): for j in range(0, 200): temp = np.array([xx[i, j], yy[i, j]]).reshape(2, -1) res = smo.predict(temp) # print(res) zz[i, j] = res # print(zz[i, j]) zz[(zz &lt; 0)] = -1 zz[(zz &gt;= 0)] = 1 plt.subplot(1,2,2) plt.contourf(xx, yy, zz) # # print(x[0,:].shape, x[1,:].shape, y.shape) plt.scatter(smo.x[0,:].reshape(1, -1), smo.x[1,:].reshape(1, -1), c = 0 - smo.y.T) plt.show() 导入数据 此处生成同心圆数据，以区别线性核和非线性核之间的区别 x_train, y_train, x_test, y_test = load() # plt.scatter(x_train[0, :], x_train[1, :], c = y_train[:, 0]) (2, 100) (2, 100) 使用高斯核的SVM 此处σ=0.5\\sigma = 0.5σ=0.5,取值为1时，准确率就很低了，不知道怎么回事（先补一下核函数更多的技术了， 狗头.jpg） smo = SMO(x_train, y_train, C = 2, kernel = &quot;gauss&quot;) smo.init() smo.SMO(110) y_pred = smo.predictAll(x_test) evaluate(y_test, y_pred) draw_svm(smo) this is 0th loop. this is 10th loop. this is 20th loop. this is 30th loop. this is 40th loop. this is 50th loop. this is 60th loop. this is 70th loop. this is 80th loop. this is 90th loop. this is 100th loop. 1.0542578147143928 The roc_auc_score is 0.982048143614851 The accuracy is 0.89 precision recall f1-score support class0 0.80 1.00 0.89 43 class1 1.00 0.81 0.89 57 accuracy 0.89 100 macro avg 0.90 0.90 0.89 100 weighted avg 0.91 0.89 0.89 100 使用线性核的SVM smo = SMO(x_train, y_train, C = 2, kernel = &quot;linear&quot;) smo.init() smo.SMO(110) y_pred = smo.predictAll(x_test) evaluate(y_test, y_pred) draw_svm(smo) this is 0th loop. this is 10th loop. this is 20th loop. this is 30th loop. this is 40th loop. this is 50th loop. this is 60th loop. this is 70th loop. this is 80th loop. this is 90th loop. this is 100th loop. 0.27041462716608683 The roc_auc_score is 0.4618523051815585 The accuracy is 0.48 precision recall f1-score support class0 0.41 0.49 0.45 43 class1 0.55 0.47 0.51 57 accuracy 0.48 100 macro avg 0.48 0.48 0.48 100 weighted avg 0.49 0.48 0.48 100 调用之前写过的决策树C4.5 from dt import buildTree, Node, predictAll, predict, draw_tree import pandas as pd X_train = np.r_[x_train, y_train.T] X_train = pd.DataFrame(X_train.T, columns=[&quot;x&quot;,'y',&quot;label&quot;]) X_test = np.r_[x_test, y_test.T] X_test = pd.DataFrame(X_test.T, columns=[&quot;x&quot;,'y',&quot;label&quot;]) Y_test = np.array(list(X_test[&quot;label&quot;])).reshape(-1,1) root = Node(Dataset=X_train, attrList = ['x','y']) root = buildTree(root) Y_pred = predictAll(root ,X_test) evaluate(Y_test, Y_pred) draw_tree(root) plt.scatter(X_train[&quot;x&quot;], X_train[&quot;y&quot;], c = 0 - X_train[&quot;label&quot;]) The roc_auc_score is 0.7105263157894737 The accuracy is 0.67 precision recall f1-score support class0 0.57 1.00 0.72 43 class1 1.00 0.42 0.59 57 accuracy 0.67 100 macro avg 0.78 0.71 0.66 100 weighted avg 0.81 0.67 0.65 100 &lt;matplotlib.collections.PathCollection at 0x7f523e323310&gt; 分析 对于同心圆这种线性不可分的数据，使用linear kernel只能得到约50/100的准确度 使用决策树，这里由于决策变量只有x，y所以，这里的决策树虽多两层，对于特征向量较小的数据集不友好 使用拉普拉斯核（测试时用的拉普拉斯核，准确率略高于高斯核） 或者 高斯核在该种线性不可分的数据集中起到了很好的升维作用 使用神经网络可以得到很好的效果（在神经网络实现的时候，测试过该数据集，随着层数的增加，能达到99/100的准确率） import tensorflow==2.0.0 Cannot run import tensorflow because of system compatibility. AI Studio prepared an entire environment based on PaddlePaddle already. Please use PaddlePaddle to build your own model or application. ","link":"https://xuaii.github.io/post/svm/"},{"title":"【转载】VR扯掉了中国科技圈的遮羞布","content":"转自知乎 Oculus应该卖给谁？好大的一个问题啊。 卖给谁都可以，但就是不该卖给Facebook！ 卖给Apple多合适，那里有全世界最好的消费电子产品。卖给Google也不错，安卓系统逐渐统治世界，Google眼镜刚被《时代》杂志评为那一年最令人期待的硬件产品。 还可以选微软，VR（Virtual Reality，虚拟现实）最直观的使用场景就是游戏，这和微软Xbox游戏机一脉相承。就连亚马逊，好歹也做出了Kindle，在人类出版界放了一场大火。 再看看Facebook呢？一点做硬件的经验都没有。扎克伯格(Mark Zuckerberg)曾经放出狠话要做手机，折腾了半天，只是竹篮打水一场空。 不仅如此，Oculus还非常不facebook。CTO压根没有Facebook账户，CEO的办公室里赫然挂着一副对Facebook不敬的工艺品，员工把嘲笑Facebook当作工作的日常，FB是一个典型的反面教材：僵化的公司、糟糕的设计、隐私的小偷。 当扎克伯格千里迢迢来拜访Oculus全体员工，一位叫Dycus的员工，当着全公司的面问小扎：很多人（当然，不包括我哈），都觉得Facebook是邪恶的（Facebook is evil），你觉得，这会怎么影响Oculus的形象？ 图：戴着Oculus的扎克伯格 但是扎克伯格却像被施了法术，对Oculus着了魔。 扎克伯格带着Facebook一众高管轮流戴了一会Oculus的VR头盔。 当时还只是样品，距离成品上市，还有很远的距离。即使到了今天，VR头盔都没有克服最大的bug——晕眩。更别说7年前了。小扎卸下头盔的刹那，估计和学生时代在哈佛大学通宵宿醉后一样的难受，但是，小扎连同CTO和负责产品的VP，对这个新奇的玩意赞不绝口，反复说着：holy crap（专业翻译：我X, NB啊）。 5天后，这位全球最大社交网络的管理者亲自去了这家创业公司的办公室。 这一天，这位全世界最富有的80后背了一个麦当劳的购物袋。这真是神来之笔。本来对Facebook没有一点好感的年轻极客们，瞬间议论纷纷：真是没想到，互联网超级大佬，原来是和我一样的人。 在狠狠拉了一波好感值后，扎克伯格为这家创办仅仅2年的公司开出了无法拒绝的价码——30亿美元。以及反复的劝诱和许诺：Oculus会成为Facebook唯一的平台，我要让Oculus成为VR的领导者！ 怎么拉近资本和创业者的距离，小扎可能是全世界最懂这件事的人。当年Facebook刚刚成立，小扎要去红杉资本的办公室谈融资。在肖恩·帕克（Sean Parker）的教唆下，他穿着睡衣走进了高大上的办公室。 西装革履的中年油腻男被挑逗得欲火焚身，这才是TMD真极客！投他，必须投他！ 那只麦当劳的手提袋，很难说不是一场精心设计的轮回。这位哈佛辍学生，有一个木讷的外表，以至于常常让我们忽略了他极其精明和复杂的内心世界。 但是。 搞VR？！你还是想想清楚吧，这个专门绞杀科技巨头的战场，早已白骨累累。 01 从弗兰克鲍姆的《万能钥匙》到赫胥黎的《美丽新世界》，从伍迪艾伦的《沉睡者》（1973年），到斯皮尔伯格的《头号玩家》（2018年），VR（虚拟现实）是所有科幻小说、科幻电影的必备元素。 带上一套装备，通过视觉、嗅觉、触觉，让人走进一个完全虚拟的世界。还有比这更cool的科技产品吗？ 斯皮尔伯格的电影《头号玩家》主题就是一个VR游戏 写出《数字化生存》的MIT（麻省理工）教授尼葛洛庞帝说，他从1969年就开始关注VR。 没错，在连彩色电视机都没有普及的60年代，真极客们就已经在尝试做VR头盔。90年代，任天堂、世嘉，以及乔布斯实习过的雅达利，先后对着VR设备，大搞特搞。 世嘉（SEGA）搞得最轰动。产品宣传了三年，发布会开了又开，《大众科技》的杂志封面也如愿登过了。结果，临门一脚，突然宣布不发布了，放了全世界一个大鸽子。世嘉的理由是：VR游戏太过真实，玩家在游戏过程中不由自主地移动，容易受伤。 拉倒吧。 受伤是真的，但不是因为移动，而是因为晕眩导致的恶心头疼。VR营造了一个深度沉浸的世界，如果技术跟不上，虚拟画面和现实动作有延时，会造成严重的晕眩，类似现实中的晕车。 从此，晕眩感成为横亘在VR产业面前的一道天堑，或者说一道魔咒。人类科技界对VR的第一次攻关，以被团灭的方式告终。 紧接着，互联网来了。亚马逊、Google先后问世，那些利用互联网连接存量资源，那些消费主义的迎合者，成了硅谷的新宠。 时代换了一批新的宾客，但是极客的火苗没有完全熄灭。把科幻小说里最cool的装备变成现实，也是科技新贵的梦。 Google先做AR(Augmented reality，增强现实)，谷歌眼镜（Google Glass）才出了几张宣传照，全世界科技迷就自嗨到了高潮，不仅有英国王子这样的社会名流野生代言，而且频频被各类媒体评价为人类最具创新、最值得期待的产品。Google又感动又兴奋，再接再厉做了一个VR的平台Daydream，满腔热血期待复制一个安卓的神话。 三星，作为当时全球出货量第一的手机品牌，也狠狠表示了一把，弄出个Gear VR。但是，Google眼镜、Daydream，GearVR，全部火不过两年，最终销声匿迹。 目前为止，人类最重要的硬件还是智能手机。Google和三星是这个行业绝对的领导者，在产业链里是一呼百应。那么强的能力，那么厚的背景，在VR行业也不过是碰一鼻子灰，羞羞地找个台阶下。 这就是Facebook收购Oculus的背景。在硅谷，Facebook的标签是侵犯隐私、抄袭模仿、功利主义，这样的扎克伯格可能做出人类最新奇的硬件吗？ 02 2016年，小扎正在为Facebook进入中国努力。顶着大雾霾，毅然决然地在天安门前跑步，是个又红又专的好少年。 那次扎克伯格来北京，目的是参加由国务院发展研究中心主办的中国发展高层论坛。 93岁的基辛格老爷子做了《避免修昔底德陷阱》的演讲，接下来就是扎克伯格和马云的谈话。扎克伯克表示，前两年我收购了Oculus，今年会推出一款VR头盔，今年消费级VR就会爆发，五到十年之后，VR手机会成为市场主流。 马云说，行啊，我会帮你。 其实，不只是姓赵。姓马，也是有鄙视链的。 就拿马克·扎克伯格、马云、马斯克来说。 小扎像个中国人，场面上说话一定圆滑，不轻易得罪人。和马云聊天客客气气的，上来先介绍自己正在学习中文，但是还很糟，所以辛苦马云今天用英语交流，谢谢大家的理解。 你再看看马斯克？那副得瑟劲。同样是来中国参加对话，马斯克一点不给马老师面子，把马氏鸡汤里的逻辑矛盾、事实错误全指了出来。喜欢阿里的人千万别放心上，其实玩硬核科技的马斯克最看不起的人，是马克·扎克伯格。马斯克不带修饰地说过：Facebook垃圾（Facebook sucks），窃取隐私、只会垄断，扎克伯格小朋友对于AI一无所知……然后，以身作则地把自己的Facebook账户注销了。 小扎心里是真苦啊。Facebook是全世界市值前五的互联网公司，说起来有头有脸，但是收入的95%都是广告。扎克伯格气不过的时候也想回怼两句，但是射火箭、卖电动的马斯克恐怕要怼一句更厉害的回来，“你个卖广告的，装什么B”，那年轻的小扎又要气得几天睡不着觉了。 马家人的鄙视链说到底就是一句话：互联网企业压根不是科技公司。 清醒点，好不好，你不过是做了一个网页，因为上线得足够早，早早占了个好坑，很多人用。形成了平台，形成了垄断，独占了数据，仅此而已。巴西男足踢中国男足，即使教练席栓一条狗，也能赢。是的，仅此而已。这怎么能配叫高科技？ 在马斯克眼中，扎克伯格就是这种不配的典型。 这就是扎克伯格坚持做VR的第二个背景。 何止是Google、三星，中国也多的是利用VR吹牛逼的大公司。就在扎克伯格和马云亲切交谈的那一年，阿里推出VR购物 “Buy＋”，目标是利用VR让网购变成逛商场的模样。另一个大手笔是领投了美国很火的AR创业公司Magic Leap，7.94亿美元的融资。 同一年，马化腾也给VR站过台，“VR是一场大洗牌，即将开始。就像移动互联网转型一样，上不了船的人将逐渐落伍”。当年由微信引发的“船票论”再次甚嚣尘上。据说腾讯启动了多款VR游戏的制作。还扬言也像Facebook一样做VR硬件，连原型机都搞出来了。然后，就没有然后了。 VR这件事，科技感爆棚，但是每次一燃，就会被泼下一盆又一盆的冷水。归根结底，有这样几个过不去的坎——晕动症、功能单一、缺乏优质内容、设备臃肿、价格昂贵…… 没过多久，Google、三星、阿里、腾讯都撤了，它们都不过是匆匆的过客，都没有成为推动行业前进的力量。 意外的是扎克伯格却固执地坚持了一下。 为什么？ 往低了说，是守护Facebook的社交边界。扎克伯格这个人，永远在警惕Facebook可能的颠覆者。Facebook的入职手册中，写着这样一句话：如果我们不去创造出能杀死Facebook的产品，有人会去做。 马化腾也表示过，VR/AR很可能是下一代社交，颠覆微信的那一种。 的确，微信毕竟只是一个平面的聊天框。用脚趾头就能想明白，如果VR创建一个虚拟space，渣男撩妹的空间会大很多很多。 Facebook开发的VR社交平台Horizon 往高了说，扎克伯格就是憋了一口气，去TMD马家人鄙视链。我要亲自证明Facebook的科技感——我来做一个新硬件，我来扩展人类的边界，我来打碎虚拟世界和现实世界的这面墙。 你们给我看清楚了。 03 扎克伯格有个枯燥且乏味的爱好——寻访有社交竞争力的创业公司，和创始人一见如故，再开一个你无法say no的条件，接着带你飞一段，然后闹掰，最终交恶。 扎克伯格先后收购Instagram和WhatsApp，它们的创始人斯特罗姆(Kevin Systrom)、克里格(Mike Krieger)、库姆(Jan Koum)都在2018年滚蛋。 Oculus自然不会例外，勒基(Palmer Luckey)只在Facebook待了三年就不愉快地离开。剩下的伊里比（Brendan Iribe）也在2018年打包走人。 VR设备有一项路线之争——做一个连接电脑/手机的硬件，还是做一个独立的设备？ 连接电脑/手机的好处显而易见，电脑/手机性能强，VR设备不需要计算，只需要负责显示，因此重量更轻（更适合戴在头上），成本更低。但是缺点也很明显，永远只能当附庸，本质就是一台显示器，一台戴在头上装X的显示器。 早期的Oculus很惊艳，但是选择的技术路线是做一个连接到电脑的显示器，因为创始人的首要的目标是打游戏要爽。 这群死肥宅怎么可能理解马克·扎克伯格的痛苦和野心？ Facebook麾下的Oculus一定要做独立的设备！怎么可以依附在电脑和手机上？电脑，是微软Windows的天下，手机王国已经被苹果iOS和Google安卓的瓜分完了。你们还想我扎克伯格卑躬屈膝到什么时候？ 这些年Facebook Reality Labs玩命地在屏显技术、眼球追踪、手指追踪、面部和身体追踪技术上烧钱，但是有一个前提。 一定要做独立的设备！ 扎克伯格为Oculus设计的战略是，硬件+操作系统+内容生态+应用商店分发+社交。我说得再简单一点哈，苹果和iPhone在智能手机行业是什么地位，Oculus在VR这个人类新硬件上，就要什么地位。 对，苹果有多NB，我就要多，N，B。 04 2016年，AR游戏精灵宝可梦GO （Pokemon Go）惊艳问世，让VR/AR产业实实在在地火了六个月。 紧接着全球VR/AR产业又跌回无休止的寒冰期，一眼望去看不到头的那种。 法律面前不一定人人平等，但是VR面前却做到了人人平等，不管你是Google三星阿里腾讯这样的巨头，还是爱逞强爱嘴炮的腰部互联网，又或者是灵活敢闯的独角兽，反正统统让你们死。 2016年，乐视说，VR是乐视生态重要的组成部分，然后乐视崩盘。暴风说，暴风会成为中国乃至世界VR行业的领导者，然后暴风势不可挡地成了“小乐视”。Magic Leap，AR行业最神秘的公司，拿了Google和阿里巴巴的投资，这个够骚了吧？但是这些年，管它叫“美国乐视”的人越来越多…… 人类就是可笑，折腾了那么久，那么多人那么多钱那么多会，最终还不如一只叫皮卡丘的黄色老鼠有能量——一款游戏为一个行业充电六个月。 踏踏实实地说，VR最基本的使用场景就是玩游戏，因此，出一款口碑爆表的VR游戏，比一万场口嗨发布会都管用。 看看隔壁的任天堂switch，这小破游戏机也默默无闻好多年，最终凭借《健身环大冒险》和《动物森林》两个爆款游戏，在2020年顺利出圈。 VR人喜欢这个励志故事，心里有个信念VR行业一定也能守得云开见月明。 2020年，《半衰期：爱莉克斯》（Half-Life: Alyx）来了。游戏媒体IGN给了罕见的满分评价，说“这像是一款来自未来的游戏”。 还记得小时候整个网吧都在玩的CS吧，《半衰期：爱莉克斯》和CS同宗同源，由顶级游戏公司Valve开发。不仅有人类游戏界的顶级IP坐镇，而且游戏操作用到了“真的VR”。 在PC和智能手机，游戏再好玩也只是二维的平面。但是VR游戏发生在一个三维的空间。在《半衰期：爱莉克斯》里，有怪物向你扑来，你会像现实生活中一样，很自然地举起椅子，把怪物隔开。 动图封面 《半衰期：爱莉克斯》（Half-Life: Alyx） Valve Index Controller指虎型的设计提供了可识别单个手指动作的功能，这就是VR的魅力，你可以真的用手玩游戏，而不是用鼠标和键盘——现实里手怎么动，游戏里手就怎么动。 如果说2016年的Pokemon Go是AR游戏的代表作，那么2020年的《半衰期：爱莉克斯》就是VR行业的里程碑。结结实实地让各大电商平台的VR头显卖到了缺货。 AR/VR的使命是打穿虚拟和现实之间的那道墙，2020年，这道墙肉眼可见地在变薄。 软件上陆续有了好游戏，VR硬件也有了普遍的进步。体现在一些专业的指标上，6自由度（6Dof）定位追踪、90Hz刷新率，以及更高的分辨率。 还记得那个该死的晕眩感吗？VR头盔让人晕眩，最主要的原因在于计算能力不行，有延迟。你在真实空间移动了，但是虚拟画面没有跟上同步移动，比如延迟了30毫秒，来来回回，就晕了。和晕车一个道理。 得益于专业AI芯片和AI空间定位算法，加上5G带来延时下降，晕眩的解决指日可待。行业一般认为把延时缩短到15毫秒以内，晕眩感就可以消除，而现在已经无限逼近。 VR硬件接连出现好设备，Facebook的Oculus Quest 2和索尼的PSVR，是公认的两强。 索尼有PS游戏机的底子，算是干好了老本行，但是Facebook这个互联网暴发户也杀了进来，确实让人刮目相看。 另外，PSVR不是独立设备，需要连接索尼PS主机才能玩。Oculus Quest一问世，索尼的市场份额节节败退。索尼感觉到了后继乏力，明确表示回家闭关修炼内功，到2022年再发布新产品，一决雌雄。 这样看来，Oculus势不可挡的劲头会延续一会。江湖有了传说，要等武林盟主苹果亲自出手，才能杀一杀Oculus的嚣张气焰。 扎克伯格可算是扬眉吐气了。 05 2014年，腾讯收购WhatsApp的交易几乎已经谈妥，就差马化腾和WhatsApp创始人Jan Koum见一面。 人算不如天算，关键时刻，马化腾腰伤的老毛病又犯了，决定先做手术，于是见面推迟。 不料扎克伯格趁虚而入，给Jan Koum开出190亿美元的天价。当时，WhatsApp才成立五年，50个人。 190亿美元！那还等什么马化腾牛化腾。Deal！ 时隔七年来看，马化腾的一次腰疼，让腾讯丢掉了国际化最好的抓手。时至今日，这家市值7万亿港元的中国第一互联网公司，年收入的95%都在中国，连跨国企业都称不上。你说你是靠竞争赢的，不是靠垄断，不过在全球市场，你好像没赢过吧？ 但是，2014年，谁能看得那么深远？微信支付奇袭支付宝，腾讯正在高歌猛进，革命气氛一片大好。 直到美国的科技媒体the Information写了一篇文章《Facebook应该向微信学习什么》（What Facebook Should Learn from WeChat），中国互联网圈，除了阿里巴巴脸色不好，别的从业者都集体高潮了。 辛辛苦苦这么多年，我们做的都是copy to china。永远都是美国什么火了，就copy一下去中国做一个一样的。中国的创业者去华尔街、硅谷讨钱，BP画得再精致老外也听不懂，远远不如换一个谦卑的口吻，有一种意味深长的声音说，“我们做的这个，就是这是中国的Facebook”，“中国的Yelp”，“中国的Amazon”……老外立刻懂了，百试不爽。 哪能想到有生之年能看到这个？！多豪情啊，是正儿八经的西方媒体，严肃的告诫，Facebook应该向中国的微信学习！甚至有人开始造一个新词“copy from china”。 厉害了，我的中国互联网。 不过，这故事还有一个更骚的结尾。2019年，扎克伯格竟然亲自回应了这篇文章，承认自己错了，说，悔不听君一席话，早学微信就好啦。 很奇怪，这一次，中国的舆论一点都不嗨了。嗨不起来。没错，腾讯和Facebook各自管理着中国最大和世界最大的社交产品，腾讯的市值甚至已经稳稳地超过了Facebook。 但是。 腾讯三分之一的收入是游戏。一年1000多亿元的游戏收入，常年在世界游戏公司收入中排名第一。讽刺的是，这个第一既做不出像使命召唤、星际争霸这样征服全球的3A游戏，也不能像Microsoft、任天堂、索尼一样，做出Xbox、Switch、PS这样的顶级游戏硬件。 这个星球上最赚钱的游戏公司，却对游戏行业的进步提供不了一丝一毫的推动。他是全世界最尴尬的游戏之王。 这就不难理解，在突如其来的VR时代里，能指望他做啥呢？ 06 VR，以及一脉相承的AR，再到现在新词运动里的MR(Mixed Reality，混合现实)和XR（Extended Reality，拓展现实），核心是一样的：把现实和虚拟更深地搞到一起。 纵观人类产业历史，一项高精尖的技术往往经历先军用，再商用/民用的发展过程。除了深度游戏玩家和科技迷，AR/VR距离普通人的生活还有一些远，但是其在军用和2B业务上已经站稳了脚跟，而消费级的民用产品，已经走到了爆发的前夜。 对一个人来说，付出总有回报。对一个产业来说，也是功不唐捐。 VR产业的核心技术包括定位技术、光学元件、操作系统、芯片、传感技术、人工智能、电子织物。VR头盔看似是一台游戏机，但实际上是一场高精尖技术的大阅兵。 比如，VR行业普遍使用的SLAM技术，在实时性和精度上要求非常高。能胜任VR的技术，反手就可以用于自动驾驶和机器人。 再比如，VR中的语音识别也有很高的要求，不仅要读懂语意，还要匹配嘴部运动，不仅要做到实时性，还要能捕捉面部动作。 重中之重是AI技术，VR中的定位和识别，一方面需要硬件支撑，一方面，要靠AI做了几十亿次的模拟。中国的科技大佬，动不动就说自己对于人工智能的投入，如今，是骡子是马，是时候拉出来遛遛了。 为什么说VR扯掉了中国科技商业圈的遮羞布？ 因为可以确定的是，中国产业界一定会重复自己在PC和智能手机时代一模一样的遗憾——造不来核心技术，站不上主导地位。 VR里，芯片还是高通的。如果说智能手机还有华为、苹果两个巨头自研芯片的杂音，那么VR行业就安静很多，Oculus、HTC，国内的小鸟、大朋所有主流设备的芯片都是高通的。 再比如，生态的争夺还是在硅谷内部。微软Windows操作系统了PC时代，智能手机有iOS和安卓争锋，同样，VR生态也会有操作系统。目前来看，Facebook走在前面，后面跟着微软（Windows Mixed Reality）和苹果这两个老家伙的追赶，至此，拿着望眼镜看，操作系统这件事也和中国无关。 内容开发更是中国企业弱项中的弱项，Oculus Quest上线了上百款游戏，只有一两款来自中国。 在VR战场的最前沿，唯一的中国元素应该是歌尔，提供代工，和部分非核心元器件。 VR一定会和PC和智能手机一样，重复一样的剧本——先来的人建好了生态，后来的玩家永远只能当绿叶或者当肥料，像今天一样，继续交苹果税，交安卓税，交高通税…… PC时代、智能手机时代，中国企业还有借口，因为发展浅，因为底子薄，除了联想有钱，都找不出能做大事的大公司。但是这一次，面对VR这个新硬件，没借口了吧，那么多互联网企业在中国挣到了惊掉西方同僚下巴的大利润。 当年，联想提“贸工技”，被骂惨了——你看，联想多短视，赚了钱不好好搞研发，没有卡住关键技术和关键位置，混成今天这样真是活该。 然后，产业界用了20年时间，只为了向世界证明，我们人人都是联想。 去做真的科技公司，在管理好财务平衡的同时，尽最大可能地用科技拓宽人类的边界，而不是只盯着短期能赚钱的事，靠垄断利润，把市值垒得如此虚高——这是中国产业界最要学习，却永远无法吸取的教训。 就拿VR来说，先行者和长期主义者的曙光渐渐展现。 按照销售数据估算，Oculus Quest 1和Oculus Quest 2的累计销量即将突破1000万。1000万什么概念？智能手机轻轻松松一年卖出10亿台，PC不断衰落，但是全球年销量依旧在2-3亿。这样看来1000万（而且还是累计数），简直不值一提，距离小扎自己吹的牛B，“要让10亿人使用Oculus”，还差9.9亿。 但是，行业里的参与者才知道，1000万，意味着行业的生态成型，已经有了规模经济，从此内容生产者可以赚到钱了，会有越来越多的开发者投入进来。内容越丰富，生态就越吸引用户。万事开头难，但Oculus迈过了第一道槛，这个生态将开始良性循环。 扎克伯格真是够心狠手辣的，把Oculus的价格杀到299美元，比一台普通智能手机还便宜。这是什么概念？前面提到Vavle公司自己的VR设备要999美元，吓退一众屌丝，不可能普及。华为绝对是国产之光和价格屠夫，但是华为VR产品的价格只能压到3000元人民币，而且和Oculus比，华为VR第一不是独立设备，第二性能差一截，第三生态差，没有好游戏。 Oculus的299美元，就好比早已是行业第一却在不断降价的特斯拉，后来者想进入这个行业，但是大门正在被扎克伯格一点点关上。 Facebook和他的VR叙事，应该是中国同行的一面镜子。 在VR身上，值得我们羡慕的是美国的商业生态。巨头公司敢打科技硬仗，重金投入在周期长、定位高的赛道，耐心孵化造生态，要干就要干核心技术。 这恰恰是中国科技界、产业界最短缺的。短视、功利，什么赚钱做什么，已经是深入灵魂的信仰。往深了说，因为你们没有极客精神，从来没有把扩宽人类边界当作自己的使命。以为提倡员工穿牛仔裤，给员工配mac电脑就是科技公司了，其实呢，大厂的胸牌再明光晃晃，一开口说话都是市侩的味道，是一个赶集的买卖人，其实很土的。 为什么会这样？ 第一是纵容垄断，而垄断的原因又是市场不开放。比如，说了那么多，其实中国根本买不到Oculus，毕竟Facebook都还没有进入中国市场。拿腾讯来说，只有遇到体量相当的竞争对手，才能走出“没有梦想”的诅咒。 第二，知识产权的保护还是远远不够。在中国只有傻子才好好做游戏和内容，你做得再好，第二天就有了免费下载的破解版。指望“用爱发电”，能完成产业迁跃，笑话。 新硬件之战，或者说，生态之战怎么打？这需要，大公司敢打硬仗，小公司能靠内容本身赚到钱。而我们暂时还没有这样的土壤。 VR真有意思，它的目标是拆掉虚拟和现实之间的那道墙。在我看来，中国要实现VR产业的大突破，我们的目标应该是先拆掉现实生活里的某些墙。 谢谢读完，虚拟人VR创始人倪志力，对此文亦有指导 ","link":"https://xuaii.github.io/post/zhuan-zai-vr-che-diao-liao-zhong-guo-ke-ji-quan-de-zhe-xiu-bu/"},{"title":"游戏机制-里世界","content":"里世界机制 机制概念简述：存在两个不同的世界，里世界和表世界 他们有大致相同的场景整体形状，不同的场景风格（例如，崭新&lt;-&gt;老旧，清洁&lt;-&gt;污染） 有一个透镜能在表世界看见里世界的物体并且互动 只有玩家能在里世界和表世界间穿梭，这意味着玩家可以通过切换世界来躲避伤害 所有的外部物体（除玩家外），与透镜发生碰撞时可以 以一种特效的的方式穿过，暗示对玩家没有伤害 直接与透镜碰撞然后消失 通过对透镜的形状限制来设计关卡 实现：表示世界和里世界将在一个场景节点中表示 透镜物体是一个Light2D， 通过光照Mask显示/剔除里世界的物体的Sprite 透镜物体是一个Area2D，通过记录进入区域中的里世界物体，并且实时修改里世界物体的碰撞形状，如果是表世界（那么根据简述3来处理） public class SuperLens : Area2D { public Dictionary&lt;string, InnerObject&gt; data = new Dictionary&lt;string, InnerObject&gt;(); public void OnObjectExit(Node node) { if(node is InnerObject innerObject &amp;&amp; data.ContainsKey(innerObject.Name)) { data.remove(innerObject.Name); } } public void OnObjectEnter(Node node) { if(node is InnerObject innerObject ) { data[innerObject.Name] = innerObject; } if(node is OuterObject outerObject ) { ProcessOuterObject(outerObject); } } public override void _PhysicsProcess(float delta) { foreach(var inner in data.Values) { // 更改碰撞体积 inner.Rect = inner.DefaultRect.overlap(this.Rect); } } } ","link":"https://xuaii.github.io/post/you-xi-ji-zhi-li-shi-jie/"},{"title":"游戏机制-窗体互动","content":"使用 Godot 对WindowFrame 进行拙劣的模仿，观察视频中的窗体有以下性质： 窗体既是 UI 也是可以与玩家互动的 场景物体 窗口的位置可以由场景物理改变也可以由鼠标控制改变 玩家可以发射子弹，子弹碰到的边进入锁定状态，一段时间后子弹消失，并且解除锁定 考虑一下几种设计： 方案一 存在一个窗体对象window和场景对象rect 每一帧将rect大小和位置经过MPV变换后同步到窗口大小 每一个rect 对象有一个默认的初始大小 rect 对象持有四条边的对象 line，每个line对象有 follow/move/lock/idle状态 Follow 状态的边跟随 target(player) 运动 Move 状态的边能被鼠标拖动 Lock 状态的边在玩家移动过程中充当 墙 或 地板 Idle 状态，是场景中没有 target 时的状态 rect 对象实进入场景树的时候生成 windows 对象，并持有，rect退出场景树的时候回收 windows 对象 各个状态都有对应的 Physics Collision Layer / Mask，例如锁定状态的边会阻挡某些攻击，拖动时和锁定时与玩家的碰撞是不一样的。 using Godot; using System; public class InteractiveAnchor : RigidBody2D { public Vector2 velocity; public bool IsStop = false; public Vector2 StopPosition = Vector2.Zero; ColorRect rect; RandomNumberGenerator _random = new RandomNumberGenerator(); public delegate void InteractiveAnchorCallBack(InteractiveAnchor anchor); public InteractiveAnchorCallBack callback; // cache 一旦锁定目标，不可更改！！ InteractiveLine AnotherCache = null; public override void _Ready(); public void Init(Vector2 _velocity, InteractiveAnchorCallBack _callback); public override void _ExitTree(); // // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta); // 添加抖动将要删除时 public void _on_DeleteEffect_timeout(); void _on_Area2D_body_entered(Node body); void _on_Area2D_body_exited(Node body); void CacheCurrentState(Vector2 origin_global_position); } public class InteractiveArea : Area2D { public override void _Ready(); Node Scene; public override void _EnterTree(); public override void _PhysicsProcess(float delta); void _on_Area2D_body_entered(Node body); void _on_Area2D_body_exited(Node body); } public class InteractiveBorder : Node2D { // 显示区域大小 public Rect2 window; [Export] public Rect2 DefalutRect; [Export] public float BorderWidth; public InteractiveLine left; public InteractiveLine right; public InteractiveLine top; public InteractiveLine down; public InteractiveWindow interactiveWindow; public Vector2 Start; public Vector2 End; public Rect2 UIRect; public override void _Ready(); public override void _EnterTree(); public override void _Draw(); public override void _Process(float delta); public override void _PhysicsProcess(float delta); public void Reset(); public void SetRect(Rect2 _window); public void SetCollision(bool flag); } public class InteractiveLine : KinematicBody2D { public bool IsLocked; static public string IsSlideName = &quot;&quot;; public SegmentShape2D shape; public InteractiveWindow window; public Vector2 velocity = Vector2.Zero; public int ColllisionCount = 0; [Export] public Vector2 DefaultBias; public override void _Ready(); public override void _ExitTree(); public override void _PhysicsProcess(float delta); public void SetCollision(uint layer, uint mask); public void Reset(); public float DistanceToLine(Vector2 P, Vector2 A, Vector2 B); } public class InteractiveLineFollow : StateNode&lt;InteractiveLine&gt; { public override void Enter() { target.SetCollision(target.window.FollowLayer, target.window.FollowMask); } public override void _PhysicsUpdate(float delta) { /// 如果没有目标，就转移到Lock？ if(!target.window.IsLockTarget) { _machine.Transition&lt;InteractiveLineIdle&gt;(); return; } if(target.window.Target.IsInsideTree()) { target.GlobalPosition = target.window.Target.GlobalPosition + target.DefaultBias; } if(target.ColllisionCount != 0) { _machine.Transition&lt;InteractiveLineLock&gt;(); return; } } public class InteractiveLineIdle : StateNode&lt;InteractiveLine&gt; { public override void _PhysicsUpdate(float delta) { if(target.window.IsLockTarget) { _machine.Transition&lt;InteractiveLineFollow&gt;(); return; } } } public class InteractiveLineLock : StateNode&lt;InteractiveLine&gt; { Vector2 cachePosition = Vector2.Zero; public override void Enter() { target.IsLocked = true; cachePosition = target.Position; target.SetCollision(target.window.LockLayer, target.window.LockMask); } public override void Exit() { target.IsLocked = false; } public override void _PhysicsUpdate(float delta) { // TODO:这里是否可以不移动锁定的目标不移动 if(cachePosition != null) target.Position = cachePosition; if(target.ColllisionCount == 0) { _machine.Transition&lt;InteractiveLineFollow&gt;(); return; } if(Input.IsActionJustPressed(&quot;mouse_right&quot;) &amp;&amp; target.NormalToLine(target.GetGlobalMousePosition(), target.GlobalPosition + target.shape.A, target.GlobalPosition + target.shape.B).Length() &lt; 14f) { // 进入拖动状态 _machine.Transition&lt;InteractiveLineMove&gt;(); return; } } } public class InteractiveLineMove : StateNode&lt;InteractiveLine&gt; { public override void Enter() { target.SetCollision(target.window.MoveLayer, target.window.MoveMask); } public float PlayerMargin = 50f; private float MoveSpeed = 50f; public override void _PhysicsUpdate(float delta) { if(!target.window.IsLockTarget) { _machine.Transition&lt;InteractiveLineIdle&gt;(); return; } Vector2 line_movement = target.NormalToLine(target.GetGlobalMousePosition(), target.GlobalPosition + target.shape.A, target.GlobalPosition + target.shape.B); Vector2 player_movement = target.NormalToLine(target.window.Target.GlobalPosition, target.GlobalPosition + target.shape.A, target.GlobalPosition + target.shape.B); if(line_movement.Dot(player_movement) &lt; 0f || !target.window.Target.TestMove(target.window.Target.GlobalTransform, line_movement * delta) || player_movement.Length() &gt; PlayerMargin) { // 鼠标位置与Player在line异侧不限制速度，player与line距离足够大不限制速度；其余情况限制速度 if(line_movement.Dot(player_movement) &lt; 0f || player_movement.Length() &gt; PlayerMargin) { target.GlobalPosition += line_movement; } else { target.GlobalPosition += line_movement.Normalized() * MoveSpeed * delta; } } if(Input.IsActionJustReleased(&quot;mouse_right&quot;)) { _machine.Transition&lt;InteractiveLineLock&gt;(); return; } } } public class InteractiveWindow : Node2D { // window local position [Export] PackedScene bullet; [Export(PropertyHint.Layers2dPhysics)] public uint MoveMask; [Export(PropertyHint.Layers2dPhysics)] public uint MoveLayer; [Export(PropertyHint.Layers2dPhysics)] public uint FollowMask; [Export(PropertyHint.Layers2dPhysics)] public uint FollowLayer; [Export(PropertyHint.Layers2dPhysics)] public uint LockMask; [Export(PropertyHint.Layers2dPhysics)] public uint LockLayer; ShaderMaterial shader; public InteractiveBorder border; Main screen; // canvas + window related WindowDialog dialog; CanvasLayer canvas; // screen effects Tween tween; RandomNumberGenerator _random = new RandomNumberGenerator(); Queue&lt;InteractiveAnchor&gt; queue = new Queue&lt;InteractiveAnchor&gt;(); // mouse related // physics's disabled area Area2D area; RectangleShape2D shape; [Export] Vector2 SoftMargin = new Vector2(5, 5); // target lock related public bool IsLockTarget = false; public KinematicBody2D Target = null; public Console _wrapper; public override void _Ready(); public override void _EnterTree(); public override void _ExitTree(); void _DeferredPrograce() { screen.RemoveChild(canvas); screen.ResetScreen(); this.AddChild(canvas); } public override void _PhysicsProcess(float delta) { // 1. window 更新 + 可视区剪裁 screen.SetDisplayRect(border.Start, border.End); // 2. windowdialog 对齐 dialog.Popup_(border.UIRect.Clip(screen.viewport.GetVisibleRect())); // 3. 物理开启区域对齐 area.Position = border.window.Position - SoftMargin; shape.Extents = border.window.Size + SoftMargin * 2; } public void OnWindowGuiInput(InputEvent inputEvent) { if (inputEvent is InputEventMouseButton mouseEvent &amp;&amp; mouseEvent.Pressed) { switch ((ButtonList)mouseEvent.ButtonIndex) { case ButtonList.Left: { if(IsLockTarget) { InteractiveAnchor anchor = bullet.Instance&lt;InteractiveAnchor&gt;(); anchor.GlobalPosition = GetGlobalTransform().AffineInverse() * GetViewportTransform().AffineInverse() * (border.Start + mouseEvent.Position); this.CallDeferred(&quot;add_child&quot;, anchor); // anchor.CallDeferred(&quot;Init&quot;, border.Start + mouseEvent.Position - BasicFollowCamera.Target.ScreenPosition, (object)EffectCallback); anchor.Init((border.Start + mouseEvent.Position - BasicFollowCamera.Target.ScreenPosition), EffectCallback); } break; } case ButtonList.WheelUp: break; } } if (inputEvent is InputEventKey keyEvent &amp;&amp; keyEvent.Pressed) { switch ((int)keyEvent.Scancode) { case (int)KeyList.L: { break; } } } } // delete callback public void EffectCallback(InteractiveAnchor anchor); void disturb_offset(float _strength) { dialog.RectPosition += new Vector2(_random.RandfRange(-_strength, _strength), _random.RandfRange(-_strength, _strength)); screen.GetNode&lt;TextureRect&gt;(&quot;CanvasLayer/_ScreenTexture&quot;).RectPosition += new Vector2(_random.RandfRange(-_strength, _strength), _random.RandfRange(-_strength, _strength)); } public void LockTarget(KinematicBody2D target); public void UnlockTarget(); public void EnableBackground(); public void DisableBackground(); public void SetRect(Rect2 _window); public void Reset(); // CommandLine private void LockPlayer(); private void _on_ActivateArea_body_entered(Node body); } 总结：这样的设计有以下缺陷 拖动 Line 时不能直接修改 velocity，因为拖动时Line有可能会与Player发生碰撞（需要KinematicBody2D 的SlideAndCollide方法更新速度），所以只能设计一种有鼠标位置计算 Line.velocity 的方法。 窗口Window对象在场景的UI节点下，借此将场景相机的画面绘制到窗口相应的位置，这样设计与物体外的结构耦合。 如果想实现窗口外的一切对象停止更新比较麻烦（仅仅 Update 相机内的对象），应该有引擎自带的方法比较方便。 方案二 不使用 UI 对象，将交互和物理全部集中到一个 Rect 对象中。 交互窗体包含四条边，每条边包含碰撞设置和鼠标靠近检查（锁定状态） 每条边拥有相似的几种状态，特别的在拖动时，依然使用velocity来移动每条边 当鼠标左键按下 &amp;&amp; 鼠标位置在边的拖动区域时 ==&gt; 进入拖动状态 松开鼠标左键时 ==&gt; 退出拖动状态 拖动状态下，鼠标位置，边位置，边速度的关系如下 velocityL=(posM−posL)⋅normalL∣∣normalL∣∣velocity_L = \\frac{(pos_M - pos_L) \\cdot normal_L}{||normal_L||} velocityL​=∣∣normalL​∣∣(posM​−posL​)⋅normalL​​ 这样，窗口移动始终比鼠标位置延后一帧，但是移动过程中可以进行物理检测 3. 窗口根据三条边的位置绘制窗口（场景中绘制），并且生成一个mask覆盖整个屏幕（不使用方案一中生成相机纹理在windows中显示） 4. 如果某条边的移动会使得 player 与其他物体碰撞，那么该移动应该被修正: 会与player碰撞的物体有两种可能： a. 场景中的物体 -&gt; 丢弃当前的移动 b.窗体中的自由对边 -&gt; 保持当前移动 c.窗体中的锁定对边 -&gt; 丢弃当前移动 为了使移动边感知到玩家的碰撞，需要为边增加一个Push状态（不用增加，写在Move里即可），该状态下每次移动时应该对玩家进行移动测试，如果通过测试则移动否则不移动。 5. 在边的Move状态下，应该停止相机对 Player的跟踪 6. 2D 引擎不能如3D一样剔除视锥外的物体，不渲染/不更新窗口外的物体只能通过碰撞来实现 a. 所有进入窗体的对象将恢复更新，退出窗体的对象停止更新 b. 场景对象持有所有场景物体的引用，所以当玩家进入窗口时可以直接调用场景节点的Stop方法，这将停止所有除（player，window，obj_in_window）的对象。 ","link":"https://xuaii.github.io/post/you-xi-ji-zhi-chuang-ti-hu-dong/"},{"title":"状态机的几种写法","content":"在各个Godot初学者教程中，实现第一个人物控制器都是使用的状态机，常见的有以下写法： 写法一 全在 Update 中 using Godot; using System; public class ScriptName : Node { // fields [Export] float Speed； [Export] float JumpHeight; private State state = State.Idle; public enum State : int { Run, Jump, Idle, Fall } public void Update { switch(state) { case State.Idel: // code case State.Run: // code case State.Jump: // code case State.Fall: // code default: // code } } } 优点 ： 至少能实现功能， 缺点： 不利于维护，不方便拓展 写法二 写成状态类和状态机类 public interface IState { void Enter(); void Exit(); void Update(float delta); void PhysicsUpdate(float delta); } public class StateBase&lt;T&gt; : IState { private StateMachine _machine; private T agent; public virtual void Enter() { } public virtual void Exit() { } public virtual void Update(float delta) { } public virtual void PhysicsUpdate(float delta) { } } public class StateMachine : Node { Dictionary&lt;string, IState&gt; StateInfo; IState CurrentState; public void ChangeTo&lt;T&gt;() where T : IState { ... } public override void _Process(float delta){ CurrentState.Update(delta); } public override void _Process(float delta) { CurrentState.PhysicsUpdate(delta); } } class RunState : StateBase&lt;T&gt; { ... } class JumpState : StateBase&lt;T&gt; { ... } class IdleState : StateBase&lt;T&gt; { if(Mathf.Abs(horizontalInput) &gt; 0.01) { _machine.ChangeTo&lt;RunState&gt;(); } if(verticalInput &gt; 0.1) { _machine.ChangeTo&lt;Jump&gt;(); } } 优点:比写法一便于维护 缺点：如果要实现一个 Player 的状态机 和一个Enemy的状态机，他们都有相似的移动逻辑，但是Player状态机多出一些技能相关的状态；如果采用上述写法，ChangeTo()是硬编码在状态内部的，这样就不方便添加边和状态以拓展状态机 写法三 ：基于 GraphEditor的状态机 Godot Asset Store 有很多基于 GraphEdit 的状态机实现，通过： 为状态绑定状态脚本 为转移边绑定脚本或者添加转换条件 减少状态 和 转移边 的耦合。 它们都有一个共同的缺点：不支持 c# 或者c#版本bug多 所以能不能实现一个足够简单的，C#版本的，解耦状态和转化边的状态机呢？ 写法四 状态类 using Godot; using Godot.Collections; namespace StateMachine.Base { public interface IState { string StateName {get;} void Init(Object agent, Dictionary&lt;string, object&gt; blackboard, IStateMachine machine); void OnEnter(); void OnExit(); void Update(float delta); void PhysicsUpdate(float delta); void Exit(); } public class StateBase : Object, IState { // state 只持有 agent 对象不持有状态机对象 protected string _StateName = &quot;&quot;; public string StateName =&gt; _StateName; public Object agent; public IStateMachine machine; private Dictionary&lt;string, object&gt; blackboard; public virtual void Init(Object _agent, Dictionary&lt;string, object&gt; _blackboard, IStateMachine _machine) { agent = _agent; blackboard = _blackboard; machine = _machine; } public virtual void OnEnter() { } public virtual void Update(float delta) { } public virtual void PhysicsUpdate(float delta) { } public virtual void OnExit() { } public virtual void Exit() { machine.Transition(StateName); } } } 状态类内部不能调用StateMachine的ChangeTo()方法，只能实现状态自身的更新逻辑 工具类 IStateMachine 接口，Condition 是用于转换边的方法（返回true就转换，否则就不转换） 满足AssertTo.condition 则转换到AssertTo.nextState Transition的属性用于标志该方法是判断哪个状态转移到哪个状态的 public interface IStateMachine { void Transition(string current); void Start(string name); void Exit(); } public delegate bool Condition(); public class AssertTo : Godot.Object { public Condition condition; public string nextState; public AssertTo(Condition _condition, string _nextState) { condition = _condition; nextState = _nextState; } } [System.AttributeUsage(System.AttributeTargets.Method)] public class Transition : System.Attribute { public string from; public string to; public Transition(string _from, string _to) { from = _from; to = _to; } } 状态机类 状态机类继承自 StateBase，因此状态机是可嵌套的 public class StateMachineBase : StateBase, IStateMachine { public IState CurrentState = null; protected Dictionary&lt;string, Array&lt;AssertTo&gt;&gt; TransitionMap = new Dictionary&lt;string, Array&lt;AssertTo&gt;&gt;(); public Dictionary&lt;string, Godot.Object&gt; Name2State = new Dictionary&lt;string, Godot.Object&gt;(); // 状态机黑板 protected Dictionary&lt;string, object&gt; blackboard; public override void Init(Godot.Object _agent, Dictionary&lt;string, object&gt; _blackboard = null, IStateMachine _machine = null) { base.Init(_agent, _blackboard, _machine); if(blackboard == null) { blackboard = new Dictionary&lt;string, object&gt;(); } if(_machine == null) { } // 初始化状态列表 &amp;&amp; 初始化状态名 foreach(var info in this.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) { if(info.ReflectedType.IsSubclassOf(typeof(StateMachine.Base.StateBase))) { if(Name2State.ContainsKey(info.Name)) { GD.Print(&quot;[FSM runtime] duplicate state &quot;, info.Name); } else { IState state = info.GetValue(this) as IState; if(state == null) { // current state is null before start continue; } Name2State[info.Name] = state as Godot.Object; state.Init(agent, blackboard, this as IStateMachine); (state as Godot.Object).Set(&quot;_StateName&quot;, info.Name); } } } // 初始化转换边列表 foreach(var info in this.GetType().GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) { if(info.GetCustomAttribute&lt;Transition&gt;() is Transition transition) { if(!Name2State.ContainsKey(transition.from) || !Name2State.ContainsKey(transition.to)) { return; } if(!TransitionMap.ContainsKey(transition.from)) { TransitionMap[transition.from] = new Array&lt;AssertTo&gt;(); } TransitionMap[transition.from].Add(new AssertTo((Condition)Delegate.CreateDelegate(typeof(Condition), this, info), transition.to)); } } } #region life cycle public override void OnEnter() { Start(&quot;entry&quot;); } public override void Update(float delta) { if(CurrentState == null) return; CurrentState.Update(delta); } public override void PhysicsUpdate(float delta) { if(CurrentState == null) return; CurrentState.PhysicsUpdate(delta); } public override void Exit() { if(machine == null) { CurrentState = null; } else { base.Exit(); } } // API public void Transition(string current) { if(CurrentState == null) return; if(CurrentState is ExitState) { CurrentState.OnExit(); Exit(); return; } if(!Name2State.ContainsKey(current)) { return; } if(TransitionMap == null) { return; } if(!TransitionMap.ContainsKey(current)) { return; } foreach(AssertTo edge in TransitionMap[current]) { if(edge.condition.Invoke()) { // 添加信号 CurrentState.OnExit(); CurrentState = Name2State[edge.nextState] as IState; CurrentState.OnEnter(); return; } } } public void Start(string name) { if(Name2State.ContainsKey(name)) { CurrentState = Name2State[name] as IState; CurrentState.OnEnter(); } } } Demo // 状态定义 public class Idle : StateBase { public override void OnEnter() { PlayAnimation(&quot;Idle&quot;); } public override void PhysicsUpdate(float delta) { if(InputCache != null) { Exit(); } } } public class Run : StateBase { public override void OnEnter() { PlayAnimation(&quot;Run&quot;); } public override void PhysicsUpdate(float delta) { Position += velocity * delta; } } public class PlayerStateMachine : StateMachineBase { // 绑定状态名和状态类型 EntryState entry = new EntryState(); Run run = new Run(); Idle idle = new Idle(); ExitState exit = new ExitState(); // 定义转换 [Transition(&quot;entry&quot;, &quot;idle&quot;)] public bool transition_1() { return true; } [Transition(&quot;idle&quot;, &quot;run&quot;)] public bool transition_2() { if(horizontalInput != 0) { return true; } return false; } [Transition(&quot;run&quot;, &quot;idle&quot;)] public bool transition_3() { if(agent.IsOnGround() &amp;&amp; velocity == agent.GetGroundVelocity()) { return true; } return false; } } 这样写就把状态 和 状态转移 分离开了，另外还可以实现一些编辑器工具来生成状态机的文件，以及为指定节点绑定状态机以简化操作 Todo: 每个状态机绑定的对象类型不固定，但是状态机继承应该与 agent 对象继承具有相似的层级，所以每写一个新的状态机就强制转换agent类型过于繁琐，尝试找到优化方法！ ","link":"https://xuaii.github.io/post/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"title":"Fourier Transform","content":"1. Dirichlet Conditions 一个周期内, 连续或者有有限个第一类间断点 一个周期内, 有限个极值点 一个周期内可积 2. Trangle Transform 假设 f(t)=c0+∑n=1∞cncos⁡(nωt+φ)=c0+∑n=1∞[cncos⁡φcos⁡(nωt)−cnsin⁡φsin⁡(nωt)]f(t) = c_0+\\sum_{n=1}^{\\infty}c_n\\cos(n \\omega t + \\varphi) =c_0+\\sum_{n=1}^{\\infty}[c_n\\cos\\varphi\\cos(n\\omega t)- c_n\\sin\\varphi \\sin(n\\omega t)] f(t)=c0​+n=1∑∞​cn​cos(nωt+φ)=c0​+n=1∑∞​[cn​cosφcos(nωt)−cn​sinφsin(nωt)] 令 an=cncos⁡φ,bn=−cnsin⁡φa_n = c_n \\cos\\varphi,\\qquad b_n = -c_n\\sin\\varphian​=cn​cosφ,bn​=−cn​sinφ f(t)=c0+∑n=1∞[ancos⁡(nωt)+bnsin⁡(nωt)]∫0Tf(t)sin⁡(kωt)dt=∫0Tc0sin⁡(kωt)dt+∫0Tsin⁡(kωt)∑n=1∞[ancos⁡(nωt)+bnsin⁡(nωt)]dt∫0Tf(t)sin⁡(nωt)dt=0+bnT2bn=2T∫0Tf(t)sin⁡(nωt)dt f(t) = c_0+\\sum_{n=1}^{\\infty}[a_n\\cos(n\\omega t) + b_n \\sin(n\\omega t)]\\\\ \\int_0^T f(t)\\sin(k\\omega t) dt= \\int_0^Tc_0\\sin(k\\omega t) dt + \\int_0^T\\sin(k\\omega t)\\sum_{n=1}^{\\infty}[a_n\\cos(n\\omega t) + b_n \\sin(n\\omega t)] dt\\\\ \\int_0^T f(t)\\sin(n\\omega t) dt= 0 + b_n \\frac{T}{2}\\\\ b_n = \\frac{2}{T} \\int_0^T f(t)\\sin(n\\omega t) dt f(t)=c0​+n=1∑∞​[an​cos(nωt)+bn​sin(nωt)]∫0T​f(t)sin(kωt)dt=∫0T​c0​sin(kωt)dt+∫0T​sin(kωt)n=1∑∞​[an​cos(nωt)+bn​sin(nωt)]dt∫0T​f(t)sin(nωt)dt=0+bn​2T​bn​=T2​∫0T​f(t)sin(nωt)dt 与 2 相似的可以计算得到 cn,an,φ,c0c_n, a_n, \\varphi, c_0cn​,an​,φ,c0​ 3. Fourier 级数 根据欧拉公式: ejx=cos⁡x+jsin⁡xcos⁡(nωt)=ejnωt+e−jnωt2sin⁡(nωt)=ejnωt−e−jnωt2je^{jx} = \\cos x + j\\sin x\\\\ \\cos(n\\omega t) = \\frac{e^{jn\\omega t} + e^{-jn\\omega t}}{2}\\\\ \\sin(n\\omega t) = \\frac{e^{jn\\omega t} - e^{-jn\\omega t}}{2j}\\\\ ejx=cosx+jsinxcos(nωt)=2ejnωt+e−jnωt​sin(nωt)=2jejnωt−e−jnωt​ (8) (9)代入(3) f(t)=c0+∑n=1∞[anejnωt+e−jnωt2+bnejnωt−e−jnωt2j] f(t) = c_0+\\sum_{n=1}^{\\infty}[a_n \\frac{e^{jn\\omega t} + e^{-jn\\omega t}}{2} + b_n \\frac{e^{jn\\omega t} - e^{-jn\\omega t}}{2j}]\\\\ f(t)=c0​+n=1∑∞​[an​2ejnωt+e−jnωt​+bn​2jejnωt−e−jnωt​] 由于 : an=2T∫0Tf(t)cos⁡(−nωt)dt=a−n同理:−bn=b−n a_n = \\frac{2}{T} \\int_0^T f(t)\\cos(-n\\omega t)dt = a_{-n}\\\\ 同理:-b_n = b_{-n} an​=T2​∫0T​f(t)cos(−nωt)dt=a−n​同理:−bn​=b−n​ 整理得到: f(t)=c0+∑n=1∞[an−jbn2ejnωt+ a−n−jb−n2e−jnωt]f(t)=c0+∑n=1∞an−jbn2ejnωt+∑n=−∞−1an−jbn2ejnωt合并得到:f(t)=∑n=−∞∞an−jbn2ejnωt令:An=an−jbn2f(t)=∑n=−∞∞Anejnωt f(t) = c_0 + \\sum_{n=1}^{\\infty}[\\frac{a_n-jb_n}{2}e^{jn\\omega t} + \\ \\frac{a_{-n} - jb_{-n}}{2}e^{-jn\\omega t}]\\\\ f(t) = c_0 + \\sum_{n=1}^{\\infty}\\frac{a_n-jb_n}{2}e^{jn\\omega t} + \\sum_{n = -\\infty}^{-1} \\frac{a_n - jb_n}{2}e^{jn\\omega t}\\\\ 合并得到:\\\\ \\qquad\\qquad f(t) = \\sum_{n=-\\infty}^{\\infty}\\frac{a_n - jb_n}{2}e^{jn\\omega t}\\\\ 令:\\\\ \\qquad\\qquad A_n = \\frac{a_n - jb_n}{2}\\\\ f(t) = \\sum_{n=-\\infty}^{\\infty}A_ne^{jn\\omega t}\\\\ f(t)=c0​+n=1∑∞​[2an​−jbn​​ejnωt+ 2a−n​−jb−n​​e−jnωt]f(t)=c0​+n=1∑∞​2an​−jbn​​ejnωt+n=−∞∑−1​2an​−jbn​​ejnωt合并得到:f(t)=n=−∞∑∞​2an​−jbn​​ejnωt令:An​=2an​−jbn​​f(t)=n=−∞∑∞​An​ejnωt 在 4. 中得到 Fourier 级数, 再两边同时 乘以 e−jkωte^{-jk\\omega t}e−jkωt 并在一个周期内积分得到: ∫0Tf(t)e−jnωtdt=∫0T∑n=−∞+∞Anej(n−k)ωtdt∫0Tf(t)e−jnωtdt=AnTAn=1T∫0Tf(t)e−jnωtdt \\int_{0}^{T}f(t)e^{-jn\\omega t}dt = \\int_{0}^{T}\\sum^{+\\infty}_{n = -\\infty}A_ne^{j(n-k)\\omega t}dt\\\\ \\int_0^Tf(t)e^{-jn\\omega t}dt = A_nT\\\\ A_n = \\frac{1}{T}\\int_0^Tf(t)e^{-jn\\omega t}dt ∫0T​f(t)e−jnωtdt=∫0T​n=−∞∑+∞​An​ej(n−k)ωtdt∫0T​f(t)e−jnωtdt=An​TAn​=T1​∫0T​f(t)e−jnωtdt 4. Fourier Transform 1 An=1T∫0Tf(t)e−jnωtdtF(ω)=lim⁡T→∞AnT=∫0∞f(t)e−jnωtdt(FourierTransform+)lim⁡T→∞An=lim⁡T→∞F(ω)T=lim⁡T→∞F(ω)⋅ω2π A_n = \\frac{1}{T}\\int_0^Tf(t)e^{-jn\\omega t}dt\\\\ F(\\omega) = \\lim_{T\\rightarrow \\infty}A_nT = \\int_0^\\infty f(t)e^{-jn\\omega t}dt\\qquad (Fourier Transform + )\\\\ \\lim_{T\\rightarrow \\infty}A_n = \\lim_{T\\rightarrow \\infty}\\frac{F(\\omega)}{T} = \\lim_{T\\rightarrow \\infty}\\frac{F(\\omega)\\cdot \\omega}{2\\pi}\\\\ An​=T1​∫0T​f(t)e−jnωtdtF(ω)=T→∞lim​An​T=∫0∞​f(t)e−jnωtdt(FourierTransform+)T→∞lim​An​=T→∞lim​TF(ω)​=T→∞lim​2πF(ω)⋅ω​ 结合 (19)(25) 得到 f(t)=lim⁡T→∞∑n=−∞∞Anejnωt=lim⁡T→∞∑n=−∞∞F(ω)⋅ejnωt2πdω=12π∫−∞∞F(ω)⋅ejnωtdω(FourierTransform−) f(t) = \\lim_{T\\rightarrow \\infty}\\sum^\\infty_{n=-\\infty}A_n e^{jn\\omega t} =\\lim_{T\\rightarrow \\infty}\\sum^\\infty_{n=-\\infty}\\frac{F(\\omega)\\cdot e^{jn\\omega t}}{2\\pi} d\\omega =\\frac{1}{2\\pi}\\int^\\infty_{-\\infty}F(\\omega)\\cdot e^{jn\\omega t}d\\omega \\qquad (Fourier Transform -)\\\\ f(t)=T→∞lim​n=−∞∑∞​An​ejnωt=T→∞lim​n=−∞∑∞​2πF(ω)⋅ejnωt​dω=2π1​∫−∞∞​F(ω)⋅ejnωtdω(FourierTransform−) 5. Convolution Theorem 定理描述设:f1(t)的Fourier变换为F1(ω),f2(t)的Fourier变换为F2(ω),那么:时域:F[f1(t)⊗f2(t)]=F1(ω)⋅F2(ω)频域:F[f1(t)⋅f2(t)]=12πF1(ω)⊗F2(ω)设:f_1(t) 的Fourier变换为F_1(\\omega), f_2(t) 的Fourier变换为F_2(\\omega), \\\\ 那么:\\\\ 时域:\\\\ \\qquad\\qquad F[f_1(t)\\otimes f_2(t)] = F_1(\\omega)\\cdot F_2(\\omega)\\\\ 频域:\\\\ \\qquad\\qquad F[f_1(t)\\cdot f_2(t)] = \\frac{1}{2\\pi}F_1(\\omega)\\otimes F_2(\\omega)\\\\ 设:f1​(t)的Fourier变换为F1​(ω),f2​(t)的Fourier变换为F2​(ω),那么:时域:F[f1​(t)⊗f2​(t)]=F1​(ω)⋅F2​(ω)频域:F[f1​(t)⋅f2​(t)]=2π1​F1​(ω)⊗F2​(ω) 6. Fourier 时移性质 F[f(t)]=F(ω)则:F[f(t−τ)]=F(ω)e−jnωτF[f(t)] = F(\\omega) \\qquad则: F[f(t - \\tau)] = F(\\omega)e^{-jn\\omega \\tau} F[f(t)]=F(ω)则:F[f(t−τ)]=F(ω)e−jnωτ 证明: F[f(t−τ)]=∫−∞+∞f(t−τ)e−jnωtdtF[f(t - \\tau)] = \\int^{+\\infty}_{-\\infty}f(t-\\tau)e^{-jn\\omega t}dt\\\\ F[f(t−τ)]=∫−∞+∞​f(t−τ)e−jnωtdt 令 x=t−τ:x= t - \\tau:x=t−τ: F[f(t−τ)]=∫−∞+∞f(x)e−jnω(x+τ)dx=ejnωτ∫−∞+∞f(x)e−jnωxdx=F(ω)⋅ejnωτ F[f(t - \\tau)] = \\int^{+\\infty}_{-\\infty}f(x)e^{-jn\\omega (x+\\tau)}dx =e^{jn\\omega\\tau}\\int^{+\\infty}_{-\\infty}f(x)e^{-jn\\omega x}dx = F(\\omega)\\cdot e^{jn\\omega\\tau} F[f(t−τ)]=∫−∞+∞​f(x)e−jnω(x+τ)dx=ejnωτ∫−∞+∞​f(x)e−jnωxdx=F(ω)⋅ejnωτ 7. Convolution Theorem 证明 定义卷积运算 f1(t)⊗f1(t)=∫−∞+∞f1(τ)f2(t−τ)dτf_1(t)\\otimes f_1(t) = \\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t - \\tau)d\\tau\\\\ f1​(t)⊗f1​(t)=∫−∞+∞​f1​(τ)f2​(t−τ)dτ 将 (35) 带入(24) F[f1(t)⊗f1(t)]=∫−∞+∞[∫−∞+∞f1(τ)f2(t−τ)dτ]e−jnωtdt=∫−∞+∞f1(τ)[∫−∞+∞f2(t−τ)e−jnωtdt]dτ(调换积分顺序)=∫−∞+∞f1(τ)F2(ω)e−jnωτdτ=F2(ω)⋅F1(ω) F[f_1(t)\\otimes f_1(t)] = \\int_{-\\infty}^{+\\infty}[\\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t - \\tau)d\\tau]e^{-jn\\omega t}dt\\\\ = \\int_{-\\infty}^{+\\infty}f_1(\\tau)[\\int_{-\\infty}^{+\\infty}f_2(t - \\tau)e^{-jn\\omega t}dt]d\\tau \\qquad(调换积分顺序)\\\\ = \\int_{-\\infty}^{+\\infty}f_1(\\tau)F_2(\\omega)e^{-jn\\omega \\tau}d\\tau\\\\ = F_2(\\omega)\\cdot F_1(\\omega)\\\\ F[f1​(t)⊗f1​(t)]=∫−∞+∞​[∫−∞+∞​f1​(τ)f2​(t−τ)dτ]e−jnωtdt=∫−∞+∞​f1​(τ)[∫−∞+∞​f2​(t−τ)e−jnωtdt]dτ(调换积分顺序)=∫−∞+∞​f1​(τ)F2​(ω)e−jnωτdτ=F2​(ω)⋅F1​(ω) ","link":"https://xuaii.github.io/post/fourier-transform/"}]}