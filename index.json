[{"categories":null,"content":"wiki 塞尔达传说 wiki 电子游戏简史 塞尔达传说 旷野之息 地图 灰机wiki 宝可梦百科全书 马里奥 cheats wiki 各个游戏的结构体 hacking 百科全书 ","date":"2023-04-30","objectID":"/focus/:1:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"博客 john-wigg godot 特效 unity 跳跃优化 第一个关卡设计 shaggy dev 关于图形学的一切 unity shader 教程 写给程序员的美术指南 LightJiao riteme oi-wiki 什么算法都有 渲染\u0026\u0026游戏 ","date":"2023-04-30","objectID":"/focus/:2:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"工具 关卡设计 可视化函数工具 可视化函数 测试shader的网站 渲染器 openmoonray 几何画板 数值策划 一个用于学术目的的渲染器？ hugo 主题 loveit ubuntu pastebin git 文档 git 动画教程 github 加速下载 接码平台 金克拉 飞机场 UI设计网站 游戏外覆盖 ","date":"2023-04-30","objectID":"/focus/:3:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"资源 Unity 学习资源 godot shader 游戏资源 godot 教程 godot 教程 godot 教程 图形学必读书单 the book of shader GAMES104 自动tile 忧郁的弟弟 ","date":"2023-04-30","objectID":"/focus/:4:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"文档 godot doc 游戏设计模式 ","date":"2023-04-30","objectID":"/focus/:5:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"论坛 game dev godot community general GAMES 图形学 godot 中文社区 ","date":"2023-04-30","objectID":"/focus/:6:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"插件 \u0026 demo Unity-2D-Platformer-Controller 2d-flexible-platformer-controller-67414 corgi engine gameFramework godot 贴花插件 Godot-Mono-CustomResourceRegistry godot sky shader ","date":"2023-04-30","objectID":"/focus/:7:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"着色器 深度水 屏幕空间草？ shadertoy godot 2d 光线 shdertoy 体素边缘 ","date":"2023-04-30","objectID":"/focus/:8:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"平台网站 godot 游戏 盗版游戏 游戏资讯 盗版\u0026破解游戏 游侠 ","date":"2023-04-30","objectID":"/focus/:9:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"美术素材 3D模型 cgtrader 3D 模型 turbosquid 2D马里奥tile 2D马里奥 马里奥资源 ","date":"2023-04-30","objectID":"/focus/:10:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"软件 switch 破解 ","date":"2023-04-30","objectID":"/focus/:11:0","tags":null,"title":"Focus","uri":"/focus/"},{"categories":null,"content":"常用命令速查 git-cheat-sheet ","date":"2023-04-30","objectID":"/git-note/:0:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"基础 git status 查看信息 git diff 查看差异 git log 查看commit 历史，由近到远 提交的版本号是一个哈希值 使用 –pretty-oneline 将一个commit打印到一行 ","date":"2023-04-30","objectID":"/git-note/:1:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"版本库 \u0026 工作区 git reset –hard HEAD^ 是回退到上一个版本， 在reset回退版本时，版本链会断掉，使用 git log 看不到之前的提交记录了， 可以找窗口之前的记录，得到某个commit的Id 并且使用 git reset –hard 1094a 回退， 这里的1094a 是id的前几位！！ 如果窗口被关闭了还可以使用 git reflog查看每一次命令， 所以在 git中有一个很重要的是一定要为 commit 添加注释！！ HEAD 指针指向当前版本！ Git会追踪被add过的文件的所有改变，没有被add的文件只会被标记为untrack git diff HEAD – readme.txt可以查看变动！这里的变动是 commit 与 工作区 的差异！ git checkout – file 重新检出，丢弃工作区的修改 checkout 要么回到暂存区，要么回到版本库，总之回到最近的修改 这里的–指定文件！如果不加就是切换分支的命令！！ git reset HEAD 可以撤销掉暂存区的修改 删除文件 git rm git commit 如果是误删，就git checkout – file 来撤销工作区的修改 checkout 的本质是用版本库替换工作区！ ","date":"2023-04-30","objectID":"/git-note/:2:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"远程仓库 git remote add origin 地址 的含义是将当前仓库和远程仓库建立连接，其中 origin是远程仓库名字？？？ 第一次推送代码时，使用 git push -u origin master， origin是指定了远程仓库名字 这里的 master 是本地的master分支！！-u 初次使用时添加，意思是将他们关联起来！ git ls-files [–cached –delete –modified –other –stage] git push [-f 强制推送，可能覆盖] git push -u origin [branch] 创建新分支时使用，这会创建一个与本地分支 branch 对应的上游分支 git push -all 这会 push 所有分支 git push –tag 发布尚未在远程仓库中的标签（不懂是什么意思 git branch (-m | -M) [] 重命名分支，reflog 会做相应的重命名，并且创建条目记录该行为 git remote add origin 添加远程仓库 git remote -v 查看远程仓库信息 git remote rm origin 删除远程仓库 ","date":"2023-04-30","objectID":"/git-note/:3:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"远程仓库 git clone git@github.com:xxx cd xxx git 支持多种协议但是 ssh 协议是最快的， https 协议是慢的 git 的分支切换功能非常快，其他的项目管理软件非常慢 （1s内） git 中的无数 commit 组成一条时间线，一般项目的分支叫做 master， HEAD 用于指向当前分支，而当前分支会指向指向 commit 链表 ","date":"2023-04-30","objectID":"/git-note/:4:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"分支 git branch -b dev 创建并切换分支（等价于以下两个命令） git branch dev 创建分支 git checkout dev 切换分支 git branch 查看分支 git 版本管理结构 git 所管理的本质就是一个个用链表串联起来的 commit 通过分支指向链表的某个末端 再用 HEAD 指向当前分支 git merge 将指定分支合并到当前分支（这里没有说怎么处理冲突！快进模式是非常快的，通常某个分支没有发生改变，就改改指针） git branch -d 删除分支，合并完成后删除 使用 checkout 来切换分支和撤销修改，不太科学，实际上切换分支应该用 switch git switch -c dev 创建并切换到新分支 git switch master 切换到 master 分支 ","date":"2023-04-30","objectID":"/git-note/:5:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"解决冲突 当两个分支不在一个单链表上时（而是出现了分叉，像树枝一样），此时合并分支不再时快速模式，而是有可能出现冲突。 git merge feature 或报错，提示分支冲突 可以使用 git status 查看哪些文件冲突了！ 直接查看冲突文件，会出现 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD xxxxxxxxxx ======== yyyyyyyyyy \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e feature 解决冲突后再 add commit 再 merge 即可！ git log –graph –pretty=oneline –abbrev-comit 可以查看分支合并情况！ ","date":"2023-04-30","objectID":"/git-note/:6:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"分支管理策略 合并时如果能用 FastForward 就会直接用，但是删除分支后会丢失信息 强制禁用 FastForward 模式 git 在 merge 时就会生成一个新的 commit 就可以从历史上看书分支信息 这种强制的方法: git merge –no-ff ","date":"2023-04-30","objectID":"/git-note/:7:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"分支管理的基本原则 保证 master 分支的稳定性（仅用于发布版本，不在上边干活） dev 分支是不稳定的，在 dev 上干活 ","date":"2023-04-30","objectID":"/git-note/:8:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"stash 紧急 bug 修复 情景：当我正在 dv 上开发功能，开发到一半不能提交，但是此时收到一个紧急bug 解决: 将当前的工作暂存，创建一个新的分支用于解决 bug，当处理完bug恢复之前未完成的工作区代码 git stash git stash apply git stash pop 使用 git cherry-pick 处理 bug 时可以拷贝分支 ","date":"2023-04-30","objectID":"/git-note/:9:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"多人协作模式 多人协作的工作模式通常是这样： 首先，git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建， 用命令git branch –set-upstream-to origin/。 ","date":"2023-04-30","objectID":"/git-note/:10:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"rebase 变基 主要功能是整理分支，通常如果push有冲突的话我们会先pull这时会在本地产生一个分支，并合并。 再推送到远程 分支树就会很乱，所以应该在本地git rebase将本地修改移动到最近一次pull的版本后，这样分支就只有一个了！再提交就变得很优雅！ ","date":"2023-04-30","objectID":"/git-note/:11:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"tag tag就是一个指向版本的指针，本来用id可以访问版本的，但是id不好看，所以可以用tag 使用方法 git tag v1.0 就在当前指向的commit打上标签了！ git tag 可以查看所有标签 git tag 给历史提交打标签 标签是字母顺序而不是时间顺序 git show 可以查看标签信息 创建标签时 可以用 -a 指定标签名 -m 添加说明 git tag -d 删除本地标签， git push origin 将标签推送到远程 git push origin –tags 推送所有标签 删除远程标签 删除本地标签 -d git push origin :refs/tags/ 删标签只记住这种方法就好了，其他方法存在误删分支的风险！ 冒号的原理是将 冒号前的推送到冒号后的， 这里冒号前是空的，就是将空的东西推送到远程分支！！！ ","date":"2023-04-30","objectID":"/git-note/:12:0","tags":null,"title":"[学习记录] git 分布式版本管理系统","uri":"/git-note/"},{"categories":null,"content":"今天看小宁子介绍 ‘拓麻歌子’ 宠物蛋时想到了一个游戏机的玩法！大致思路是，在房间中心扫描某一面墙，获取深度信息，将墙上突出来的部分当作 平台，利用投影仪技术将 角色/影子 投影到墙上。在 2D 的墙面上进行 战斗和跳跃。玩家可以自行在墙上添加物体！ 一个深度摄像头 一个激光投影仪 难点是深度摄像头和激光投影仪的对齐问题， 还有成本问题！ 好想要做一个这样的东西，一定非常有趣！！ 这就像小时候玩过的手影，还会和小伙伴用手影战斗！！！非常有意思。 深度摄像头其实已经很便宜了，不管是 iphone 还是kinect 都可以，主要是激光投影仪太贵了，而且不是家中常有的东西。并且一般的投影仪并不能在图像透明通道不发光，如果是全发光的话效果并不好。 等到深度传感器技术和激光投影技术成本更低廉的时候再来实现这个想法！！ 可以考虑 便携式迷你投影仪 AAXA P2-B - 130 Lumen Mini Projector (这个非常适合s) Kodak 柯达超小型便携式投影仪 对于深度摄像机也完全没有必要这么严格，只需要普通相机，对画面进行边缘检测即可！ 暂时不用投影仪来做，可以先实现一个简单功能，就是 在白纸上画一些平台和障碍物，或者贴纸。用相机拍下来，然后游戏自动生成这个场景，然后就能玩了！ ","date":"2023-04-29","objectID":"/game_play_idea_20230429/:0:0","tags":null,"title":"[玩具 Idea] 影子格斗","uri":"/game_play_idea_20230429/"},{"categories":null,"content":"什么是热更新技术? 游戏上线后可能会定期的更新资源(美术资源+代码)，需要一种可靠的方案来更新代码。 对于 C# 来说就是将代码编译为 .dll 文件，放入 AssetBundle 热更包里边，在客户端动态的的加载，当然这会带来一系列的限制。 下面记录一下 Unity 和 Godot 中的热更新方案。 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:1:0","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"Unity + ILRuntime 转载自 10274176.html 10458333.html ILRuntime 相当于在客户端运行了一个能动态加载C# 字节码 DLL 的程序。 ILRuntime 项目和 Unity C# 项目运行在两个不同的域中，他们可以通过以下方式交互 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:0","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"1. 根据字符串找到方法 appdomain.Invoke(\"HotFix_Project.InstanceClass\", \"StaticFunTest\", null, null); 或者 //预先获得IMethod，可以减低每次调用查找方法耗用的时间 IType type = appdomain.LoadedTypes[\"HotFix_Project.InstanceClass\"]; //根据方法名称和参数个数获取方法 IMethod method = type.GetMethod(\"StaticFunTest\", 0); appdomain.Invoke(method, null, null); 也可以在主工程中抛出事件，在热更工程中监听，原理和Invoke是一样的 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:1","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"2. 监听主工程的委托 在热更工程中监听主工程的事件，由主工程触发。 如果非Action或Func，则需要在主工程中写适配器，所以建议使用系统自带的Action和Func。 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:2","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"3. 继承主工程，实现主工程接口 Demo中有三个适配器示例，都继承自CrossBindingAdaptor，适配器中有内部类，继承或实现接口的方法。 public class MonoBehaviourAdapter : CrossBindingAdaptor { public override Type BaseCLRType {get { return typeof(MonoBehaviour); } } public override Type AdaptorType {get { return typeof(Adaptor); } } public override object CreateCLRInstance(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance) { return new Adaptor(appdomain, instance); } //为了完整实现MonoBehaviour的所有特性，这个Adapter还得扩展，这里只抛砖引玉，只实现了最常用的Awake, Start和Update public class Adaptor : MonoBehaviour, CrossBindingAdaptorType { ILTypeInstance instance; ILRuntime.Runtime.Enviorment.AppDomain appdomain; public Adaptor() { } public Adaptor(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance) { this.appdomain = appdomain; this.instance = instance; } public ILTypeInstance ILInstance { get { return instance; } set { instance = value; } } public ILRuntime.Runtime.Enviorment.AppDomain AppDomain { get { return appdomain; } set { appdomain = value; } } public void Awake() {} void Start(){} void Update(){ } public override string ToString(){ } } } 这里我不明白为什么这样写了之后就能继承了？ ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:3","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"4. CLR重定向/热补丁 CLRRedirectionDemo，需要在AppDomain中注册 RegisterCLRMethodRedirection 在热更工程中调用主工程的代码时会重定向新的实现，新手可以从修改CLR生成的绑定代码开始。 例子是修改Debug.Log方法，在热更中打印的日志也能显示堆栈信息。 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:4","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"5. 生成CLR绑定代码 类似于slua/tolua/xlua一样， 把在热更工程会用到主工程的类添加到列表中，然后生成绑定代码。 ILRuntime提供一个智能分析在热更工程会访问主工程的代码并生成CLR绑定代码。 在CLRBindingDemo示例中生成CLR绑定代码之后性能提升10倍 在生成绑定代码之后，热更中访问主工程中方法是调用的 xxx_Binding.cs，而如果不生成则是通过反射调用。 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:5","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"6. 在热更工程使用协程 官方例子是调用主工程的方法来启动协程，我测试热更工程也可以调用MonoBehaviour的方法开启协程。 热更工程代码如下： public static void RunTest() { Debug.Log(\"热更工程中开启协程\"); CoroutineDemo.Instance.StartCoroutine(Coroutine()); } static System.Collections.IEnumerator Coroutine() { Debug.Log(\"开始协程,t=\" + Time.time); yield return new WaitForSeconds(3); Debug.Log(\"等待了3秒,t=\" + Time.time); } ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:6","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"7. 对主工程的值类型做绑定 那些需要做绑定？Unity的常用值类型，比如：Vector3，Vector2 这项操作会提升性能，减少额外的CPU开销和GC Alloc。 方法： AppDomain.RegisterValueTypeBinder(typeof(Vector3), new Vector3Binder()); Demo 做了十万次向量的运算，添加值类型绑定，不绑定的耗时如下： Value: a=(100001.0, 100002.0, 100003.0),dot=0, time = 750ms Value: a=(100001.0, 100002.0, 100003.0),dot=0, time = 1911ms Value: a=(-0.4, -0.8, -1.7, -5.1),dot=-124.7494, time = 604ms Value: a=(-0.4, -0.8, -1.7, -5.1),dot=-124.7494, time = 1550ms Value: a=(100001.0, 100002.0),dot=0, time = 710ms Value: a=(100001.0, 100002.0),dot=0, time = 1902ms ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:7","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"热更工程主要用例 根据我们以往的项目使用Lua做为热更脚本为例，我们在热更工程做的最多的事情： 在热更工程中调用主工程的方法，或监听主工程的事件，监听Unity组件触发的事件。 热更工程调用主工程接口加载资源 热更工程处理UI代码逻辑 读取配置，对配置解析 热更工程中处理网络的回调 热更工程基本处理所有的业务逻辑 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:8","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"为什么要写适配器 因为ILRuntime可以理解为蓝大写的C#虚拟机，这个虚拟机要在运行时和Unity的脚本进行交互。 由于IOS的AOT限制，在运行时ILRuntime中是不知道Unity中的类型，所以需要我们在主工程写适配器让ILRuntime知道如何调用在Unity的代码，或当Unity的事件触发时让ILRuntime能够监听到。 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:9","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"ILRuntime 的委托 ILRuntime 内部使用委托，或者 ILRuntime 使用主工程委托都是 OK 的， 但是需要将委托实例传到 Hotfix 域的外部使用，就需要编写委托适配器（按照官网的 demo 写，Ation、Func 外的委托需要额外实现一个转换器） ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:10","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"ILRuntime 继承主工程的类接口 适配器类是需要在主工程中实现的，这个适配器的本质就是在调用 Hotfix 域中的方法。 观察 ILRuntime 的 Demo 可以发现实际上就是在 Adaptor中 执行以下逻辑 static CrossBindingMethodInfo mVMethod1_0 = new CrossBindingMethodInfo(\"VMethod1\"); public override void VMethod1() { if (mVMethod1_0.CheckShouldInvokeBase(this.instance)) base.VMethod1(); else mVMethod1_0.Invoke(this.instance); } 实际上就是预留了一个绑定的 位置！ 最后记得注册适配器 appdomain.RegisterCrossBindingAdaptor(new ClassInheritanceAdaptor()); 那么在 Hotfix 工程中如何继承该类呢？ 参考链接 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:11","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"反射 参考官方文档 总的来说，Hotfix 访问主工程是容易的，而主工程访问Hotfix 工程是困难的！ ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:12","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"CLR 重定向 这也在官方文档中写得很清楚了，主要就是编写 CLR重定向方法并且注册方法（将这个方法映射到一个CLR方法） ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:13","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"CLR 绑定 热更代码中访问主工程代码是通过反射调用实现的，这样会不可避免的带来性能开销和 GC，对于经常调用的接口进行绑定可以消除反射带来的 GC Alloc CLR 绑定生成的是借助 CLR 重定向实现的，但是手动实现需要精细的控制，所以 ILRuntime 提供了自动生成方法，我看不懂这个地方放 的代码，以后需要使用的时候再学吧！！ 文档 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:2:14","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"Unity + Huatuo ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:3:0","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"原理 C#运行时结构 ![v2-f9db604624b4bfbaf111a9d95e040b97_720w](vx_images/338792822230449.webp =500x) 最后一个概念AOT(Ahead of time)，AOT技术指的是将高级开发语言直接转成传统的编译型编程语言(如C/C++),再编译成机器指令代码在硬件上运行。IL2CPP可以成为AOT技术。 Unity 打包运行时为：AOT + IL2CPP VM(提供基础服务，如GC)，对于底层运行时而言，是数据运行对象 + 代码机器指令两部分，huatuo 热更新就是扩展了 IL2CPP VM 服务，在使用 原来数据对象的情况下， 扩展了解释执行 IL 代码的功能，让 IL2CPP 的运行模式变为了 内存对象 + AOT机器代码指令 + IL指令解释执行 三个部分，huatuo 热更新时只需要利用 Unity ADF(asmdef, 程序集定义机制)让Unity对某一部分代码单独编译出一个 IL 指令的 DLL 文件。 热更新时 IL2CPP_huatuo就可以加载 IL 指令， 由 IL2CPP_huatuo 来解释执行。并且huatuo 解释执行时使用了原来的 AOT 数据内存对象，所以 huatuo 方案不需要其他热更方案的接口导出，跨域调用等一些列问题 开发者不需要任何特殊处理，内存占用，性能都会更好。 huatuo的革命性优势 huatuo第1个优势是基于AOT(本地机器代码执行)+Interpreter (IL解释执行)使用同一个内存数据对象，没有跨域访问的问题 我们来拿xLua或ILRuntime热更方案来举例，这些方案都有一条原则，尽量减少与Unity C#层的交互，但是这种交互又避免不了而且量大，比如我们要在逻辑热更代码里面访问 Unity C#的GameObject对象数据，最终在运行的时候，GameObject 会在AOT模式下的原生内存数据结构对象。 由于xLua或ILRuntime有自己的虚拟机，所以不能直接访问原生GameObject数据对象，往往要把访问里面的数据包装成函数，这样性能开销就大大的增加了。而huatuo是在IL2CPP模式下的解释执行，直接可以访问原生的数据对象。 相比传统的Lua或ILRuntime热更,他能更新任意部分的代码。不用像Lua或ILRuntime一样，分热更代码+框架代码，框架代码有bug还不能热更。 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:3:1","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"优缺点 优点 热更和非热更开发体验一致 原生支持 95% 以上的代码热更需求，包括不限于 await/aysnc, 跨域继承， 跨域调用 第三方插件接入不需要框架层适配！华佗是在 IL2CPP 完成了热更功能！ 额外内存开销比较小 特性完整（继承，反射，多线程，volatile，ThreadStatic，Task，async），没有代码生成，没有特殊代码，没有特殊限制 缺点 基于 IL2CPP 的底层实现导致无法真机 C# Debug AOT 泛型导致的一些限制（完善中） 在 HybridCLR中应该已经完善了泛型问题，主要使用两个机制 泛型共享 + 补充元数据 无法真机的 C# Debug，但是可以断点跟踪 huatuo 指令集执行过程，在editor 可以直接使用 mono 的调试方式 平台支持 PC（稳定） Android（跑通几个了） IOS （比较少的APP跑通了） ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:3:2","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"实践 bilibili ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:3:3","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"Godot 热更新 godot 打包时可以选择需要的 DLC 资源得到 PCK 也可以直接打包为 EXE （静态的一些资源 然后将 PCK 放到服务器设置好目录 最后在 Godot 端实现 PCK 的下载和加载 ","date":"2023-04-08","objectID":"/unity_godot_hot_update/:4:0","tags":null,"title":"游戏引擎热更新技术","uri":"/unity_godot_hot_update/"},{"categories":null,"content":"GC的前世与今生 虽然本文是以 .Net 作为目标来讲述 GC，但是 GC 的概念并非才诞生不久。早在1958年，由鼎鼎大名的图林奖得主 John McCarthy 所实现的 Lisp 语言就已经提供了 GC 的功能，这是 GC 的第一次出现。Lisp的程序员认为内存管理太重要了，所以不能由程序员自己来管理。但后来的日子里Lisp却没有成气候，采用内存手动管理的语言占据了上风，以 C 为代表。出于同样的理由，不同的人却又不同的看法，C 程序员认为内存管理太重要了，所以不能由系统来管理，并且讥笑 Lisp 程序慢如乌龟的运行速度。的确，在那个对每一个 Byte 都要精心计算的年代 GC 的速度和对系统资源的大量占用使很多人的无法接受。而后，1984年由 Dave Ungar 开发的 Small talk 语言第一次采用了 Generational garbage collection的技术（这个技术在下文中会谈到），但是 Small talk 也没有得到十分广泛的应用。 直到20世纪90年代中期 GC 才以主角的身份登上了历史的舞台，这不得不归功于 Java 的进步，今日的 GC 已非吴下阿蒙。Java采用VM（Virtual Machine）机制，由VM来管理程序的运行当然也包括对 GC 管理。90年代末期 .net 出现了，.net采用了和 Java 类似的方法由 CLR(Common Language Runtime) 来管理。这两大阵营的出现将人们引入了以虚拟平台为基础的开发时代，GC 也在这个时候越来越得到大众的关注。 为什么要使用GC呢？也可以说是为什么要使用内存自动管理？有下面的几个原因： 1、提高了软件开发的抽象度； 2、程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题； 3、可以使模块的接口更加的清晰，减小模块间的偶合； 4、大大减少了内存人为管理不当所带来的Bug； 5、使内存管理更加高效。 总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。 ","date":"2023-03-24","objectID":"/csharp-gc/:1:0","tags":null,"title":"[转载]C#垃圾回收机制(GC)","uri":"/csharp-gc/"},{"categories":null,"content":"什么是GC GC如其名，就是垃圾收集，当然这里仅就内存而言。Garbage Collector（垃圾收集器，在不至于混淆的情况下也成为GC）以应用程序的root为基础，遍历应用程序在Heap上动态分配的所有对象[2]，通过识别它们是否被引用来确定哪些对象是已经死亡的哪些仍需要被使用。已经不再被应用程序的root或者别的对象所引用的对象就是已经死亡的对象，即所谓的垃圾，需要被回收。这就是GC工作的原理。为了实现这个原理，GC有多种算法。比较常见的算法有Reference Counting，Mark Sweep，Copy Collection等等。目前主流的虚拟系统.net CLR，Java VM和Rotor都是采用的Mark Sweep算法。 ","date":"2023-03-24","objectID":"/csharp-gc/:2:0","tags":null,"title":"[转载]C#垃圾回收机制(GC)","uri":"/csharp-gc/"},{"categories":null,"content":"Mark-Compact 标记压缩算法 简单把.NET的GC算法看作Mark-Compact算法 阶段1: Mark-Sweep 标记清除阶段, 先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的 阶段2: Compact 压缩阶段, 对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理 ![](https://images.cnblogs.com/cnblogs_com/riccc/dotnet/net-mem-02-mark-compact.png =500x) Heap内存经过回收、压缩之后，可以继续采用前面的heap内存分配方法，即仅用一个指针记录heap分配的起始地址就可以 主要处理步骤： 将线程挂起 确定roots 创建reachable objectsgraph 对象回收 heap压缩 指针修复 可以这样理解roots：heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph，roots是CLR在heap之外可以找到的各种入口点。GC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针（还有finalizationqueue）等。 主要可以归为2种类型：已经初始化了的静态变量、线程仍在使用的对象（stack+CPU register） Reachable objects：指根据对象引用关系，从roots出发可以到达的对象。例如当前执行函数的局部变量对象A是一个rootobject，他的成员变量引用了对象B，则B是一个reachable object。从roots出发可以创建reachable objectsgraph，剩余对象即为unreachable，可以被回收 ![](https://images.cnblogs.com/cnblogs_com/riccc/dotnet/net-mem-05-reachable-graph.png =500x) 指针修复 : 因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPUregister中的指针以及heap中其他对象的引用指针 Debug和release执行模式之间稍有区别，release模式下后续代码没有引用的对象是unreachable的，而debug模式下需要等到当前函数执行完毕，这些对象才会成为unreachable，目的是为了调试时跟踪局部对象的内容, 传给了COM+的托管对象也会成为root，并且具有一个引用计数器以兼容COM+的内存管理机制，引用计数器为0时这些对象才可能成为被回收对象 Pinnedobjects：指分配之后不能移动位置的对象，例如传递给非托管代码的对象（或者使用了fixed关键字），GC在指针修复时无法修改非托管代码中的引用指针，因此将这些对象移动将发生异常。pinnedobjects会导致heap出现碎片，但大部分情况来说传给非托管代码的对象应当在GC时能够被回收掉 ","date":"2023-03-24","objectID":"/csharp-gc/:3:0","tags":null,"title":"[转载]C#垃圾回收机制(GC)","uri":"/csharp-gc/"},{"categories":null,"content":"Generational 分代算法 程序可能使用几百M、几G的内存，对这样的内存区域进行GC操作成本很高，分代算法具备一定统计学基础，对GC的性能改善效果比较明显。将对象按照生命周期分成新的、老的，根据统计分布规律所反映的结果，可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度，争取在较短时间间隔、较小的内存区域内，以较低成本将执行路径上大量新近抛弃不再使用的局部对象及时回收掉 分代算法的假设前提条件： 大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长 对部分内存进行回收比基于全部内存的回收操作要快 新创建的对象之间关联程度通常较强。heap分配的对象是连续的，关联度较强有利于提高CPU cache的命中率 .NET将heap分成3个代龄区域: Gen 0、Gen 1、Gen 2 Heap分为3个代龄区域，相应的GC有3种方式: Gen 0 collections ： Gen 0 heap内存达到阀值，则触发0代GC， 0代GC后Gen 0中幸存的对象进入Gen1。 Gen 1 collections ： Gen 1的内存达到阀值，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。 Gen 2 collections： 2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收 ![](https://images.cnblogs.com/cnblogs_com/riccc/dotnet/net-mem-06-generation.png =500x) Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为fullGC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时fullGC可能需要花费几秒时间。大致上来讲.NET应用运行期间2代、1代和0代GC的频率应当大致为1:10:100。 ","date":"2023-03-24","objectID":"/csharp-gc/:4:0","tags":null,"title":"[转载]C#垃圾回收机制(GC)","uri":"/csharp-gc/"},{"categories":null,"content":"Finalization Queue和Freachable Queue 这两个队列和.net对象所提供的Finalize方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。 当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。在GC被启动以后，经过Mark阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被Finalization Queue中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到Freachable Queue中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？因为这个对象的Finalize方法还没有被执行，所以不能让它死去。 Freachable Queue平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的Finalize方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。.net framework的System.GC类提供了控制Finalize的两个方法，ReRegisterForFinalize和SuppressFinalize。前者是请求系统完成对象的Finalize方法，后者是请求系统不要完成对象的Finalize方法。ReRegisterForFinalize方法其实就是将指向对象的指针重新添加到Finalization Queue中。这就出现了一个很有趣的现象，因为在Finalization Queue中的对象可以复生，如果在对象的Finalize方法中调用ReRegisterForFinalize方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。 ","date":"2023-03-24","objectID":"/csharp-gc/:5:0","tags":null,"title":"[转载]C#垃圾回收机制(GC)","uri":"/csharp-gc/"},{"categories":null,"content":"托管资源 \u0026\u0026 非托管资源 Net中的所有类型都是（直接或间接）从System.Object类型派生的。 CTS中的类型被分成两大类——引用类型（reference type，又叫托管类型[managed type]），分配在内存堆上，值类型（value type）。值类型分配在堆栈上。如图 ![](https://images.cnblogs.com/cnblogs_com/frank_xl/CSType.gif =500x) 值类型 在栈里，先进后出，值类型变量的生命有先后顺序，这个确保了值类型变量在推出作用域以前会释放资源。比引用类型更简单和高效。堆栈是从高地址往低地址分配内存。 引用类型 分配在托管堆(Managed Heap)上，声明一个变量在栈上保存，当使用new创建对象时，会把对象的地址存储在这个变量里。托管堆相反，从低地址往高地址分配内存，如图 ![](https://images.cnblogs.com/cnblogs_com/frank_xl/StackHeap.gif =500x) .net中超过80%的资源都是托管资源。 非托管资源 ApplicationContext,Brush,Component,ComponentDesigner,Container,Context,Cursor,FileStream,Font,Icon,Image,Matrix,Object,OdbcDataReader,OleDBDataReader,Pen,Regex,Socket,StreamWriter,Timer,Tooltip ,文件句柄,GDI资源,数据库连接等等资源。可能在使用的时候很多都没有注意到！ .NET的GC机制有这样两个问题： 首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。 第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。 GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。使用using 语句可以简化资源管理。 示例 /// \u003csummary\u003e /// 执行SQL语句，返回影响的记录数 /// \u003c/summary\u003e /// \u003cparam name=\"SQLString\"\u003eSQL语句\u003c/param\u003e /// \u003creturns\u003e影响的记录数\u003c/returns\u003e public static int ExecuteSql(string SQLString) { using (SqlConnection connection = new SqlConnection(connectionString)) { using (SqlCommand cmd = new SqlCommand(SQLString, connection)) { try { connection.Open(); int rows = cmd.ExecuteNonQuery(); return rows; } catch (System.Data.SqlClient.SqlException e) { connection.Close(); throw e; } finally { cmd.Dispose(); connection.Close(); } } } } 当你用Dispose方法释放未托管对象的时候，应该调用GC.SuppressFinalize。如果对象正在终结队列(finalization queue),GC.SuppressFinalize会阻止GC调用Finalize方法。因为Finalize方法的调用会牺牲部分性能。如果你的Dispose方法已经对委托管资源作了清理，就没必要让GC再调用对象的Finalize方法(MSDN)。附上MSDN的代码，大家可以参考. public class BaseResource : IDisposable { // 指向外部非托管资源 private IntPtr handle; // 此类使用的其它托管资源. private Component Components; // 跟踪是否调用.Dispose方法，标识位，控制垃圾收集器的行为 private bool disposed = false; // 构造函数 public BaseResource() { // Insert appropriate constructor code here. } // 实现接口IDisposable. // 不能声明为虚方法virtual. // 子类不能重写这个方法. public void Dispose() { Dispose(true); // 离开终结队列Finalization queue // 设置对象的阻止终结器代码 // GC.SuppressFinalize(this); } // Dispose(bool disposing) 执行分两种不同的情况. // 如果disposing 等于 true, 方法已经被调用 // 或者间接被用户代码调用. 托管和非托管的代码都能被释放 // 如果disposing 等于false, 方法已经被终结器 finalizer 从内部调用过， //你就不能在引用其他对象，只有非托管资源可以被释放。 protected virtual void Dispose(bool disposing) { // 检查Dispose 是否被调用过. if (!this.disposed) { // 如果等于true, 释放所有托管和非托管资源 if (disposing) { // 释放托管资源. Components.Dispose(); } // 释放非托管资源，如果disposing为 false, // 只会执行下面的代码. CloseHandle(handle); handle = IntPtr.Zero; // 注意这里是非线程安全的. // 在托管资源释放以后可以启动其它线程销毁对象， // 但是在disposed标记设置为true前 // 如果线程安全是必须的，客户端必须实现。 } disposed = true; } // 使用interop 调用方法 // 清除非托管资源. [System.Runtime.InteropServices.DllImport(\"Kernel32\")] private extern static Boolean CloseHandle(IntPtr handle); // 使用C# 析构函数来实现终结器代码 // 这个只在Dispose方法没被调用的前提下，才能调用执行。 // 如果你给基类终结的机会. // 不要给子类提供析构函数. ~BaseResource() { // 不要重复创建清理的代码. // 基于可靠性和可维护性考虑，调用Dispose(false) 是最佳的方式 Dispose(false); } // 允许你多次调用Dispose方法, // 但是会抛出异常如果对象已经释放。 // 不论你什么时间处理对象都会核查对象的是否释放, // check to see if it has been disposed. public void DoSomething() { if (this.disposed) { throw new ObjectDisposedException(); } } // 不要设置方法为virtual. // 继承类不允许重写这个方法 public void Close() { // 无参数调用Dispose参数. Dispose(); } public static void Main() { // Insert code here to create // and use a BaseResource object. } } GC.Collect() 方法 作用：强制进行垃圾回收。 GC的方法： 名称 说明 Collect() 强制对所有代进行回收 Collect(Int32) 对0到指定代进行回收 Collect(Int32, GCCollectionMode) 强制在 GCCollectionMode 值所指定的时间对零代到指定代进行垃圾回收。 GC注意事项： 只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理 循环引用，网状结构等的实现会变得简单。GC的标志也压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。 GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。 GC在一个独立的线程中运行来删除不再被引用的内存 GC每次运行时会压缩托管堆 你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。 对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数 Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer.而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对","date":"2023-03-24","objectID":"/csharp-gc/:5:1","tags":null,"title":"[转载]C#垃圾回收机制(GC)","uri":"/csharp-gc/"},{"categories":null,"content":"作者：海默 链接：https://www.zhihu.com/question/65018524/answer/2330206559 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 一句话来说，日丹诺夫主义的幽灵依然在我国哲学教育界游荡。 日丹诺夫死了，日丹诺夫主义诞生的国家也解体了，但日丹诺夫主义的幽灵并没有被驱散，他依然游荡在我国官方哲学教育界。 在当代中国哲学界,已经很少有人知道日丹诺夫这个名字以及1947 年6 月24 日这个讲话了（引者注：1947年6月24日的讲话指的是日丹诺夫在关于《西欧哲学史》一书研讨会上的讲话，日丹诺夫发表了关于对哲学和哲学史的一些看法）。即使是知道它们的人,也总觉得那似乎是一个关于别人的虚无缥缈的故事。这毫无疑问是错误的。因为在10 个月后,这篇发言就被中国共产党老资格的革命家李立三在晋察冀解放区翻译成中文出版,先在各大解放区广泛传播,接着在解放后的知识分子思想改造中和《联共 (布) 党史简明教程》一起成为中国哲学家们的必读书目,深刻地改变、重塑了那一代中国人的哲学史观念。作为这种思想改造的积极成果,60 年代初,脱胎换骨后的中国哲学家们创作和出版了多种《西方哲学史》和《中国哲学史》,这些著作的文字无疑是中国的,但它们的灵魂却是苏联的。日丹诺夫在中国复活了! ① ①张亮《政治的逻辑与哲学史 ———重读日丹诺夫1947 年6 月24 日的讲话》 即便在没有多少人知道的这篇讲话的今天,它的精神依旧梦魇般地束缚着当代中国人,成为束缚我们去真实面对哲学的历史、思想的历史的僵化教条。② 日丹诺夫主义的哲学用一句话来说就是：“哲学史就是唯物主义和唯心主义斗争，最后唯物主义战胜唯心主义的历史。整个哲学史就是这样一个观点。”③ 也就是我们耳熟能详的一句话：哲学史是唯物主义和唯心主义的两军对垒。 这样的说法对不对？或者说符不符合马克思主义？ 我们在马恩列著作中确实没有看到这样的论述，而列宁在《哲学笔记》里的一句话被用来反抗日丹诺夫主义的政治高压：“哲学的历史、各门科学的历史…….简单地说，就是整个认识的历史……”。列宁在这里把哲学的历史归属到整个认识的历史之中，也就是说哲学史属于认识的历史，哲学史是认识史里的一部分。 日丹诺夫主义会用“反马列主义”来驳斥你的观点，你不认同我这一套，你是反马列主义的。然而，这句话就是列宁说的，你不能说列宁反对马列主义。 这句话成为一些想要突破日丹诺夫主义体系的人的护身符。我们接受的哲学教育里，会告诉你谁谁谁的什么什么内容是“唯心主义”“形而上学”，这是错误，谁谁谁的什么什么内容是“唯物主义”“辩证法”，这是正确的。 然而我问你，这个人的思路是什么？ 我们的官方哲学教育对这个讲得太少。 他会贴标签，给这个贴“唯心主义”，给那个贴“唯物主义”。 做题目是“连连看”，把这个连到“唯心主义”，把那个连到“唯物主义“。 然而，这些哲学说法的思路是什么？ 既然哲学史是认识史的一部分，那哲学自然要认识一部分东西，不管这个认识正不正确，但要给认识问题提供了一个答案。 也就是说，哲学内容是要回答一些问题的，是要帮助人认识问题的，不论这个回答对不对，但至少这个回答是针对着人类的认识问题。 在唯物主义与唯心主义两军对垒的叙述下，官方哲学教育执着于“贴标签”与“连连看”，却没告诉你，这些人在回答什么问题，这些人的思路是什么。 举几个例子，黑格尔的“绝对精神”，哲学书告诉我们，这属于客观唯心主义。 任何一个接受过官方哲学教育的人，在做题时，基本上都会毫不犹豫地给“绝对精神”贴上客观唯心主义的标签。 那问问，“绝对精神”是什么意思？ 哲学教材书没告诉我们。 “绝对精神”回答了什么人类认识问题？ 也没告诉我们。它花了太多精力贴标签，却没解释这些。 这样的词汇太多了，哲学教科书只告诉我们这属于什么，却没告诉这些词说了什么。 因为哲学是唯物主义与唯心主义的两军对垒，关键的是知道这些是唯物主义的还是唯心主义的。 这是日丹诺夫主义哲学的思路。 但按列宁的思路，哲学史是人类认识历史的一部分。 比如康德，在唯理论哲学和经验论哲学各执一端而僵持不下时，对如何再次确立知识的可靠性与可用性这个问题时，康德提出一系列哲学主张。 他在回答这个问题，在回答人类认识的问题。 固然，按照日丹诺夫主义哲学的定义，康德是“二元论”，是“不可知论”，好像都不是什么正面的词汇，但康德在回答这些问题。他在回答人类认识的问题。他的回答可能错了，但他有一个思路。 这个思路不是简单贴标签就能解决的。 康德的“物自体”是日丹诺夫主义哲学体系的“不可知论”，但“物自体”是个什么意思以及康德提出这个概念是回答什么问题，日丹诺夫主义对这个并不关心。 而这样执着于“唯物主义”与“唯心主义”的划分，不是说不对，但你不能只划分不解释，他的思路是什么呢？这个问题需要回答。 而因为不回答哲学理论的思路，或者说对哲学理论思路漠不关心，就导致了另一个恶果——断章取义来划分唯物主义与唯心主义。 经典例子就是笛卡尔的“我思故我在”。 笛卡尔“我思故我在”是有论述的，这只是其中一句话，结合上下文，我们不难看出，笛卡尔的意思是：从“我思”可以推导出“我存在”。或者更简便一点：我思可推出我存在。④ “我思故我在”，如果断章取义并且加上望文生义（日丹诺夫主义经常用这套来给哲学理论贴标签，笛卡尔这个只是显著例子），就理解为：我思考，所以我存在，我的思考是我存在的原因。 这样就把“思维”“意识”看成了原因，把“存在”看成了结果，也就是把“意识”看成第一性的，这确实是唯心主义。 但如果认真阅读上下文，“我思可推我存在”这个思路并不能得出这个理论是唯心主义的。 我举一个例子：张三有一个想法，这个想法是他下午要去接他的小孩。我不认识张三，但我知道了张三的想法，我推论，张三有小孩，张三的小孩是存在着的。 这也是从思想（接小孩的想法）推出存在（小孩的存在），从意识推出存在，只是一种推理，不意味着意识是小孩的原因，意识是第一性的。 笛卡尔这句话并不表现出唯心主义的意思。 我们看到这个连锁反应，执着于唯物唯心的划分，使得不关注哲学理论的思路，不关注哲学理论的思路导致断章取义与望文生义，断章取义与望文生义导致了对马哲之外的哲学理论的错误解释。 而对其他哲学理论的错误解释也会导致一个后果：对马哲的错误解释、庸俗化解释。 我在读完挪威高校哲学史教材时有感而发：这本书是挪威高校哲学史教材，那不得不说，挪威的高校哲学教育吊打我们国内，我们国内的哲学教材还是日丹诺夫那套，通过歪曲马克思主义哲学以外的哲学思想，把笛卡尔、康德等人思想说成是小学生都会感觉荒谬的东西，如同抗日神剧一样（将敌人无限贬低时自己也被贬低了），而且对马克思的思想也是庸俗化的。希望我们国家的教育部，可以像挪威一样编订这样一部教材。开口“形而上学”，闭口“唯心主义”的哲学教育太失败了。 这是一个很简单的道理：A把你要驳斥的理论庸俗化了，错误曲解了，你的理论也就被曲解了。 比如爱因斯坦驳斥了牛顿的绝对时空观，物理教材这么写：牛顿的绝对时空观认为人在任何情况下度过时间的感受都一样，人在煎熬时不会感觉时间过得慢，人在享受时不会感觉时间过得快。这就是牛顿的绝对时空观，爱因斯坦批判了这个。 那请问看完这段话，你认为爱因斯坦的时空观是什么？ 很明显如果把牛顿的时空观曲解了，反驳他的理论，你很难理解甚至只有错误理解。 只要翻开日丹诺夫主义体系的书，就会看到这样对其他哲学理论的人曲解比比皆是。 讲好牛顿的绝对时空观是理解爱因斯坦时空观的基础，对于马克思主义之前的哲学理论也是如此。 靠着歪曲与曲解，得到的也是歪曲与曲解。 我们举一个例子：形而上学与辩证法，这对划分是我们听得第二多的哲学词汇了。 形而上学是什么意思？辩证法是什么意思？ 我们学的形而上学释义，即形而上学是用孤立静止片面的观点看世界。这种释义只是一种特殊语境下的使用。 一些形而上学家喜欢用“孤立静止片面的观点看世界”，马恩用这个词来讽刺他们。 就好像小孩大多幼稚、天真，我们看到一个人也用一种幼稚、天真的思维来看问题。 我们说：你有这种想法，真是个小孩。你这种想法是小孩的想法。 小孩是什么意思？日丹诺夫主义体系说：小孩的意思是“用天真、幼稚的观点看世界”。 这种定义可笑在，小孩是人不是观点，也不是所有小孩都是天真幼稚的。 形而上学同理。形而上学是一种哲学学科，不是一种观点。其次不是所有形而上学都是片面孤立静止的。 在实体的私法的结尾部分，我看到了整体的虚假，这个整体的基本纲目接近于康德的纲目，而阐述起来却大相径庭。这再次使我明白，没有哲学就无法深入。于是我就可以心安理得地重新投入哲学的怀抱，并写了一个新的形而上学基本体系，但在该体系的结尾处我又一次不得不认识到它和我以前的全部努力都是错误的。——［德］马克思.致亨利希·马克思（1837年11月10—11日）／／马克思恩格斯全集：第47卷.2版.北京：人民出版社，2004：11. 可以看到马克思也是用形而上学的原本意思。马克思在这里也是把形而上学看成一种哲学学科。⑤ 1750年左右，德国所有的伟大思想家——诗人歌德和席勒、哲学家康德和费希特都诞生了；过了不到二十年，最近的一个伟大的德国形而上学家黑格尔诞生了。——恩格斯《德国状况》 这里就更加明显了，用日丹诺夫主义体系，黑格尔是唯心主义辩证法的，形而上学与辩证法是相对的，这句话就会成自相矛盾的话。这里只能把形而上学按一般意思来理解。 形而上学只有在特殊语境下，才拥有了日丹诺夫主义体系的唯一解释。就好像小孩也只有在特殊语境下，才拥有了“用幼稚天真的观点看世界”这个解释。 其次是错上加错，对形而上学的解","date":"2023-03-10","objectID":"/zhongguo-zhexuejiaoyu/:0:0","tags":null,"title":"[转载] 为什么我国中学的哲学教育这么失败?","uri":"/zhongguo-zhexuejiaoyu/"},{"categories":null,"content":"从问题出发 当我在实现 2D 平台游戏中 WallJump 时遇到了麻烦，角色的水平移动是关于输入的函数，即: void Update() { Velocity.X = input_map(HorizontalInput); MoveAndSlide(); } 而 WallJump 需要赋予玩家一个 斜向初速度，此时的水平速度会被 HorizontalInput 覆盖 [Export] float WallJumpVelocity; void WallJump(Vector2 direction) { Velocity = dir * WallJumpVelocity.X + Vector2.Up * WallJumpVelocity.Y; MoveAndSlide(); } 最终的效果就是玩家只会产生向上的移动。S有一个简单的技巧可以回避这个问题，在 WallJump 发生的一瞬间启动一个 计时器 计时结束前屏蔽玩家输入。这能解决问题，但是不够优雅和一致，这是在回避问题而不是解决问题, 这个问题的根源是: 当我们输入时是否应该立即作用于角色 于是我采用 缓动 的方式改变使 HorizontalInput 延迟作用到 Velocity 这个视频作者的思路和我大致相同，但并非使用自定义的缓动曲线，而是使用时常出现 Unity 教程中的方法: void Update() { // horizontal move var targetVelocity = input_map(HorizontalInput); Velocity = Lerp(Velocity, targetVelocity, k); MoveAndSlide(); } 这是一个 幂函数($y=a^x$) 缓动曲线, 初学者通常误以为是线性插值而对 Lerp 函数产生误解, 我后面会解释原因。 ","date":"2023-03-07","objectID":"/lerp_and_easing_effect_in_update_function/:1:0","tags":null,"title":"Lerp 函数与递推缓动","uri":"/lerp_and_easing_effect_in_update_function/"},{"categories":null,"content":"该问题引发的思考 为什么使用 Lerp 插值能解决问题呢？采用自定义缓动的曲线为什么不行呢？ 分析一: 自定义缓动曲线方法 通常自定义的曲线需要确定 起始值(s)、终点值(f)、插值变量(p) 从而在每帧插值出当前需要的值并更新。例如: private Vector2 cachedVelocity; private float p; void Update(float delta) { var targetVelocity = input_map(HorizontalInput); // 获取预期的水平速度 Velocity = Lerp(cachedVelocity, targetVelocity, p); MoveAndSlide(); p = Mathf.Clamp(t + delta, 0f, 1f); // 更新插值变量(t) } void Start() { cachedVelocity = this.Velocity; p = 0f; } 这种方法中 当前值(c) 不参与计算，而是 插值变量(p) 在控制插值过程，这会导致一个问题： 当前值(c) 和 终点值(f) 并非固定, 例如 WallJump 触发时会直接修改 Velocity.X, HorizontalInput 也随着输入改变而改变。 终点值(f) 发生连续变化时, 插值变量(p) 不变时, 插值结果可能会产生巨大突变。（因为自定义曲线的斜率是无法预知的） 当前值(c) 发生突变时, 需要重新启动一个插值过程 即：重置插值的 插值变量(p = 0) 和 起始值(s = c) 分析二: 递推的 Lerp 方法 而递推的 Lerp 的方法是利用 当前值(c) 代替 起始值(s), 用户输入作为 目标值(f)， 这样不论如何 速度都会平滑的改变： void upadte() { var targetVelocity = input_map(HorizontalInput); Velocity = Lerp(Velocity, targetVelocity, 0.1f); // 注意这里 p 固定为 0.1, 后面会讨论 } 终点值(f) 发生连续变化时, 插值结果是通过 Lerp 函数以 起始值(s) 为起点插值的, 所以一定是连续的。 当前值(c) 发生突变时, 插值仍然是从 起始值(s) 开始的, 所以仍然是连续的。 上述两种情况保证了 Velocity 的 连续性 这种不依赖 插值变量(t) 的 无状态迭代方法 很有意思。于是我跳脱出这个问题，开始思考该方法更加一般的应用。 ","date":"2023-03-07","objectID":"/lerp_and_easing_effect_in_update_function/:2:0","tags":null,"title":"Lerp 函数与递推缓动","uri":"/lerp_and_easing_effect_in_update_function/"},{"categories":null,"content":"无状态递推缓动函数 首先我们思考 $c_{n+1} = lerp(c_n, f, 0.1)$ 的本来面貌！ Lerp 函数定义 我们只考虑 float 插值的情况，其他多维变量大同小异 float Lerp(float s, float f, float p) { if(p \u003e 1) return f; if(p \u003c 0) return s; return (1 - p) * s + p * f; } 显然这是一个线性插值， 但是将其应用于缓动时， 起始值(s) 传入的是当前值(c)，所以这个过程是 递推的 用数列来表达缓动过程就是： $$ x_{n} = (1 - p) \\cdot x_{n-1} + p \\cdot f $$ 求解 $x_{n}$ 通项公式是一个简单的高中数列问题： $$ x_{n} - f = (1-p)\\cdot (x_{n-1} - f) \\\\ x_{n-1} - f = (1-p)\\cdot (x_{n-2} - f)\\\\ …\\\\ x_{1} - f = (1-p)\\cdot (x_{0} - f)\\\\ $$ 累乘可得 $x_n = (1-p)^n \\cdot (x_0 - f) + f$ 这里的变量的含义是累计迭代的次数 $n \\in (1, +\\infty)$ 而缓动函数的变量是 $t \\in (0, 1)$, 我们假设每帧的更新时间是 $\\triangle t$, 可以得到 $n = \\frac{t}{\\triangle t}$ 从而: $g(t) = x_{\\frac{t}{\\triangle t}} = (1-p)^{\\frac{t}{\\triangle t}} \\cdot (x_0 - f) + f$ 至此我们得到了 递推式 $x_{n} = (1 - p) \\cdot x_{n-1} + p \\cdot f$ 的 函数式 $g(t) = x_{\\frac{t}{\\triangle t}} = (1-p)^{\\frac{t}{\\triangle t}} \\cdot (s - f) + f$ 当 s = 0, f = 1, p=[0.01 -\u003e 0.08] 时该函数图像如下图（p 越大 曲线弯曲程度越大） 当 s=0, f =[1.0 -\u003e 1,4], p = 0.05 时 该函数曲线如下 （f 越大曲线渐进线越高） ","date":"2023-03-07","objectID":"/lerp_and_easing_effect_in_update_function/:3:0","tags":null,"title":"Lerp 函数与递推缓动","uri":"/lerp_and_easing_effect_in_update_function/"},{"categories":null,"content":"曲线分析 当前值(c) 的稳定性 对于我们的需求，最佳的曲线是，当 终点值(f) 发生变化时 当前值(c) 不发生改变。但是遗憾的是这样的曲线并不存在。证明很简单，略。 既然 c 不可能不发生变化，那么在 f 变化时保证 c 平滑变化也是可以接受的。 计算 $g(t, f)$ 对 $f$ 的偏导数: $$ \\frac{\\partial g}{\\partial f} = 1 - (1 - p)^{\\frac{t}{\\triangle t}} $$ 其中 $p, \\triangle t$ 几乎是不变的, 所以对于某时刻 $t$, 当前值(c) 随 终点值(f) 的变化而平滑变化 当前值(c) 的变化速率 由于 $g(t)$ 是一个以 $y=f$ 为渐近线的渐进曲线。所以 我们可以计算 $\\delta = |g(t) - f| = (1-p)^{\\frac{t}{\\triangle t} \\cdot (f -s)}$ 来表示值得接近程度, $(1-p)^{\\frac{t}{\\triangle t}}$ 表示,随着越来越接近 终点值(f) 变化将越来越缓慢, 所以该曲线影响 渐进速度的量是 $(1-p)^{\\frac{t}{\\triangle t}}$ 项 当 s = 0, f = 1, p = 0.83, dt = [0.1 -\u003e 0.7] 是如下图：（$\\triangle t$ 越大曲线弯曲程度越小） 可见 $p$ 和 $\\triangle t$ 都会影响曲线的弯曲程度(渐进时间), 并且 影响的方向相反(一个变平滑一个变弯曲) 可见 $(1-p)$ 和 $\\triangle t$ 是影响响应时间的主要部分(通过分析偏导数可以得到), 在游戏引擎中 $\\triangle t$ 在物理帧中通常是常数, 所以只能通过调整 $p$ 的值来调整曲线的响应时间 这里产生了一个新问题：为了使 120fps($\\triangle t = \\frac{1}{120}s$) 的游戏和 60fps($\\triangle t = \\frac{1}{60}s$) 的游戏中的缓动具有相同的响应时间, 所以需要约束 $p$ 与 $\\triangle t$ 的关系。 $p$ 与 $\\triangle t$ 的约束 为了描述渐进曲线的接近程度, 上述分析中定义了 $\\delta = |g(t) - f| = (1-p)^{\\frac{t}{\\triangle t}} \\cdot (f -s)$ 来描述渐进程度 我们再定义一个小量 $\\epsilon \\cdot (f -s)$, 当 $\\delta = |g(t) - f| = (1-p)^{\\frac{t}{\\triangle t}} \\cdot (f -s) \u003c \\epsilon \\cdot (f -s)$ 表示缓动完成。作以下变形： $$ (1-p)^{\\frac{t}{\\triangle t}} \u003c \\epsilon \\\\ \\quad\\\\ t \u003e \\frac{\\triangle t \\cdot \\ln \\epsilon}{\\ln(1-p)} $$ 所以当 $t \u003e t_{max}$ 时缓动结束， 可以根据该约束得到 $p$ 与 $\\triangle t$ 的约束关系： $$ p = 1 - \\epsilon ^{\\frac{\\triangle t}{t_{max}}} $$ 所以最初的式子演变为： $$ g(t, t_{max}, \\epsilon) = (\\epsilon ^{\\frac{\\triangle t}{t_{max}}})^{\\frac{t}{\\triangle t}} \\cdot (s-f) + f = \\epsilon^{\\frac{t}{t_{max}}} \\cdot (s - f) + f $$ 该曲线有以下特性: 曲线的响应速度与 $\\triangle t$ 无关 通过控制参数 $t_{max}$ 控制响应速度 通过设置 $\\epsilon$ 改变 $t = t_{max}$ 的渐进程度 在 Update 调用中使用方便 void Update(float delta) { var targetVelocity = input_map(HorizontalInput); // 获得期望速度 float tMax = 0.5f; // 响应时间 float p = 1 - Mathf.Pow(Mathf.Epsilon, delta / tMax); // 计算上述的 p 值 Velocity = Lerp(Velocity, targetVelocity, p); // 线性插值 MoveAndSlide(); } 代码测试 import matplotlib.pyplot as plt import numpy as np import copy import math # params f = 1 s = 0 epsolon = 0.001 dt = 0.01 t_max = 0.5 # figure setting fig = plt.figure() axes = fig.add_axes([0.1, 0.1, 0.8, 0.8]) # generate x sequence t = np.linspace(0, 1, int(1/dt)) # pre-compute `p` p = 1 - math.pow(epsolon, dt / t_max) # g(t) = (1-p) ^ (t/dt) * (s-f) + f = epsolon ^ (t/t_max) * (s-f) + f y1 = epsolon ** (t / t_max) * (s - f) + f # simulation game engine's update y, tmp = [], copy.deepcopy(s) for ti in t: tmp = (1 - p) * tmp + p * f y.append(tmp) # draw call axes.plot(t, np.array(y), c=\"green\", label=\"y=h(x)\", ls='-.', alpha = 1, lw=2, zorder=1) axes.plot(t, y1, c=\"blue\", label=\"y=lerp\", ls=':', alpha = 0.5, lw=2, zorder=1) axes.legend() plt.show() ","date":"2023-03-07","objectID":"/lerp_and_easing_effect_in_update_function/:3:1","tags":null,"title":"Lerp 函数与递推缓动","uri":"/lerp_and_easing_effect_in_update_function/"},{"categories":null,"content":"更进一步的思考 使用 Lerp 插值的缓动函数过于单一，如果我们需要使用更加灵活多样的缓动函数，并且要将他们改变为 无状态 递推的方法应该要怎么做呢？ 例如 我们的目标缓动函数是 $func(t) = t^2$ 第一步 $func(t + \\triangle t) = (t + \\triangle t) ^ 2$ 第二步 假设存在一个迭代函数 $h(\\cdot)$, 并且满足 $func(t + \\triangle t) = h[func(t)]$ 这里的 $h(\\cdot)$ 相当于原方法里的 Lerp 第三步 为了得到 $h$ 的解析形式 令 $k=func(t), \\quad t=func^{-1}(k)$ 带入原式 $h(k) = func(func^{-1}(k)+\\triangle t) = (\\sqrt{k} + \\triangle t)^2$, 所以只要 $func$ 的反函数存在就一定能计算得到 $h(k)$ float h(float k) { return g(g_inverse(k) + 1); } void Update() { position = h(position); } 然后如果要限制响应时间，变化程度的话，参考前文的方法吧！本来还想做一个统一的参数化方法的，但是累了！ 问题就解决啦，我真是个小天才，卧槽。 ","date":"2023-03-07","objectID":"/lerp_and_easing_effect_in_update_function/:4:0","tags":null,"title":"Lerp 函数与递推缓动","uri":"/lerp_and_easing_effect_in_update_function/"},{"categories":null,"content":"在我自己的 2D Platformer 项目中控制器手感非常僵硬，有一部分原因是缺少合适的角色动画，另一部分原因是控制器没有足够灵活。 然而在 Bilibili、Youtube 这样的视频网站教学中的控制器通常是简单的、不可拓展的、面向初学者的。 所以我希望通过收集各种有意思的控制器实现，并借鉴它们的优点，最终实现出一个自己的、有趣的、可拓展的控制器。 ","date":"2023-02-17","objectID":"/flexible-2d-platform-game-controller/:0:0","tags":null,"title":"List of 2D Platformer Controllers [23.2.17]","uri":"/flexible-2d-platform-game-controller/"},{"categories":null,"content":"2d-platformer-controller 这是一个 Unity2D 的控制器，作者不满足于 Unity2D 提供的物理特性，通过射线检测的方式实现自己的控制器。 包含如下特性： 平滑精确的移动 多段跳跃 易于添加动画（学一下具体怎么实现的） 单向平台 墙跳/滑墙 斜坡移动 冲刺和空中冲刺 梯子 移动平台 破碎平台 存档点系统 环境陷阱 拾取物品 压力板、操纵杆、其他触发器 跳板 虽然这使用 Unity2D 实现，但是同样可以借鉴并在 Godot 中使用作用！这个控制器将许多 Controller 以外的功能放到 Controller 中实现了？ ","date":"2023-02-17","objectID":"/flexible-2d-platform-game-controller/:1:0","tags":null,"title":"List of 2D Platformer Controllers [23.2.17]","uri":"/flexible-2d-platform-game-controller/"},{"categories":null,"content":"Unity Controller 射线检测技巧 大概讲了如何通过射线检测代替原本的2D物理，以及射线起点和角色边缘之间的间距是怎么工作的。 ","date":"2023-02-17","objectID":"/flexible-2d-platform-game-controller/:2:0","tags":null,"title":"List of 2D Platformer Controllers [23.2.17]","uri":"/flexible-2d-platform-game-controller/"},{"categories":null,"content":"platforming-engine 这个 控制器非常牛逼，超乎想象，这似乎就是奥日2Demo中的控制器！todo: 将这个控制器复刻到 Godot 上 主要学习以下实现： 动画为什么这么流畅 动画如何与物理配合的 与环境交互时交互相关的代码如何组织的 虽然这是 GameMaker Studio 2 的实现，但是可以抄到 Godot 来 ","date":"2023-02-17","objectID":"/flexible-2d-platform-game-controller/:3:0","tags":null,"title":"List of 2D Platformer Controllers [23.2.17]","uri":"/flexible-2d-platform-game-controller/"},{"categories":null,"content":"Ultimate-2D-Controller 这个是一个 Unity 的控制器，也相当流畅，但是完整版本要收费。 之后再看吧！ ","date":"2023-02-17","objectID":"/flexible-2d-platform-game-controller/:4:0","tags":null,"title":"List of 2D Platformer Controllers [23.2.17]","uri":"/flexible-2d-platform-game-controller/"},{"categories":null,"content":"对于游戏控制器状态机的一些思考 之前实现过几个简单的状态机，但是它们都不便于扩展，这其中的原因是：一旦改变了被控制对象的类型，状态机中对被控制对象的引用就失效了 这意味着我们需要一种方法来将被控制对象和状态机解耦，通过 GodotObject 的反射功能可以做到这一点，但是这仍然要求被控制对象实现某些 属性/方法。 还有一种方法是通过 Blackboard 来交互，具体做法是： 状态机以及所有状态类共享一个Dictionary\u003cstring, Variant\u003e blackboard 对象. 状态机只读写 balckboard 中的字段的值。状态机通过定义一组字段名来确定所需的功能。 被控制对象需要在每一个物理帧同步 blackboard 的值。 这样整个被控制对象只需要实现同步各个属性的方法即可。其余的计算可以全部委托给状态机。并且为状态机添加新状态/新功能时 只需要添加 blackboard 的字段即可。 并且这种结构在分层状态机中同样便于实现。 ","date":"2023-02-17","objectID":"/flexible-2d-platform-game-controller/:5:0","tags":null,"title":"List of 2D Platformer Controllers [23.2.17]","uri":"/flexible-2d-platform-game-controller/"},{"categories":null,"content":"官方文档中，Viewport 、 CanvasLayer、Camera 是比较基本的概念，但是文档中解释得并不清楚（可能是翻译导致的 ","date":"2023-02-14","objectID":"/viewport/:0:0","tags":null,"title":"[godot4] Viewport \u0026\u0026 CanvasLayer \u0026\u0026 Camera \u0026\u0026 SCREEN_TEXTURE","uri":"/viewport/"},{"categories":null,"content":"CanvasItem 所有的 Node 和 Control 都继承自 CanvasItem, 每个 CanvasItem 都继承其父节点的 Transform 所有被显示的 CanvasItem 都是Viewport 的直接或间接子节点。 移动整个场景，应该改变 Viewport 的Transform 而不是场景的 Node ","date":"2023-02-14","objectID":"/viewport/:1:0","tags":null,"title":"[godot4] Viewport \u0026\u0026 CanvasLayer \u0026\u0026 Camera \u0026\u0026 SCREEN_TEXTURE","uri":"/viewport/"},{"categories":null,"content":"CanvasLayer 比如我们希望 HUD / UI 的屏幕位置不发生改变，就可以为 UI 创建一个单独的 CanvasLayer，能够让某层独立的渲染它通过 Layer 数字规定了渲染的优先级，这很重要。 CanvasLayers 的渲染顺序与树结构无关，只依赖于层编号 layer. 也就是说，树上存在两个有不同 layer 、且是直接或间接父子关系的 CanvasLayer，其渲染关系/顺序不依照树结构，而是 layer 。 layer 越大，越后绘制，在图层越上面！ ","date":"2023-02-14","objectID":"/viewport/:2:0","tags":null,"title":"[godot4] Viewport \u0026\u0026 CanvasLayer \u0026\u0026 Camera \u0026\u0026 SCREEN_TEXTURE","uri":"/viewport/"},{"categories":null,"content":"Camera2D 一个 Viewport 中仅存在一个被激活的 Camera2D, 这意味着一个 Viewport 仅为一个相机显示画面。 3D中情况不同，可以使用多个相机对世界进行观察，并将其中一些映射到纹理。 那么2D 下如何实现这种功能呢？例如我们需要做一个 2D 的双人同屏游戏该怎么做呢？ Viewport 所观测的世界由资源对象 World2D 控制, 如果两个Viewport 的 World2D 指向同一个对象，他们的相机在 World2D 的不同位置，那么它们的 Viewport 所绘制的画面也是不同的。例如双人同屏游戏可以按如下结构： * root * WorldNode * CanvasLayer * HBoxContainer * SubViewportContainer(Left Screen) * SubViewport * Camera_left * SubViewportContainer(Right Screen) * SubViewport * Camera_right let LeftSubViewportContainer.SubViewport.World2D = root.GetViewport(); let RightSubViewportContainer.SubViewport.World2D = root.GetViewport(); 这种结构是侵入性的，它需要修改整个项目的树结构。有时我们只想为场景添加一个 Mini Map UI 怎么办呢？可以使用以下结构 * root * WorldNode * ... * MainCamera * CanvasLayer * SubViewportContainer * SubViewport * MapCamera let SubViewport.World2D = root.GetViewport(); let MapCamera.GlobalPosition = MainCamera.GlobalPosition; 这样就能将 SubViewportContainer 作为小地图，并且通过CanvasLayer限制其层数。 值得注意的是：这里必须要使用 CanvasLayer， 这是由硬件的并行工作原理限制的。 如果在同一层渲染，渲染 root.Viewport 时需要获得 SubViewport 的纹理，渲染 SubViewport 时需要 root.Viewport 纹理，这就在一次渲染中既需要读也需要写纹理，这在目前的硬件上是不好实现的。 所以添加了 CanvasLayer，让两个 Viewport 的绘制不是同一个调用中绘制的！！ 此外 SubViewportContainer 好像有神奇的功能， 使用ViewportTexture 会抛出找不到 SubViewport 的错误（虽然也能显示，但是会报错，不清楚具体原因） E 0:00:00:0625 get_node: Node not found: \"CanvasLayer/CustomSubViewport\" (relative to \"Node2D\"). \u003cC++ 错误\u003e Method/function failed. Returning: nullptr \u003cC++ Source\u003e scene/main/node.cpp:1364 @ get_node() E 0:00:00:0625 setup_local_to_scene: ViewportTexture: Path to node is invalid. \u003cC++ 错误\u003e Condition \"!vpn\" is true. \u003cC++ Source\u003e scene/main/viewport.cpp:76 @ setup_local_to_scene() ","date":"2023-02-14","objectID":"/viewport/:3:0","tags":null,"title":"[godot4] Viewport \u0026\u0026 CanvasLayer \u0026\u0026 Camera \u0026\u0026 SCREEN_TEXTURE","uri":"/viewport/"},{"categories":null,"content":"godot4.0 rc 版本发布后，新插件如雨后春笋的涌现 很多插件我还没有尝试，但是很多感兴趣的插件，列表如下 ","date":"2023-02-13","objectID":"/godot_useful_plugin/:0:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Panku Console - A in-game console 特性如下： 漂亮灵活的多窗口系统 简单开箱即用 创建窗口实时检测表达式的值 绑定表达式到key Popup Notification 系统debug 信息 Powerful Inspector Generator（游戏内显示export变量） 历史表达式管理 这个真有点猛吧, 很多In-game 的控制台都是侵入式的，需要修改很多游戏代码，但是这个插件利用 GodotObject 的 call(name, params[]) / get(name) / set(name, value) 方法监控变量，计算表达式，调用方法！ Tip\r[2023.2.24] 使用情况：设计很方便，主要功能是能在游戏运行时监控对象，但是 godot 本来就有类似的性能监视器功能只是是在编辑器界面的。 对于屏幕小而不能同时到编辑器和游戏窗口的情况很方便。 但是在使用过程中遇到了恶性BUG： 监控的对象一旦被销毁，则会触发空引用报错 。。。 有些时候会出现狂掉帧（原因不明，但是关掉这个插件就恢复了） ","date":"2023-02-13","objectID":"/godot_useful_plugin/:1:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Softbody 2D - A squishy shapes generator 在 Unity3D 中有很多方法使用软体物理(Juice), 但是 Godot4.0 中仅提供了 3D 软体，而没有2D 软体 虽然可以手动的通过 Rigidibody2D， Spring 等组件来构造弹性物体，但是 弹簧和钢体之间的连接方式以及数值设置非常令人头疼， 这个插件可以基于 Polygon2D 生成器来生成多边形轮廓、内部顶点、骨骼、刚体 ","date":"2023-02-13","objectID":"/godot_useful_plugin/:2:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"VP-GAMES’s series of plugins Quest Editor(G4) : 一个任务编辑器 Dialogue Editor(G4) : 对话编辑器 Inventory Editor (G4) : 库存系统 Localization Editor (G4) : 本地化编辑器 这个没了解, 但是看起来不错，之后可以试试 库存和本地化管理器 ","date":"2023-02-13","objectID":"/godot_useful_plugin/:3:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Simple Grass Textured - A 3D grass editor 一个简单的3D草地编辑器，主要功能就是种草，我应该用不上，但是很好奇是怎么实现在草地上种草的(没写过3D 项目) ","date":"2023-02-13","objectID":"/godot_useful_plugin/:4:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Compute Worker - A simple compute node 这是一个比较有趣的东西， 一个支持 GPU 的运算节点，可能哟点类似各个游戏引擎中的 ComputeShader，用于计算大量数据（例如数以千/万计的动画），该节点简化了数据从内存拷贝到缓冲区的过程（大概吧，只看了简介，没用过），想要通过这个项目了解 Godot 的 ComputeShader 如何工作的/ ","date":"2023-02-13","objectID":"/godot_useful_plugin/:5:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Gameplay Attributes 游戏属性是一组用于描述某些节点 使用戈多制作的 2D 和 3D 游戏的角色属性。 ","date":"2023-02-13","objectID":"/godot_useful_plugin/:6:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Controller Icons - A controller UI 这是一个简单的支持各种控制器的 Controller UI 插件，可以方便的在频幕上显示提示 UI 等 支持列表 Xbox 360 Xbox One Xbox Series PlayStation 3 PlayStation 4 PlayStation 5 Nintendo Switch Controller Nintendo Switch Joy-Con Steam Controller Steam Deck Amazon Luna Google Stadia ","date":"2023-02-13","objectID":"/godot_useful_plugin/:7:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Godot RL Agents - A reinforcement learning framework AI Agent 插件, 这个好像有点牛逼，一个强化学习框架，提供了很多功能。 功能如下 提供 在Python 中运行机器学习算法的接口 提供三个著名 RL 框架包装器: StableBaselines3、Sample Factory 和 Ray RLLib 支持 记忆模型、LSTM、注意力模型 支持 2D / 3D 游戏 一套 AI 传感器用于增强 Agent 对于游戏世界的感知 ","date":"2023-02-13","objectID":"/godot_useful_plugin/:8:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Smoother - A physics smoother node 用于平滑运动的节点，即使在真率很低的情况下，也能有等同于屏幕刷新率的效果！ 虽然但是，有以下缺点： 适用于刚体，不适用于复杂节点 插值落后真实移动 没有 Look Forward 效果真挺好！ ","date":"2023-02-13","objectID":"/godot_useful_plugin/:9:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Beehave - A full-featured behaviour tree 这是 github 上标星最多的 godot 行为树项目， 相比其他很多行为树插件，该插件看起来文档详细，并且作者自己也在使用并且也会经常更新(比起很多行为树插件bug多，几乎没人维护，这个应该是唯一能用的了) 行为树的树结构是借用了 Godot 的 SceneTree, 没有实现基于 GraphyNode 的节点编辑器, 但是基本节点和功能都覆盖了。 行为树相关知识可以参考 Godot Behavior Tree Example ","date":"2023-02-13","objectID":"/godot_useful_plugin/:10:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Dialogue Manager - The bestest dialogue manager 这是一个简单的对话管理器插件，功能简单只专注于对话内容 和 对话过程 的管理（对话过程可以调用方法，类似于godot 动画中调用一样） 简洁, 没有多余的 GUI，仅有一个用于编写 .dialogue 文件的编辑器 高效, 对话采用文本编辑，类似代码中的流程控制，一个 .dialogue 文件甚至可以 import 其他的dialogue，这很符合程序员的想法（hhhh 独立, 它是一个完全独立的系统，仅仅提供 DialogueManager 的数个 API ，对原本游戏系统几乎\"零\"侵入。 正因为它足够简单和高效，拓展或者实现自定义 UI 都非常简单！ Tip\r[2023.2.24] 使用情况：很简单易用，暂时没有发现 BUG\r几乎把 godot 4.0 的插件列表翻了一遍，对上边这些比较感兴趣，并且打算 Panku Console 和 Beehave 应用到自己的项目中！ ","date":"2023-02-13","objectID":"/godot_useful_plugin/:11:0","tags":null,"title":"[Godot4.0] 实用插件搜索计划 第一期","uri":"/godot_useful_plugin/"},{"categories":null,"content":"Godot 有两个主流的 Dialog插件 Dialogue Manager Dialogic Dialogic 复杂庞大并且有丰富的图形化界面, 但是自定功能需要阅读很多源码 DialogManager 简单, 提供一种纯文本的方式编辑 Dialog， 添加自定义功能较简单， 并且能再运行时编辑 Dialog 本文仅根据官方文档介绍 Dialogue Manager 使用方式 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:0:0","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"Writting Dialogue ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:0","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"Nodes Dialogue Manager 将对话抽象为 dialogue 节点，dialogue 节点是以行为单位的传闻本结构，使用 ~ \u003cdialog_title\u003e 标记一个名为 \u003cdialog_title\u003e 的节点的开始 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:1","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"Dialogue 一个dialogue是形如Character: What they say.的一行文本 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:2","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"随机选择 Nathan: [[Hi|Hello|Howdy]]! 使用[[...]] 包裹的内容随机选择一个出现 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:3","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"变量 使用{{...}}在文本种添加变量， 所有的变量需要是全局的或者在 DialogManagerSetting 种指定 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:4","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"bbcode dialogue 支持富文本标记 bbcode 如果使用插件提供的 DialogueLabel 节点显示文本，可以额外的支持[wait=N]、 [speed=N] 和 [next=?] 标签 wait 标签显示完一段对话后等待的时间 speed 对话文本显示速度（打字速度） next 下一个对话的间隔？ ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:5","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"随机对话 之前的 [[]]是随机替换一个对话中的文本， 而 % 提供随机的一句对话，eg: 等概率随机对话 Nathan: I will say this. % Nathan: And then I might say this % Nathan: Or maybe this % Nathan: Or even this? 带权重的随机对话 %3 Nathan: This line as a 60% chance of being picked %2 Nathan: This line has an 40% chance of being picked ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:6","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"跳转 从一段对话跳转到另一段对话(类似 goto) =\u003e another_title 从一段对话跳转到另一段对话后返回下一句(类似过程调用) =\u003e\u003c another_title 可以跨文件导入对话(文件头部) import \"res://snippets.dialogue\" as snippets 导入后使用 =\u003e snippets/talk_to_nathan 来跳转对话 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:7","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"回答(选项) Nathan: What would you like? - This one - No, this one - Nothing 回答中也可以包含 bbcode、变量 默认是按照dialogue 的列表顺序进行，但是可以使用 =\u003e 根据不同的选项跳转,其中 END 表示结束对话 Nathan: What would you like? - This one Nathan: Ah, so you want this one? - Another one =\u003e another_title - Nothing =\u003e END 如果一个选项中包含了以 \u003cname\u003e: 开始的对话，玩家选中后会被当作一个对话进行？（没太懂） Someone: Here is a thing you can do. - That's good to hear! Nathan: That's good to hear! - That's definitely news Nathan: That's definitely news 等价于 Someone: Here is a thing you can do - Nathan: That's good to hear! - Nathan: That's definitely news ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:8","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"条件 dialogue 中的条件 if SomeGlobal.some_property \u003e= 10 Nathan: That property is greather than or equal to 10 elif SomeGlobal.some_other_property == \"some value\" Nathan: Or we might be in here. else Nathan: If neither are true I'll say this. response 中的条件使用 ‘[’ 和 ‘]’ 包起来 Nathan: What would you like? - This one [if SomeGlobal.some_property == 0 or SomeGlobal.some_other_property == false] Nathan: Ah, so you want this one? - Another one [if SomeGlobal.some_method()] =\u003e another_title - Nothing =\u003e END ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:9","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"Mutations 使用 set / do 来修改变量和调用方法 if has_met_nathan == false do SomeGlobal.animate(\"Nathan\", \"Wave\") Nathan: Hi, I'm Nathan. set has_met_nathan = true Nathan: What can I do for you? - Tell me more about this dialogue editor 请求一段对话时可以传入对象数组，该对话 检查是否存在可用的 Mutations 方法 内置的 Mutations 方法 emit 发射信号 wait 等待时间（单位 秒） debug print debug messgae Mutations 可以在 dialogue 行内被调用，并且是在文本打印到行内 mutations 位置时调用 Nathan: I'm not sure we've met before [do wave()]I'm Nathan. Nathan: I can also emit signals[do emit(\"some_signal\")] inline. tips: inline mutations 中的 await 是无效的， 即 inline mutations 方法必须是同步的 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:10","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"Error checking 游戏运行前语法错误会被高亮 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:11","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"测试场景 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:12","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"自定义测试场景 测试场景必须继承 BaseDialogueTestScene, 并且提供一个 dialogue resource 和 起始标题 extends BaseDialogueTestScene func _ready() -\u003e void: # Change this to open your custom balloon DialogueManager.show_example_dialogue_balloon(resource, title) ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:13","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"翻译 略 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:1:14","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"设置 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:2:0","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"编辑器 当使用静态翻译key并且手动添加时Treat missing translations as errors （看不懂 Wrap long lines : 自动换行 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:2:1","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"运行时 Include responses with failed conditions : 将包括未能通过其条件检查的响应列表附加到给定的行。(看不懂) ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:2:2","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"全局变量 插件的运行时本身是无状态的，这意味着需要自行提供变量和方法来运行，manager 首先在当前场景中查询然后在全局作用域中查询 如果不想使用 GameState.some_variable 可以在 Autoload 中 达赖GameState.gd 然后直接引用 some_variable ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:2:3","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"在游戏中使用对话 你可以自行决定dialogue 的表现方式和输入控制，也可以参考a few example balloons 可以调用 DialogueManager.show_example_dialogue_balloon(resource, title) 来调用使用内置的样例(render/Inputs) 当开始自己构建对话时，需要获得一行对话和使用 dialogue lable node ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:3:0","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"获取一行对话 通过静态类 DialogueManager 来访问对话管理器 可以使用 await DialogueManager.get_next_dialogue_line(resource, title) 来获取一行对话， 也可以直接从对话的resource 对象调用get_next_dialogue_line 方法来调用 疑问：如果这里直接返回了对话，那对话中的 Mutations 将在什么时机调用呢？ 回答：行内的 Mutations 交给 DialogueLabel 处理， Manager 会在调用 get_next_dialogue_line 时自行出里行间的 Mutations var resource = load(\"res://some_dialogue.dialogue\") # then var dialogue_line = await DialogueManager.get_next_dialogue_line(resource, \"start\") # or var dialogue_line = await resource.get_next_dialogue_line(\"start\") 这里的 dialogue_line 是一个 RefCounted 类型 现在，Dialogue _ line 包含一个字典，其中包含行 Nathan: 这里有一些选项。.此字典还包含响应选项列表。 没一个选项对应一个 next_id 属性, 常用于延续分支 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:3:1","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"DialogueLabel 节点 该节点需要提供一个 dialogue_line 字典， 如上文提及的 该节点会处理 bb_code、 wait、 speed 、inline_mutation 节点 该节点通过 .type_out() 方法来开始打印对话文本， 并且在文本结束时 触发finished_typing 信号，在遇到暂停时会触发 paused_typing 信号并携带暂停持续时间，每一个字母被打印时会触发 spoke 信号并携带打印速度。 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:3:2","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"运行时生成 Dialogue Resource var resource = DialogueManager.create_resource_from_text(\"~ title\\nCharacter: Hello!\") 文本首先被传到分析器，如果存在符号错误该方法会失败（失败是什么意思？ 注意：文本分析在创建时进行，不是在使用时进行 如果你没有错误，这个生成的 resource 局部对象，将可以被当作一般的 dialogue resource 使用 ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:3:3","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"C# wrapper using DialogueManagerRuntime; var dialogue = DG.Load\u003cResource\u003e(\"res://example.dialogue\"); # do DialogueManager.ShowExampleDialogueBalloon(dialogue, \"start\"); # or var line = await DialogueManager.GetNextDialogueLine(dialogue, \"start\"); tips: 这个 RefCounted 对象和 gd 版本有相同的 property ，但是需要手动的使用 .Get(\u003cproperty_name\u003e) 来访问？？ 可以在GetNextDialogueLine 方法内做一个类型转换呀？ ","date":"2023-02-10","objectID":"/godot_dialogue_plugin/:4:0","tags":null,"title":"[Godot-Plugin] Dialogue Manager \u0026\u0026 Dialogic","uri":"/godot_dialogue_plugin/"},{"categories":null,"content":"\r","date":"2023-01-16","objectID":"/game-idea-exchange/:0:0","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"灵感来源 前段时间玩了 传送门2, 想到一个新的游戏机制 玩家A可以发射一个交换球，交换球碰撞到特定的可交换物体 B后交换 A 和 B 的位置 该机制可以用来设计同传送门相似的各种奇思妙想的关卡，需要将整个机制分解为以下两个机制 移动场景中的物体 玩家获得位置移动 ","date":"2023-01-16","objectID":"/game-idea-exchange/:1:0","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"需要解决的问题？ 上文中 A 和 B 的体积 和 碰撞 Layer/Mask 都是不一样的，如何保证交换的物体在交换后不会与场景中已有的物体发生冲突呢？ 如何进行碰撞测试？ ","date":"2023-01-16","objectID":"/game-idea-exchange/:2:0","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"如何进行有效的冲突测试？ 引擎提供的冲突检测仅给出碰撞点和碰撞方向, 要实现将物体放置到安全位置还需要知道冲突重叠区域在碰撞法线方向上投影的最大宽度(将物体平移到恰好不碰撞的位移) 所以我们定义一个 恢复偏移向量: 假设物体 A 和环境碰撞体 B 发生碰撞, 碰撞点为 P, 碰撞法线为 N, 那么以 P 点为起始点方向为 -N 发射射线, 与 A 的碰撞体积计算几何交点 $Q_i$ 取最长的 $Q_iP$ QP, QP 则是恢复偏移向量 按照 QP 移动物体能解决 A/B 的冲突但是可能引入新的冲突, 所以需要多次进行 冲突测试-避免冲突 几何交点 public static List\u003cVector2\u003e GeometryIntersection(Polygon polygon, Ray ray) { List\u003cVector2\u003e res = new List\u003cVector2\u003e(); foreach(Segment segment in polygon.GetSegments()) { Vector2 intersection = GeometryIntersection(segment, ray); if(intersection != null) { res.Add(intersection); } } return res; } public static List\u003cVector2\u003e GeometryIntersection(Segment segment, Ray ray) { Vector2 A = segment.Start; Vector2 B = segment.End; Vector2 P = ray.Start; Vector2 D = ray.Direction; float k = ((B.x - P.x) * D.y - (B.y - P.y) * D.x) / ((B.x - A.x)*D.y - (B.y - A.y) * D.x); float t = (B.x - P.x - k * (B.x - A.x)) / D.x; if(k \u003e= 0 \u0026\u0026 k \u003c=1 \u0026\u0026 t \u003e= 0) return P + t * D; else return null; } ","date":"2023-01-16","objectID":"/game-idea-exchange/:3:0","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"解决碰撞冲突(网格搜索) 目前已知物体 A / B, 要交换它们的位置，当某个物体改变位置后如果发生碰撞，我们可以微调目标位置，使其以最小的偏移实现 无碰撞交换 但是微调是一个很暧昧的概念，什么叫微调，移动多远的距离算微调，如果对微调距离不加限制，那么 A/B 呆在原地也恰好不发生碰撞，所以限制微调距离是必要的 Tip\r交换指 位置互换，微调指在一定的 容忍范围 内移动目标位置\r所以我们可以得到一个朴素的假算法 假定有目标位置 $P(x_0, y_0)$, 容忍距离 $d$, 有点集: $$ D = \\lbrace (x, y) | \\sqrt{(x-x_0)^2 + (y-y_0)^2} \u003c d \\rbrace $$ 搜索点集中距离 P 最近并且无碰撞的点作为新的目标位置 上述算法存在几个问题 点集 D 是无穷集合无法枚举 环境的碰撞不是有序的(无法简单的二分) ","date":"2023-01-16","objectID":"/game-idea-exchange/:4:0","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"方法一(网格枚举) 可以使用网格划分 D ，然后由P点到边缘的顺序枚举每一个网格点，并对点其进行 碰撞测试，找到第一个无碰撞的点 记划分粒度为 k, 算法复杂度为 $O(\\frac{d^2}{k^2})$ (可以使用QP 向量来减小碰撞测试的次数) 缺点 网格碰撞, 可能因为空间的整数划分而找不到安全点(可能实际上有安全点) 解决 配合碰撞解算(方法三) ","date":"2023-01-16","objectID":"/game-idea-exchange/:4:1","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"方法二(碰撞解算) 在该方法中, 我们将物体在某一位置的所有碰撞简化为与多条直线的碰撞(直线与法线 N 垂直,并且过点 P) 对于任意碰撞 $c_i$, 可以计算碰撞的 $(QP)_i$ 向量, 我们移动物体解决碰撞的本质是 计算一个 $M_i$ 向量, 该向量在 $(QP)_i$ 方向的投影大于等于 $|(QP)_i|$ $$ \\frac{\\vec{M} \\cdot \\vec{QP}}{|\\vec{QP}|} \\ge |\\vec{QP}| \\\\ \\quad\\\\ \\Rightarrow \\vec{M} \\cdot \\vec{QP} \\ge |\\vec{QP}|^2 $$ 此外还需要满足 M 尽可能地小的约束(确保靠近选中的位置) 所以对于所有的碰撞点: $$ \\begin{cases} \\vec{M} \\cdot \\vec{QP_i} \\ge |\\vec{QP_i}|^2,\\quad i = 1,2,3,…\\\\ \\\\ \\arg \\mathop{\\min}\\limits_{M} |\\vec{QP_i}| \\end{cases} $$ 我们观察上式, 所有的 $QP$ 是已知的, 每一个不等式约束都是一个线性约束设 $M(x, y)$, 每一个约束都是一个关于 $x, y$ 的不等式 所以该问题就转化为了熟悉的不等式约束的优化问题, 优化目标是 $M$ 位移的距离 Tip\r可以使用带 KKT 条件的拉格朗日乘数法来解 M\r","date":"2023-01-16","objectID":"/game-idea-exchange/:4:2","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"线性约束的非线性规划问题 但是优化问题相关的第三方库都是使用迭代的数值优化方法来计算解, 这会导致算法复杂度可能无法预估。 所以这里我们用一个朴素的算法来解决线性约束的非线性规划问题, 算法分成两步: 由于所有的约束都是线性约束, 所以可行域一定是多边形区域(或者开放的凸多边形区域) 最优解的点只会取约束直线上某点或者顶点(不会取可行域内的点) 如何计算 可行域边界 ？ 每个约束条件与其余约束条件计算公共区域(Intercepted 方法) Tips1: 存在线段和射线约束, 需要检查交点是否在线段或者射线上 Tips2：直线的法线代表可行域区域, 可以通过两条直线的方向 和 法线方向判断两线相交分割出的四条射线哪两段是有效的 (见 Intercepted 中判断 Direction 和 Normal 夹角 \u003c= 90\u003e) 线段剪切 Tips3: 线的相交只会缩短端点, 所以需要进行 Max/Min 判断(见 Intercepted) Tips4: 那些 左端点 \u003e= 右端点 的边界视为无效边界( 见SolveCollition 和 Line.IsValid()) 更深层的意思是, 出现无效边时, 可能有以下几种情况(但是只要去除所有无效边即可获得正确的可行域) 线段剪切枚举 得到一个边界集合(元素可能是 直线/线段/射线), 其中某些边界有效, 某些边界无效 对边界集合中所有有效的边界, 计算其与 O(0,0) 点的距离, 并取最小距离，最小距离仅可能以下情况： O 向边界线作垂线的垂足(需要保证垂足再 minT 和 maxT 约束之间) 边界射线端点 边界线段断电 所以, 只需要遍历所有的边界线垂足和边界顶点, 取与 O 最近的点即可 (见 SolveCollition 第二个 for 循环) 该算法复杂度为 $O(n^2)$, 比计算出所有交点, 再检查焦点是否在可行域内的方法($O(n^3)$)更快 public class Line { public Vector2 Point; public Vector2 Normal; public Vector2 Direction; public float minT = float.MinValue; public float maxT = float.MaxValue; public Line(Vector2 _p, Vector2 _n) { Point = _p; Normal = _n; Direction = new Vector2(Normal.y, -Normal.x); } public bool IsRay() =\u003e (minT == float.MinValue \u0026\u0026 maxT != float.MaxValue) || (minT != float.MinValue \u0026\u0026 maxT == float.MaxValue); public bool IsLine() =\u003e minT == float.MinValue \u0026\u0026 maxT == float.MaxValue; public bool IsSegment() =\u003e minT != float.MinValue \u0026\u0026 maxT != float.MaxValue; public bool IsValid() =\u003e minT \u003c= maxT; public Vector2 GetRayPoint() { if (minT == float.MinValue \u0026\u0026 maxT != float.MaxValue) { return Point + maxT * Direction; } if (minT != float.MinValue \u0026\u0026 maxT == float.MaxValue) { return Point + minT * Direction; } return Point; } public Vector2 GetRayDirection() { if (minT == float.MinValue \u0026\u0026 maxT != float.MaxValue) { return -Direction; } if (minT != float.MinValue \u0026\u0026 maxT == float.MaxValue) { return Direction; } return Vector2.Zero; } public void Perpendicular(Vector2 point, out Vector2 foot, out float distance) { Line pLine = new Line(point, this.Direction); Intersect(this, pLine, out float t1, out float t2); foot = pLine.Point + pLine.Direction * t2; if(t1 \u003c= maxT \u0026\u0026 t1 \u003e= minT) distance = (foot - point).Length(); else distance = float.MaxValue; } } static public void Intersect(Line B1, Line B2, out float t1, out float t2) { Vector2 P1 = B1.Point; Vector2 P2 = B2.Point; Vector2 D1 = B1.Direction; Vector2 D2 = B2.Direction; t2 = (D1.y * (P1.x - P2.x) - D1.x * (P1.y - P2.y)) / (D2.x * D1.y - D1.x * D2.y); t1 = (P2.x + t2 * D2.x - P1.x) / D1.x; } static public void Intercepted(ref Line B1, ref Line B2) { Intersect(B1, B2, out float k1, out float k2); if (B1.Direction.Dot(B2.Normal) \u003e= 0) B1.minT = Mathf.Max(k1, B1.minT); else B1.maxT = Mathf.Min(k1, B1.maxT); if (B2.Direction.Dot(B1.Normal) \u003e= 0) B2.minT = Mathf.Max(k2, B2.minT); else B2.maxT = Mathf.Min(k2, B2.maxT); } static public Vector2 SolveCollition(Line[] lines) { for(int i = 0; i \u003c lines.Length; i++) { for (int j = 0; j \u003c i; j++) { Intercepted(ref lines[i], ref lines[j]); } } float distance = float.MaxValue; Vector2 Selected = Vector2.Zero; foreach (var line in lines) { // 跳过无效边 if (!line.IsValid()) continue; // 计算线上垂点 line.Perpendicular(Vector2.Zero, out Vector2 f, out float d); if (d \u003c distance) { Selected = f; distance = d; } // 计算射线起点 if (line.IsRay()) { Vector2 rayPoint = line.GetRayPoint(); if (rayPoint.Length() \u003c distance) { Selected = rayPoint; distance = rayPoint.Length(); } } // 计算线段端点 if (line.IsSegment()) { Vector2 L = line.Point + line.minT * line.Direction; Vector2 R = line.Point + line.maxT * line.Direction; if (L.Length() \u003c distance) { Selected = L; distance = L.Length(); } if (R.Length() \u003c distance) { Selected = R; distance = R.Length(); } } } if (distance != float.MaxValue) return Selected; else return Vector2.Zero; } 最后一个问题 如何将线性规划的约束条件转化为 (Point, Normal) 的形式？ 设 约束条件为 $ax + by \\ge c$, 边界上一点 $(x_0, y_0)$ 边界直线的法线方向有 $(a, b)$ 和 $(-a, -b)$ 两个方向 可以计算得到边界直线外一点 $(x_1, y_1) = (x_0 + a, y_0 + b)$, 将该点带入直线方程 $$ a (x_0 + a) + b(y_0 + b) = (ax_0 + by_0) + a^2 + b^2 = c + (a^2 +","date":"2023-01-16","objectID":"/game-idea-exchange/:4:3","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"方法三(网格划分 + 碰撞解算) 这是一个启发式的方法(没什么依据,乱想的): 使用网格划分, 记每个格点上的所有 QP 的长度之和为 $W = \\sum_i |QP_i|$ 取 W 值最小的格点并在此处执行碰撞解算 ","date":"2023-01-16","objectID":"/game-idea-exchange/:4:4","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"总结 实际上由于不知道物体周围的全部碰撞信息, 碰撞解算并不能避免掉未知的碰撞, 一次碰撞解决后可能引入新的碰撞, 所以基于解算的方法在不知道全局碰撞信息的情况下是不可靠的。 而基于迭代的解算完全不需要使用解算得到的移动方向, 只需要使用当前所有碰撞法线的求和得到移动方向。 所以这篇博客实际上没什么用, 唯一的作用可能是O(n^2)的解决了一个特定的线性规划问题。 确实没什么用？ ","date":"2023-01-16","objectID":"/game-idea-exchange/:5:0","tags":null,"title":"[游戏机制] 交换球","uri":"/game-idea-exchange/"},{"categories":null,"content":"转自知乎 Oculus应该卖给谁？好大的一个问题啊。 卖给谁都可以，但就是不该卖给Facebook！ 卖给Apple多合适，那里有全世界最好的消费电子产品。卖给Google也不错，安卓系统逐渐统治世界，Google眼镜刚被《时代》杂志评为那一年最令人期待的硬件产品。 还可以选微软，VR（Virtual Reality，虚拟现实）最直观的使用场景就是游戏，这和微软Xbox游戏机一脉相承。就连亚马逊，好歹也做出了Kindle，在人类出版界放了一场大火。 再看看Facebook呢？一点做硬件的经验都没有。扎克伯格(Mark Zuckerberg)曾经放出狠话要做手机，折腾了半天，只是竹篮打水一场空。 不仅如此，Oculus还非常不facebook。CTO压根没有Facebook账户，CEO的办公室里赫然挂着一副对Facebook不敬的工艺品，员工把嘲笑Facebook当作工作的日常，FB是一个典型的反面教材：僵化的公司、糟糕的设计、隐私的小偷。 当扎克伯格千里迢迢来拜访Oculus全体员工，一位叫Dycus的员工，当着全公司的面问小扎：很多人（当然，不包括我哈），都觉得Facebook是邪恶的（Facebook is evil），你觉得，这会怎么影响Oculus的形象？ 图：戴着Oculus的扎克伯格 但是扎克伯格却像被施了法术，对Oculus着了魔。 扎克伯格带着Facebook一众高管轮流戴了一会Oculus的VR头盔。 当时还只是样品，距离成品上市，还有很远的距离。即使到了今天，VR头盔都没有克服最大的bug——晕眩。更别说7年前了。小扎卸下头盔的刹那，估计和学生时代在哈佛大学通宵宿醉后一样的难受，但是，小扎连同CTO和负责产品的VP，对这个新奇的玩意赞不绝口，反复说着：holy crap（专业翻译：我X, NB啊）。 5天后，这位全球最大社交网络的管理者亲自去了这家创业公司的办公室。 这一天，这位全世界最富有的80后背了一个麦当劳的购物袋。这真是神来之笔。本来对Facebook没有一点好感的年轻极客们，瞬间议论纷纷：真是没想到，互联网超级大佬，原来是和我一样的人。 在狠狠拉了一波好感值后，扎克伯格为这家创办仅仅2年的公司开出了无法拒绝的价码——30亿美元。以及反复的劝诱和许诺：Oculus会成为Facebook唯一的平台，我要让Oculus成为VR的领导者！ 怎么拉近资本和创业者的距离，小扎可能是全世界最懂这件事的人。当年Facebook刚刚成立，小扎要去红杉资本的办公室谈融资。在肖恩·帕克（Sean Parker）的教唆下，他穿着睡衣走进了高大上的办公室。 西装革履的中年油腻男被挑逗得欲火焚身，这才是TMD真极客！投他，必须投他！ 那只麦当劳的手提袋，很难说不是一场精心设计的轮回。这位哈佛辍学生，有一个木讷的外表，以至于常常让我们忽略了他极其精明和复杂的内心世界。 但是。 搞VR？！你还是想想清楚吧，这个专门绞杀科技巨头的战场，早已白骨累累。 01 从弗兰克鲍姆的《万能钥匙》到赫胥黎的《美丽新世界》，从伍迪艾伦的《沉睡者》（1973年），到斯皮尔伯格的《头号玩家》（2018年），VR（虚拟现实）是所有科幻小说、科幻电影的必备元素。 带上一套装备，通过视觉、嗅觉、触觉，让人走进一个完全虚拟的世界。还有比这更cool的科技产品吗？ 斯皮尔伯格的电影《头号玩家》主题就是一个VR游戏 写出《数字化生存》的MIT（麻省理工）教授尼葛洛庞帝说，他从1969年就开始关注VR。 没错，在连彩色电视机都没有普及的60年代，真极客们就已经在尝试做VR头盔。90年代，任天堂、世嘉，以及乔布斯实习过的雅达利，先后对着VR设备，大搞特搞。 世嘉（SEGA）搞得最轰动。产品宣传了三年，发布会开了又开，《大众科技》的杂志封面也如愿登过了。结果，临门一脚，突然宣布不发布了，放了全世界一个大鸽子。世嘉的理由是：VR游戏太过真实，玩家在游戏过程中不由自主地移动，容易受伤。 拉倒吧。 受伤是真的，但不是因为移动，而是因为晕眩导致的恶心头疼。VR营造了一个深度沉浸的世界，如果技术跟不上，虚拟画面和现实动作有延时，会造成严重的晕眩，类似现实中的晕车。 从此，晕眩感成为横亘在VR产业面前的一道天堑，或者说一道魔咒。人类科技界对VR的第一次攻关，以被团灭的方式告终。 紧接着，互联网来了。亚马逊、Google先后问世，那些利用互联网连接存量资源，那些消费主义的迎合者，成了硅谷的新宠。 时代换了一批新的宾客，但是极客的火苗没有完全熄灭。把科幻小说里最cool的装备变成现实，也是科技新贵的梦。 Google先做AR(Augmented reality，增强现实)，谷歌眼镜（Google Glass）才出了几张宣传照，全世界科技迷就自嗨到了高潮，不仅有英国王子这样的社会名流野生代言，而且频频被各类媒体评价为人类最具创新、最值得期待的产品。Google又感动又兴奋，再接再厉做了一个VR的平台Daydream，满腔热血期待复制一个安卓的神话。 三星，作为当时全球出货量第一的手机品牌，也狠狠表示了一把，弄出个Gear VR。但是，Google眼镜、Daydream，GearVR，全部火不过两年，最终销声匿迹。 目前为止，人类最重要的硬件还是智能手机。Google和三星是这个行业绝对的领导者，在产业链里是一呼百应。那么强的能力，那么厚的背景，在VR行业也不过是碰一鼻子灰，羞羞地找个台阶下。 这就是Facebook收购Oculus的背景。在硅谷，Facebook的标签是侵犯隐私、抄袭模仿、功利主义，这样的扎克伯格可能做出人类最新奇的硬件吗？ 02 2016年，小扎正在为Facebook进入中国努力。顶着大雾霾，毅然决然地在天安门前跑步，是个又红又专的好少年。 那次扎克伯格来北京，目的是参加由国务院发展研究中心主办的中国发展高层论坛。 93岁的基辛格老爷子做了《避免修昔底德陷阱》的演讲，接下来就是扎克伯格和马云的谈话。扎克伯克表示，前两年我收购了Oculus，今年会推出一款VR头盔，今年消费级VR就会爆发，五到十年之后，VR手机会成为市场主流。 马云说，行啊，我会帮你。 其实，不只是姓赵。姓马，也是有鄙视链的。 就拿马克·扎克伯格、马云、马斯克来说。 小扎像个中国人，场面上说话一定圆滑，不轻易得罪人。和马云聊天客客气气的，上来先介绍自己正在学习中文，但是还很糟，所以辛苦马云今天用英语交流，谢谢大家的理解。 你再看看马斯克？那副得瑟劲。同样是来中国参加对话，马斯克一点不给马老师面子，把马氏鸡汤里的逻辑矛盾、事实错误全指了出来。喜欢阿里的人千万别放心上，其实玩硬核科技的马斯克最看不起的人，是马克·扎克伯格。马斯克不带修饰地说过：Facebook垃圾（Facebook sucks），窃取隐私、只会垄断，扎克伯格小朋友对于AI一无所知……然后，以身作则地把自己的Facebook账户注销了。 小扎心里是真苦啊。Facebook是全世界市值前五的互联网公司，说起来有头有脸，但是收入的95%都是广告。扎克伯格气不过的时候也想回怼两句，但是射火箭、卖电动的马斯克恐怕要怼一句更厉害的回来，“你个卖广告的，装什么B”，那年轻的小扎又要气得几天睡不着觉了。 马家人的鄙视链说到底就是一句话：互联网企业压根不是科技公司。 清醒点，好不好，你不过是做了一个网页，因为上线得足够早，早早占了个好坑，很多人用。形成了平台，形成了垄断，独占了数据，仅此而已。巴西男足踢中国男足，即使教练席栓一条狗，也能赢。是的，仅此而已。这怎么能配叫高科技？ 在马斯克眼中，扎克伯格就是这种不配的典型。 这就是扎克伯格坚持做VR的第二个背景。 何止是Google、三星，中国也多的是利用VR吹牛逼的大公司。就在扎克伯格和马云亲切交谈的那一年，阿里推出VR购物 “Buy＋”，目标是利用VR让网购变成逛商场的模样。另一个大手笔是领投了美国很火的AR创业公司Magic Leap，7.94亿美元的融资。 同一年，马化腾也给VR站过台，“VR是一场大洗牌，即将开始。就像移动互联网转型一样，上不了船的人将逐渐落伍”。当年由微信引发的“船票论”再次甚嚣尘上。据说腾讯启动了多款VR游戏的制作。还扬言也像Facebook一样做VR硬件，连原型机都搞出来了。然后，就没有然后了。 VR这件事，科技感爆棚，但是每次一燃，就会被泼下一盆又一盆的冷水。归根结底，有这样几个过不去的坎——晕动症、功能单一、缺乏优质内容、设备臃肿、价格昂贵…… 没过多久，Google、三星、阿里、腾讯都撤了，它们都不过是匆匆的过客，都没有成为推动行业前进的力量。 意外的是扎克伯格却固执地坚持了一下。 为什么？ 往低了说，是守护Facebook的社交边界。扎克伯格这个人，永远在警惕Facebook可能的颠覆者。Facebook的入职手册中，写着这样一句话：如果我们不去创造出能杀死Facebook的产品，有人会去做。 马化腾也表示过，VR/AR很可能是下一代社交，颠覆微信的那一种。 的确，微信毕竟只是一个平面的聊天框。用脚趾头就能想明白，如果VR创建一个虚拟space，渣男撩妹的空间会大很多很多。 Facebook开发的VR社交平台Horizon 往高了说，扎克伯格就是憋了一口气，去TMD马家人鄙视链。我要亲自证明Facebook的科技感——我来做一个新硬件，我来扩展人类的边界，我来打碎虚拟世界和现实世界的这面墙。 你们给我看清楚了。 03 扎克伯格有个枯燥且乏味的爱好——寻访有社交竞争力的创业公司，和创始人一见如故，再开一个你无法say no的条件，接着带你飞一段，然后闹掰，最终交恶。 扎克伯格先后收购Instagr","date":"2023-01-03","objectID":"/zhuan-zai-vr-che-diao-liao-zhong-guo-ke-ji-quan-de-zhe-xiu-bu/:0:0","tags":null,"title":"[转载] VR 扯掉了中国科技圈的遮羞布","uri":"/zhuan-zai-vr-che-diao-liao-zhong-guo-ke-ji-quan-de-zhe-xiu-bu/"},{"categories":null,"content":"原文 当今互联网到处存在着一些中间件(Middle Boxes),如NAT和防火墙,导致两个(不在同一内网)中的客户端无法直接通信. 这些问题即便是到了IPV6时代也会存在,因为即使不需要NAT,但还有其他中间件如防火墙阻挡了链接的建立. 目前部署的中间件多都是在C/S架构上设计的,其中相对隐匿的客户机主动向周知的服务端(拥有静态IP地址和DNS名称)发起链接请求. 大多数中间件实现了一种非对称的通讯模型,即内网中的主机可以初始化对外的链接,而外网的主机却不能初始化对内网的链接, 除非经过中间件管理员特殊配置. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:0:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"前言 在中间件为常见的NAPT的情况下（也是本文主要讨论的）,内网中的客户端没有单独的公网IP地址, 而是通过NAPT转换,和其他同一内网用户共享一个公网IP. 这种内网主机隐藏在中间件后的不可访问性对于一些客户端软件如浏览器来说 并不是一个问题,因为其只需要初始化对外的链接,从某方面来看反而还对隐私保护有好处. 然而在P2P应用中, 内网主机（客户端）需要对另外的终端（Peer）直接建立链接,但是发起者和响应者可能在不同的中间件后面, 两者都没有公网IP地址. 而外部对NAT公网IP和端口主动的链接或数据都会因内网未请求被丢弃掉. 本文讨论的就是如何跨越NAT实现内网主机直接通讯的问题. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:1:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"一些术语 ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"防火墙(Firewall) 防火墙主要限制内网和公网的通讯,通常丢弃未经许可的数据包. 防火墙会检测(但是不修改)试图进入内网数据包的IP地址和TCP/UDP端口信息. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:1","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"网络地址转换器(NAT) NAT不止检查进入数据包的头部,而且对其进行修改,从而实现同一内网中不同主机共用更少的公网IP（通常是一个）. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:2","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"基本NAT(Basic NAT) 基本NAT会将内网主机的IP地址映射为一个公网IP,不改变其TCP/UDP端口号. 基本NAT通常只有在当NAT有公网IP池的时候才有用. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:3","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"网络地址-端口转换器(NAPT) 到目前为止最常见的即为NAPT,其检测并修改出入数据包的IP地址和端口号,从而允许多个内网主机同时共享一个公网IP地址. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:4","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"锥形NAT(Cone NAT) 在建立了一对（公网IP,公网端口）和（内网IP,内网端口）二元组的绑定之后,只要还有一个会话还是激活的,Cone NAT会重用这组绑定用于接下来该应用程序的所有会话（同一内网IP和端口）. 例如,假设客户端A建立了两个连续的对外会话,从相同的内部端点（10.0.0.1:1234）到两个不同的外部服务端S1和S2. Cone NAT只为两个会话映射了一个公网端点（155.99.25.11:62000）, 确保客户端端口的“身份”在地址转换的时候保持不变. 由于基本NAT和防火墙都不改变数据包的端口号,因此这些类型的中间件也可以看作是退化的Cone NAT. Server S1 Server S2 18.181.0.31:1235 138.76.29.7:1235 | | | | +----------------------+----------------------+ | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 155.99.25.11:62000 v | v 155.99.25.11:62000 v | Cone NAT 155.99.25.11 | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 10.0.0.1:1234 v | v 10.0.0.1:1234 v | Client A 10.0.0.1:1234 其中Cone NAT根据NAT如何接收已经建立的（公网IP,公网端口）对的输入数据还可以细分为以下三类： 1. 全锥形NAT(Full Cone NAT) 在一个新会话建立了公网/内网端口绑定之后,全锥形NAT接下来会接受对应公网端口的所有数据,无论是来自哪个（公网）终端. 全锥NAT有时候也被称为“混杂”NAT（promiscuous NAT）. 2. 受限锥形NAT(Restricted Cone NAT) 受限锥形NAT只会转发符合某个条件的输入数据包. 条件为：外部（源）IP地址匹配内网主机之前发送一个或多个数据包的结点的IP地址. AT通过限制输入数据包为一组“已知的”外部IP地址,有效地精简了防火墙的规则. 3. 端口受限锥形NAT(Port-Restricted Cone NAT) 端口受限锥形NAT也类似,只当外部数据包的IP地址和端口号都匹配内网主机发送过的地址和端口号时才进行转发. 端口受限锥形NAT为内部结点提供了和对称NAT相同等级的保护,以隔离未关联的数据. 4. 对称NAT(Symmetric NAT) 对称NAT正好相反,不在所有公网-内网对的会话中维持一个固定的端口绑定. 其为每个新的会话开辟一个新的端口. 如下图所示： Server S1 Server S2 18.181.0.31:1235 138.76.29.7:1235 | | | | +----------------------+----------------------+ | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 155.99.25.11:62000 v | v 155.99.25.11:62001 v | Symmetric NAT 155.99.25.11 | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 10.0.0.1:1234 v | v 10.0.0.1:1234 v | Client A 10.0.0.1:1234 ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:5","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"P2P通信技术 根据客户端的不同,客户端之间进行P2P传输的方法也略有不同,这里介绍了现有的穿越中间件进行P2P通信的几种技术. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"中继（Relaying） 这是最可靠但也是最低效的一种P2P通信实现. 其原理是通过一个有公网IP的服务器中间人对两个内网客户端的通信数据进行中继和转发. 如下图所示： Server S | | +----------------------+----------------------+ | | NAT A NAT B | | | | Client A Client B 客户端A和客户端B不直接通信,而是先都与服务端S建立链接,然后再通过S和对方建立的通路来中继传递的数据. 这钟方法的缺陷很明显, 当链接的客户端变多之后,会显著增加服务器的负担,完全没体现出P2P的优势. 但这种方法的好处是能保证成功,因此在实践中也常作为一种备选方案. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:1","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"逆向链接（Connection reversal） 第二种方法在当两个端点中有一个不存在中间件的时候有效. 例如,客户端A在NAT之后而客户端B拥有全局IP地址,如下图： Server S 18.181.0.31:1235 | | +----------------------+----------------------+ | | NAT A | 155.99.25.11:62000 | | | | | Client A Client B 10.0.0.1:1234 138.76.29.7:1234　客户端A内网地址为10.0.0.1,且应用程序正在使用TCP端口1234. A和服务器S建立了一个链接,服务器的IP地址为18.181.0.31,监听1235端口. NAT A给客户端A分配了TCP端口62000,地址为NAT的公网IP地址155.99.25.11, 作为客户端A对外当前会话的临时IP和端口. 因此S认为客户端A就是155.99.25.11:62000. 而B由于有公网地址,所以对S来说B就是138.76.29.7:1234. 当客户端B想要发起一个对客户端A的P2P链接时,要么链接A的外网地址155.99.25.11:62000,要么链接A的内网地址10.0.0.1:1234,然而两种方式链接都会失败. 链接10.0.0.1:1234失败自不用说,为什么链接155.99.25.11:62000也会失败呢？来自B的TCP SYN握手请求到达NAT A的时候会被拒绝,因为对NAT A来说只有外出的链接才是允许的. 在直接链接A失败之后,B可以通过S向A中继一个链接请求,从而从A方向“逆向“地建立起A-B之间的点对点链接. 很多当前的P2P系统都实现了这种技术,但其局限性也是很明显的,只有当其中一方有公网IP时链接才能建立. 越来越多的情况下, 通信的双方都在NAT之后,因此就要用到我们下面介绍的第三种技术了. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:2","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"UDP打洞（UDP hole punching） 第三种P2P通信技术,被广泛采用的,名为“P2P打洞“. P2P打洞技术依赖于通常防火墙和Cone NAT允许正当的P2P应用程序在中间件中打洞且与对方建立直接链接的特性. 下面主要考虑两种常见的场景,以及应用程序如何设计去完美地处理这些情况. 第一种场景代表了大多数情况,即两个需要直接链接的客户端处在两个不同的NAT之后； 第二种场景是两个客户端在同一个NAT之后,但客户端自己可能并不知道(比如同一ISP下面的不同子网). 端点在不同的NAT之后 假设客户端A和客户端B的地址都是内网地址,且在不同的NAT后面. A、B上运行的P2P应用程序和服务器S都使用了UDP端口1234,A和B分别初始化了 与Server的UDP通信,地址映射如图所示: Server S 18.181.0.31:1234 | | +----------------------+----------------------+ | | NAT A NAT B 155.99.25.11:62000 138.76.29.7:31000 | | | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 现在假设客户端A打算与客户端B直接建立一个UDP通信会话. 如果A直接给B的公网地址138.76.29.7:31000发送UDP数据,NAT B将很可能会无视进入的 数据（除非是Full Cone NAT）,因为源地址和端口与S不匹配,而最初只与S建立过会话. B往A直接发信息也类似. 假设A开始给B的公网地址发送UDP数据的同时,给服务器S发送一个中继请求,要求B开始给A的公网地址发送UDP信息. A往B的输出信息会导致NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话,B往A亦然. 一旦新的UDP会话在两个方向都打开之后,客户端A和客户端B就能直接通讯, 而无须再通过引导服务器S了. UDP打洞技术有许多有用的性质. 一旦一个的P2P链接建立,链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞, 极大减少了服务器的负载. 应用程序不需要知道中间件具体是什么（如果有的话）,因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路. 端点在相同的NAT之后 现在考虑这样一种情景,两个客户端A和B正好在同一个NAT之后（而且可能他们自己并不知道）,因此在同一个内网网段之内. 客户端A和服务器S建立了一个UDP会话,NAT为此分配了公网端口62000,B同样和S建立会话,分配到了端口62001,如下图： Server S 18.181.0.31:1234 | | NAT A-S 155.99.25.11:62000 B-S 155.99.25.11:62001 | +----------------------+----------------------+ | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 假设A和B使用了上节介绍的UDP打洞技术来建立P2P通路,那么会发生什么呢？首先A和B会得到由S观测到的对方的公网IP和端口号,然后给对方的地址发送信息. 两个客户端只有在NAT允许内网主机对内网其他主机发起UDP会话的时候才能正常通信,我们把这种情况称之为\"回环传输“(loopback transmission),因为从内部 到达NAT的数据会被“回送”到内网中而不是转发到外网. 例如,当A发送一个UDP数据包给B的公网地址时,数据包最初有源IP地址和端口地址10.0.0.1:1234和 目的地址155.99.25.11:62001,NAT收到包后,将其转换为源155.99.25.11:62000（A的公网地址）和目的10.1.1.3:1234,然后再转发给B. 即便NAT支持 回环传输,这种转换和转发在此情况下也是没必要的,且有可能会增加A与B的对话延时和加重NAT的负担. 对于这个情况,优化方案是很直观的. 当A和B最初通过S交换地址信息时,他们应该包含自身的IP地址和端口号（从自己看）,同时也包含从服务器看的自己的 地址和端口号. 然后客户端同时开始从对方已知的两个的地址中同时开始互相发送数据,并使用第一个成功通信的地址作为对方地址. 如果两个客户端在同一个 NAT后,发送到对方内网地址的数据最有可能先到达,从而可以建立一条不经过NAT的通信链路；如果两个客户端在不同的NAT之后,发送给对方内网地址的数据包 根本就到达不了对方,但仍然可以通过公网地址来建立通路. 值得一提的是,虽然这些数据包通过某种方式验证,但是在不同NAT的情况下完全有可能会导致A往B 发送的信息发送到其他A内网网段中无关的结点上去的. 端点在多级NAT之后 在一些拓朴结构中,可能会存在多级NAT设备,在这种情况下,如果没有关于拓朴的具体信息, 两个Peer要建立“最优”的P2P链接是不可能的,下面来说为什么. 以下图为例： Server S 18.181.0.31:1234 | | NAT X A-S 155.99.25.11:62000 B-S 155.99.25.11:62001 | | +----------------------+----------------------+ | | NAT A NAT B 192.168.1.1:30000 192.168.1.2:31000 | | | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 假设NAT X是一个网络提供商ISP部署的工业级NAT,其下子网共用一个公网地址155.99.25.11,NAT A和NAT B分别是其下不同用户的网关部署的NAT. 只有服务器S 和NAT X有全局的路由地址. Client A在NAT A的子网中,同时Client B在NAT B的子网中,每经过一级NAT都要进行一次网络地址转换. 现在假设A和B打算建立直接P2P链接,用一般的方法（通过Server S来打洞）自然是没问题的,那能不能优化呢？一种想当然的优化办法是A直接把信息发送给NAT B的 内网地址192.168.1.2:31000,且B通过NAT B把信息发送给A的路由地址192.168.1.1:30000,不幸的是,A和B都没有办法得知这两个目的地址,因为S只看见了客户端 ‵全局‵地址155.99.25.11. 退一步说,即便A和B通过某种方法得知了那些地址,我们也无法保证他们是可用的. 因为ISP分配的子网地址可能和NAT A B分配的子网地址 域相冲突. 因此客户端没有其他选择,只能使用S来进行打洞并进行回环传输. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:3","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"固定端口绑定 UDP打洞技术有一个主要的条件：只有当两个NAT都是Cone NAT（或者非NAT的防火墙）时才能工作. 因为其维持了一个给定的（内网IP,内网UDP）二元组 和（公网IP, 公网UDP）二元组固定的端口绑定,只要该UDP端口还在使用中,就不会变化. 如果像对称NAT一样,给每个新会话分配一个新的公网端口,就 会导致UDP应用程序无法使用跟外部端点已经打通了的通信链路. 由于Cone NAT是当今最广泛使用的,尽管有一小部分的对称NAT是不支持打洞的,UDP打洞 技术也还是被广泛采纳应用. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:4","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"具体实现 一般的网络编程,都是客户端比服务端要难,因为要处理与服务器的通信同时还要处理来自用户的事件；对于P2P客户端来说更是如此,因为P2P客户端不止作 为客户端,同时也作为对等连接的服务器端. 这里的大体思路是,输入命令传输给服务器之后,接收来自服务器的反馈,并执行相应代码. 例如A想要与B建立 通信链路,先给服务器发送punch命令以及给B发送数据,服务器接到命令后给B发送punch_requst信息以及A的端点信息,B收到之后向A发送数据打通通路,然 后A与B就可以进行P2P通信了. 经测试,打通通路后即便把服务器关闭,A与B也能正常通信. 一个UDP打洞的例子见P2P-Over-MiddleBoxes-Demo ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:4:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"TCP打洞(TCP Hole Punching) 关于TCP打洞,有一点需要提的是,因为TCP是基于连接的,所以任何未经连接而发送的数据都会被丢弃,这导致在recv的时候是无法直接从peer端读取数据. 其实这对UDP也一样,如果对UDP的socket进行了connect,其也会忽略连接之外的数据,详见connect(2). 所以,如果我们要进行TCP打洞,通常需要重用本地的endpoint来发起新的TCP连接,这样才能将已经打开的NAT利用起来. 具体来说,则是要设置socket的 SO_REUSEADDR或SO_REUSEPORT属性,根据系统不同,其实现也不尽一致. 一般来说,TCP打洞的步骤如下： A 发送 SYN 到 B(出口地址,下同）,从而创建NAT A的一组映射 B 发送 SYN 到 A, 创建NAT B的一组映射 根据时序不同,两个SYN中有一个会被对方的NAT丢弃,另一个成功通过NAT 通过NAT的SYN报文被其中一方收到,即返回SYNACK, 完成握手 至此,TCP的打洞成功,获得一个不依赖于服务器的链接 由于TCP连接是由操作系统控制的, 而不是由应用控制的, 而且TCP包的序列号是随机生成, 所以TCP打洞的成功率就相对较低. 因此如果NAT对接收到的包进行TCP序列号检测时若没有现有的连接可以对应, 该TCP包很可能会被NAT丢弃掉. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:5:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"脚本语言是快速编写富有弹性的代码的重要方法之一，在 Unix 系统自动化管理中已经应用了多种脚本语言。现在，在许多应用开发中，也提供了脚本层，这大大方便用户实现通用任务自动处理或者编写应用扩展，许多成功的应用，诸如 GIMP、Emacs、MS Office、PhotoShop、AutoCAD 等都应用了脚本技术。在某种意义上，一切皆可脚本化。 在另一篇文章中，我们已经介绍了如何在 C 应用中嵌入 Python 语言，通过这项技术，可以让应用的高级用户来修改或定制化他们的程序，你可以充分利用 Python 的语言能力而不用自己去实现嵌入语言。Python 是一个不错的的选择，因为它提供了干净直观的 C 语言 API。关于如何在 C 应用中嵌入 Python 解释器，你可以参考：让Python成为嵌入式语言一文。 现在我们来更深入地探讨一些问题。 鉴于许多复杂的应用都会利用多线程技术，本文将着重介绍如何创建线程安全的界面来调用Python解释器。 这里的所有例子都是用 Python 2.7.2，所有的 Python 函数都以extern “C”定义，因此对于 C 和 C++，其使用是别无二致的。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:0:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"Python C 和线程 在C程序中创建执行线程是很简单的。在 Linux 中，通常的做法是使用 POSIX 线程（pthread) API 并调用 pthread_create 函数。关于如何使用 pthreads，你可以参考 Felix Garcia 和Javier Fernandez 著的 “POSIX Thread Libraries”一文。为了支持多线程， Python 使用了互斥使访问内部数据结构串行化。这种互斥即 “全局解释器锁 – global interpreter lock”，当某个线程想使用 Python 的C API的时候，它必须获得 全局解释器锁，这避免了会导致解析器状态崩溃的竞争条件（race condition)。 互斥的锁定和释放是通过 PyEval_AcquireLock 和 Eval_ReleaseLock 来描述的。调用了 PyEval_AcquireLock 之后，可以安全地假定你的线程已经持有了锁，其他相关线程不是被阻塞就是在执行与 Python 解析器无关的代码。现在你可以任意调用 Python 函数了。一旦取得了锁，你必须确保调用 PyEval_ReleaseLock 来释放它，否则就会导致线程死锁并冻结其他 Python 线程。 更复杂的情况是，每个运行 Python 的线程维护着自己的状态信息。这些和特定线程相关的数据存储在称为 PyThreadState 的对象中。当在多线程应用中用 C 语言调用 Python API 函数时，你必须维护自己的 PyThreadState 对象以便能安全地执行并发的 Python 代码。 如果你对开发多线程应用相当有经验，你可能会发现全局解释器锁的概念相当不方便。不过，现在它已经不像首次出现时那样糟糕了。当 Python 对脚本进行解释时，它会定期切换出当前 PyThreadState 对象并释放全局解释器锁，从而将控制权释放给其他线程。之前被阻塞的线程可以试图锁定全局解释器锁从而被运行。有些时候，原来的线程会再次获得全局解释器锁再次切回解释器。 这意味着当调用 PyEval_SimpleString 时，即使你持有全局解释器锁，其他线程仍有机会被执行，这样的副作用无可避免。另外，当你调用以 C 语言写就的 Python 模块（包括许多内置模块） 存在着将控制权释放给其他线程的可能性。基于这个原因，当你用两个 C 线程来执行计算密集的 Python 脚本，它们确实能分享 CPU 时间并发运行，但由于全局解释器锁的存在，在多处理器的计算机上，Python 无法通过线程充分计算机的 CPU 处理能力。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:1:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"启用线程支持 在多线程的 C 程序使用 Python API 之前，必须调用一些初始化例程。如果编译解释器库时启用了多线程支持（通常情况如此），你就有了一个是否启用线程的运行时选项。除非你计划使用线程，否则不建议启用该选项。未启用该选项，Python 可以避免因互斥锁定其内部数据结构而产生的系统开销。但是如果你打算用 Python 来扩展多线程应用，你就需要在初始化解释器的时候启用线程支持。我个人建议，应该在主线程执行时就初始化 Python，最好是在应用程序启动的时候，就调用下面两行代码： // initialize Python Py_Initialize(); // initialize thread support PyEval_InitThreads(); 这两个函数都返回 void，所以无需检查错误代码。现在，我们可以假定 Python 解释器已准备好执行 Python 代码。Py_Initialize 分配解释器库使用的全局资源。调用PyEval_InitThreads 则启用运行时线程支持。这导致 Python 启用其内部的互斥锁机制，用于解释器内代码关键部分的系列化访问。此函数的另一个作用是锁定全局解释器锁。该函数完成后，需要由用户负责释放该锁。不过，在释放锁之前, 你应该捕获当前 PyThreadState 对象的指针。后续创建新的 Python 线程以及结束使用 Python 时要正确关闭解释器，都需要用到该对象。下面这段代码用来捕获 PyThreadState 对象指针: PyThreadState * mainThreadState = NULL; // save a pointer to the main PyThreadState object mainThreadState = PyThreadState_Get(); // release the lock PyEval_ReleaseLock(); ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:2:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"创建新的执行线程 在 Python 里，每个执行 Python 代码的线程都需要一个 PyThreadState 对象。解释器使用此对象来管理每个线程独立的数据空间。理论上，这意味着一个线程中的动作不会牵涉到另一个线程的状态。例如，你在一个线程中抛出异常，其他 Python 代码片段仍会继续运行，就好象什么事情都没有发生一样。你必须帮助 Python 管理每个线程的数据。为此，你需要为每个执行 Python 代码的 C 线程手工创建一个 PyThreadState 对象.要创建 PyThreadState 对象，你需要用到既有的 PyInterpreterState 对象。PyInterpreterState 对象带有为所有参与的线程所共享的信息。当你初始化 Python 时，它就会创建一个 PyInterpreterState 对象，并将它附加在主线程的 PyThreadState 对象上。你可以使用该解释器对象为你自己的 C 现成创建新的 PyThreadState。请参考下面代码 // get the global lock PyEval_AcquireLock(); // get a reference to the PyInterpreterState PyInterpreterState * mainInterpreterState = mainThreadState-\u003einterp; // create a thread state object for this thread PyThreadState * myThreadState = PyThreadState_New(mainInterpreterState); // free the lock PyEval_ReleaseLock(); ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:3:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"执行 Python 代码 现在我们已创建 PyThreadState 对象，你的 C 线程就可以开始使用 Python API 执行 Python 脚本。从 C 线程执行 Python 代码时，你必须遵守一些简单的规则。首先，您在进行任何会改变当前线程状态的操作前必须持有全局解释器锁。第二，必须在执行任何 Python 代码之前，必须将该线程特定的 PyThreadState 对象加载到解释器。一旦您已经满足这些条件，您可以通过诸如 PyEval_SimpleString 函数来执行任意的 Python 代码，并记得在执行结束时切出 PyThreadState 对象并释放全局解释器锁。请参考下面代码，注意代码中“锁定、 切换、 执行、 切换，解锁”的对称关系： // grab the global interpreter lock PyEval_AcquireLock(); // swap in my thread state PyThreadState_Swap(myThreadState); // execute some python code PyEval_SimpleString(\"import sys\\n\"); PyEval_SimpleString(\"sys.stdout.write(‘Hello from a C thread!\\n‘)\\n\"); // clear the thread state PyThreadState_Swap(NULL); // release our hold on the global interpreter PyEval_ReleaseLock(); ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:4:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"清除线程 一旦你的 C 线程不再需要 Python 解释器，你必须释放相关资源。为此，需要删除该线程的 PyThreadState 对象，相关代码如下： // grab the lock PyEval_AcquireLock(); // swap my thread state out of the interpreter PyThreadState_Swap(NULL); // clear out any cruft from thread state object PyThreadState_Clear(myThreadState); // delete my thread state object PyThreadState_Delete(myThreadState); // release the lock PyEval_ReleaseLock(); 通过使用 Python API ，这个线程很有效率地完成了上述工作。现在你可以安全地调用 pthread_ext 来结束该线程的运行。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:5:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"关闭解释器 一旦应用不在需要 Python 解释器，你可以用下面的代码将 Python 关闭掉： // shut down the interpreter PyEval_AcquireLock(); Py_Finalize(); 注意：因为 Python 已经被关系，这里就不需要释放锁。请确保在调用 Py_Finalize 之前用 PyThreadState_Clear 和 PyThreadState_Delete 删除掉所有线程状态对象。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:6:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"小结： 作为嵌入式语言，Python 是一个不错的选择。Python 解释器同时支持嵌入和扩展，它允许 C 应用程序代码和嵌入的 Python 脚本之间的双向通信。此外，多线程支持促进了与多线程应用程序的集成，而且不影响性能。 你可以从本文的后面下载有关案例Python embedded HTTP Server (29)，该案例实现了一个内嵌 Python 解释器的多线程 HTTP 服务器。此外我推荐您去 http://www.python.org/docs/api/ 阅读有关的 Python C API 文档。另外 Python 解释器本身的代码也是一个很有价值的参考。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:7:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"参考列表 Python embedding c++多线程调用python yolov7-ncnn Yolo-FastestV2 ncnn教程 ncnn 环境 opencv之Mat格式数据转换成onnxruntime的输入tensor处理的c++写法 Tracker - Norfair FPS游戏的鼠标灵敏度换算方法 phoboslab/jsmpeg-vnc 桌面复制 API - Win32 apps | Microsoft Learn桌面复制 API - Win32 apps | Microsoft Learn 最近看到有些 FPS 游戏主播被锤外挂，不禁有些感叹 人菜逼事多。所以产生了研究AI自瞄原理的想法。首先做AI自瞄不是想开挂，而是对于反外挂而言 只有了解Hacker才能Anti-Hacker。 ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:0:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"总体思路 传统的 FPS 游戏外挂需要读内存、改内存，因此很容易被检测。而 AI 自瞄只读取游戏画面(可以通过屏幕捕获、外置摄像头)，通过目标检测方法 准确的识别出游戏中的目标的类型和位置，然后通过各种移动准星的方法将准星移动到目标位置，AI 自瞄系统应该仅提供基础设施（识别系统、脚本系统、配置系统），玩家可以自定义视频输入方式，通过脚本系统定义 “如何瞄准敌人”（添加抖动等），定义识别系统的参数。 // 为了高效运行，外挂的运行时使 C/C++，脚本系统使用 Python / C# 但是，将屏幕捕获交给玩家会加重识别系统的的任务（识别敌人 + 识别屏幕），再加上坐标变换后降低了准确度，为了使识别准确度尽可能提高，将采用捕获屏幕作为输入。 github 项目地址 ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:1:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"读取游戏画面 windows 屏幕抓取技术总结 总结了windows 下各个平台的屏幕抓取性能开销对比，但是和我实测的数据有些偏差，在我实测中 DXGI 几乎不消耗 CPU/GPU 资源，GDI方案消耗大量的 CPU 资源。但是在启动了 APEX 的情况下 DXGI 仅能达到 90fps， GDI 能达到 200fps，所以我们的方案采用 GDI 方法，GDI 抓屏参考(几乎是copy)了 phoboslab/jsmpeg-vnc: A low latency, high framerate screen sharing server for Windows and client for browsers 的grabber方法，并且取得很高的效率。 #ifndef GRABBER_H #define GRABBER_H #define WIN32_LEAN_AND_MEAN #include \u003cWindows.h\u003e typedef struct { int x, y, width, height; } grabber_crop_area_t; typedef struct { HWND window; HDC windowDC; HDC memoryDC; HBITMAP bitmap; BITMAPINFOHEADER bitmapInfo; int width; int height; void *pixels; grabber_crop_area_t crop; } grabber_t; grabber_t *grabber_create(HWND window, grabber_crop_area_t crop); void grabber_destroy(grabber_t *self); void *grabber_grab(grabber_t *self); #endif 该实现需要先获取 windows 窗口句柄，然后初始化 grabber #include \u003cWindows.h\u003e ... HWND handle = FindWindow(NULL, TEXT(\"Apex Legends\")); if(!handle) return -1; grabber_crop_area_t crop { 0, 0, 0, 0 }; grabber_t * grabber = grabber_create(handle, crop); ... while(1) { void* data = grabber_grab(grabber); ... } 这里踩的坑是 void* 是一个字节数组，也就是 uchar* 数组而在 grabber.c 中设置了 bitmapInfo.biBitCount = 32; bitmapInfo.biCompression = BI_RGB; 我们不需要 A 通道数据，所以设置 bitmapInfo.biBitCount = 24 这意味着要将 grabber 捕获到的数据是 RGB 格式的用 opencv 读取需要格式 CV_8U3C: void* pixel = grabber_grab(grabber); // 8U3C -\u003e 3 通道每通道 8 位 cv::Mat frame = cv::Mat(cv::Size{ grabber-\u003ewidth, grabber-\u003eheight }, CV_8UC3); frame.data = (uchar*)pixel; 由于opencv 的格式是 BGR，神经网络输入格式是 RGB；将 cv::Mat 转为 ncnn::Mat 时需要进行格式转换： ncnn::Mat in = ncnn::Mat::from_pixels_resize(croped.data, ncnn::Mat::PIXEL_BGR2RGB, croped.cols, croped.rows, target_size, target_size); 这里可以直接从 void* 转换到 ncnn::Mat , 为了测试方便还是先转换成 cv::Mat 方便使用 cv::imshow() 显示到窗口。 ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:2:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"识别目标 识别目标 是最重要的一环，也是踩坑最多的一环。神经网络训练时框架太笨重，不适合用于软件嵌入，现有的推理框架： NCNN：腾讯的产品，号称 “0 依赖\"，运行时确实不需要 .dll 开发时需要 protobuf，vulkan。在移动平台等边缘设备优化是最好的，很适合用于 嵌入应用. MNN、MACE、TF-lite、Paddle-lite 这些都类似 NCNN 主打移动端推理 TensorRT：Nvidia 的框架，一般来说 Nvidia 下用该框架时最快的依赖 cuda,cudann TensorRT-For-YOLO-Series/main.cpp at main · Linaom1214/TensorRT-For-YOLO-Series (github.com) OpenVINO：Intel家的，缺点很明显不支持 AMD CPU 对于 AI 自瞄来说最好的选择是 NCNN 或者 TensorRT（但是开始这个项目之前没怎么了解过，先后使用了libtorch、OnnxRuntime、NCNN、TensorRT） 为了方便后续添加功能，例如移动端的实现，采用 Tensorrt 和 NCNN 两种实现。 模型使用 最新的 Yolov7， 准确率高，速度快，在不启动游戏的情况下 RTX2060 可以有120fps 的推理速度。 GitHub - WongKinYiu/yolov7: Implementation of paper - YOLOv7: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors 给出了模型训练和模型导出的方法，NCNN/TensorRT 的使用可以在 Github 找到大量的Demo，拿到Demo搞清楚输入输出即可。 这一环最麻烦的是数据格式的转换 BGR -\u003e RGB : 可以由 cv::Mat.convertTo, ncnn::Mat.resize 等方法 NHWC -\u003e NCHW: cv::dnn::blobFromImage, transposeND, 三层 for 循环硬转，tensorflow/pytorch 的轴旋转方法 ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:3:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"调用track脚本 这里使用 Python 脚本来处理神经网络的输出和鼠标移动，由于不同的用户需求不同，例如 鼠标平滑，定位精度，拉枪速度，鼠标吸附等，process 方法将在每一个推理帧的最后被调用。 def process(targets) -\u003e (float, float): for target in target: print(target) return (1.1, 2.0) 脚本需要和c++交互，process 方法需要被c++调用并捕获输出值，c++ 调用python需要include Python.h 头文件，需要添加 \u003cpython_dir\u003e/libs 库文件， 最后程序打包时需要将 python39.dll 添加到 .exe 文件目录，可以使用更小的 embed 版本来将 python 嵌入到应用（只占用10mb） #define PY_SSIZE_T_CLEAN #include \u003cPython.h\u003e int main() { Py_SetPythonHome(std::wstring(config.pythonHome.begin(), config.pythonHome.end()).c_str()); Py_Initialize();//初始化python PyObject *pModule = NULL, *pFunc = NULL, *pArg = NULL; pModule = PyImport_ImportModule(\"core\");//引入模块 pFunc = PyObject_GetAttrString(pModule, \"process\");//直接获取模块中的函数 PyObject* list = PyList_New(0); Py_INCREF(list); for (auto\u0026 obj : boxes) { PyList_Append(list, Py_BuildValue(\"(f,f,f,f,f)\", (obj.x1 + obj.x2) / 2, (obj.y1 + obj.y2) / 2, obj.x2 - obj.x1, obj.y2 - obj.y1, obj.score)); } PyDict_SetItemString(dict, \"target_list\", list); Py_DECREF(list); PyDict_SetItemString(dict, \"mouse_left_button\", Py_BuildValue(\"b\", KEY_DOWN(VK_LBUTTON))); PyDict_SetItemString(dict, \"mouse_middle_button\", Py_BuildValue(\"b\", KEY_DOWN(VK_MBUTTON))); PyDict_SetItemString(dict, \"mouse_right_button\", Py_BuildValue(\"b\", KEY_DOWN(VK_RBUTTON))); PyDict_SetItemString(dict, \"mouse_ctrl_button\", Py_BuildValue(\"b\", KEY_DOWN(VK_CONTROL))); PyObject* args = PyTuple_New(1); PyTuple_SetItem(args, 0, dict); PyObject* pRet = PyObject_CallObject(pFunc, args); if (!pRet) return; if (PyErr_Occurred()) { PyErr_Print(); } Py_Finalize(); //释放python return 0; } python 端需要获取非激活窗口的键盘或者鼠标状态需要使用pyhook， 但是在 c++ 可以很简单的获得： #define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME) \u0026 0x8000) KEY_DOWN(VK_LBUTTON); KEY_DOWN(VK_MBUTTON); KEY_DOWN(VK_RBUTTON); KEY_DOWN(VK_CONTROL); 并通过 c++ 传递给 python ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:4:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"更新准星位置 参考了这位老哥的鼠标定位方法 FPS游戏（AI自瞄原理） - 哔哩哔哩 (bilibili.com) 但是这里给出的计算方式是有偏差的, 但是利用 角度替代像素 是正确的，游戏引擎中相机的角度是使用欧拉角来计算的, 一般第一人称游戏使用鼠标的 水平输出(HorizontalInput) 和 竖直输出(VerticalInput) 来控制摄像机转动，这一位置，所以对于不同的游戏 XInput 的大小和相机转动的欧拉角可能不一样，也就是说我们定义一个单位: $$ 像素角(fa) = 转动一弧度移动的像素(pixel/rad) $$ 像素角的计算和测量 $$ fa = \\frac{游戏水平转动一周需要的像素\\times 2 \\times \\pi}{360} \\times 游戏内灵敏度 \\times ADS $$ 所以只需要测量游戏内水平转动一周需要移动的像素即可(游戏内瞄准一个点不断地改变pixel 的值，直到相机画面不会抖一下)，不同倍镜下的 fa 值是不同的需要单独测量。 import win32api import win32con pixel = 10909 for i in range(pixel) { win32api.mouse_event(xxx, 1, 0, 0, 0) } 现在有了 fa 的值之后，再来计算如何将鼠标移动到频幕上的点 Point(x, y), 首先计算目标点和屏幕某点 P 的偏移向量 offset(x, y)但是，真实的移动是发生在游戏空间的 3D 世界。 也就是需要将视角方向从OB 调整到OG方向，借鉴 水平像素转角度方法可以先将视线 OB 调整到 OC，再从OC调整到OG，这个过程中 相机到视平面的距离是不变的。 为了保持距离不变，所以是先从 OB -\u003e OI -\u003e OK，所以将三维的转动过程转化为两次二维的转动 $$ dis2screen = AB = \\frac{half_screen_width}{\\tan{\\frac{fov}{2}}} \\ \\quad\\ \\quad\\ \\theta_x = \\angle{BAI} = \\arctan{\\frac{BC}{AB}} \\arctan{\\frac{offset_x}{dis2screen}} \\quad\\ \\quad\\ \\quad\\ \\quad\\ \\theta_y = \\angle{CAG} = \\arctan{\\frac{CG}{AC}} = \\arctan{\\frac{CG}{\\sqrt{AB^2+BC^2}}} = \\arctan{\\frac{offset_y}{\\sqrt{dis2screen^2 + offset_x^2}}} $$ 这样就得到了两个方向的偏转角$(\\theta_x, \\theta_y)$，所以根据之前测量得到的 fa 值，可以得到鼠标的像素偏移值： $$ pixel_i = \\theta_i \\times \\frac{fa}{游戏内灵敏度\\times FOV} $$ 所以就可以由屏幕偏移量 offset 得到鼠标偏移量 pixel， 此外需要能够移动鼠标的方法，在 python 环境下，常规的自动化库方法都是无效的，鼠标驱动层的移动应该是有效的但是麻烦，win32api 也是有效的，不过需要以管理员权限启动程序。 import win32api import win32con win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, int(pixel_x), int(pixel_y), 0, 0) ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:5:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"使用 Json 读取配置 使用简单又方便的 nlohmann/json: JSON for Modern C++ (github.com)，只有 .hpp 头文件 std::cout \u003c\u003c \"# init config ...\" \u003c\u003c std::endl; // ----------------------- config ----------------------- std::ifstream f = std::ifstream(); json json_data;; Config config; // 需要根据当前运行环境构造文件全名 try { f.open(\"./config.json\"); json_data = json::parse(f); std::cout \u003c\u003c \"[init] load config from: \" \u003c\u003c \"config.json\" \u003c\u003c std::endl; config.windowName = json_data[\"windowName\"]; config.classNamesPath = json_data[\"classNamesPath\"]; config.pythonHome = json_data[\"pythonHome\"]; config.debug = json_data[\"debug\"]; config.detectorName = json_data[\"detectorName\"]; config.paramPath = json_data[\"paramPath\"]; config.binPath = json_data[\"binPath\"]; config.boxThreshold = json_data[\"boxThreshold\"]; config.nmsThreshold = json_data[\"nmsThreshold\"]; config.useGPU = true; config.mouseMovementDelay = json_data[\"mouseMovementDelay\"]; config.receptiveField = json_data[\"receptiveField\"]; } catch (std::exception\u0026 e) { std::cout \u003c\u003c \"配置文件读取失败\" \u003c\u003c std::endl; return -1; } ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:6:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"在之前的文章里提到过 里世界机制 游戏机制，但是最初的版本是需要手动用右摇杆移动 “透镜” 来观察里世界的物体，这样的设计有以下几个缺陷： 需要控制左右摇杆和跳跃键来控制人物和移动 “透镜” 透镜 自由度过高，限制了关卡设计的可能性 仅仅实现了遮挡 / 显示 物体，并没有修改物体的碰撞体积 后来玩到 《塞尔达传说三角力量 2》 ，其中林克化身壁画在墙壁游走的能力给了我很大的启发：“壁画林克只能在一条水平线上移动，而作者利用地形的高低差设计了很多意想不到的关卡”, 这背后的思考是 “通过限制玩家的能力，来增加关卡设计的可能性”，回到里世界机制上，我们可以通过限制\"透镜\"的移动和玩家进入的方式来增加关卡设计的可能性： 于是，我对机制进行如下修正: 通过推箱子的形式移动透镜，而不是用右摇杆 限制透镜的进入点，而不是全开放 这样的修正可以以某种方式设计关卡，让玩家思考以何种顺序移动各个箱子能到达想要去的目标，它的本质是推箱子， 只是换上了一层 里世界 的皮 下面来构思整个机制的实现： 实现 “透镜” 内的物体不显示, 之外的物体显示 -\u003e 使用光照剔除 实现 “透镜” 内的物体与玩家碰撞，之外的物体不碰撞 -\u003e 使用 PolygenShape动态修改 实现 推箱子 机制 -\u003e 箱子内和箱子都能推动（避免死锁） ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:0","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"光照剔除 在之前的实现里，将里世界的所有物体放入一个单独的 CanvasLayer，再应用一个 CanvasModulate 将不透明度设置为 0， 然后用一一个 Light2D 来为里世界物体添加 透明度，这样实现玩家不能与里世界物体发生物理交互所以采用了很复杂的实现方式。 Godot Light2D 有一个 Mask 模式专门用于剔除物体，被剔除的物体需要确保 层号在 (layer_min, layer_max) 之间 光照层在 Item Cull Mask 之中 使用一个 Texture 与透镜大小相同的 Light2D 节点， 选择 Add / Mix 模式位被剔除的物体赋予颜色，同样需要确保光照层和画布层设置正确 此外，可以通过 WorldEnviroment 节点为里世界的物体增加荧光，或者设置边缘光 Shader 增加区分度。 ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:1","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"动态碰撞体 动态碰撞体很简单，只需要每帧取碰撞体矩形 DefaultRect 透镜碰撞体矩形 LensRect，计算两个 Rect2 的 ∩ 即可 public class LensRect : Area2D { public Dictionary\u003cstring, Godot.Object\u003e NearbyLens = new Dictionary\u003cstring, Godot.Object\u003e(); Vector2 extent; CollisionShape2D shape; public override void _Ready() { shape = GetNode\u003cCollisionShape2D\u003e(nameof(CollisionShape2D)); extent = (shape.Shape as RectangleShape2D).Extents; } // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta) { foreach(DynamicPolygon polygon in NearbyLens.Values) { polygon.Clips(ToGlobal(shape.Position - extent), ToGlobal(shape.Position + extent)); } } void _on_LensRect_area_entered(Area2D body) { Node parent = body.GetParent(); if(parent is DynamicPolygon) { NearbyLens[parent.Name] = parent; } } void _on_LensRect_area_exited(Area2D body) { Node parent = body.GetParent(); if(parent is DynamicPolygon) { NearbyLens.Remove(parent.Name); } } } Lens 需要使用一个 Area2D 记录附近可能相交的里世界物体，在每一个物理帧调用 polygon.Clips() 更新附近里世界物体的多边形点集 对于每一个里世界物体， 只需实现 Clips 方法， 并保证碰撞体附近没有 Lens 时，碰撞体保持休眠状态 public class DynamicPolygon : KinematicBody2D { private CollisionPolygon2D shape; private Rect2 rect; public override void _Ready() { Sprite sprite = GetNode\u003cSprite\u003e(nameof(Sprite)); shape = GetNode\u003cCollisionPolygon2D\u003e(nameof(CollisionPolygon2D)); rect = sprite.GetRect(); ; } // Called every frame. 'delta' is the elapsed time since the previous frame. public void Clips(Vector2 p1, Vector2 p2) { Rect2 _rect = new Rect2(ToLocal(p1), ToLocal(p2) - ToLocal(p1)); Rect2 inter = rect.Clip(_rect); Vector2 [] array = new Vector2[4]; Vector2 local = inter.Position; array[0] = local; array[1] = local + Vector2.Right * inter.Size.x; array[2] = local + inter.Size; array[3] = local + Vector2.Down * inter.Size.y; shape.Polygon = array; } void _on_Area2D_area_entered(Area2D area) { if (area is LensRect magic) { shape.SetDeferred(\"disabled\", false); } } void _on_Area2D_area_exited(Area2D area) { if (area is LensRect magic) { shape.SetDeferred(\"disabled\", true); } } } 这个地方有很多可以优化的点（下次一定），例如： 目前仅支持 矩形 Lens 和 矩形里世界物体，可以考虑支持任意多边形 可以优化同时对 多个Lens， 多个 里世界物体 更新（例如使用 ECS， 做一个 System 统一更新，效率更高，也可以做一些向量优化，maybe） 实现 其他 PhysicsBody 的里世界物体 添加 [Tool]编辑器代码，方便 Debug ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:2","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"推箱子 首先实现箱子类，他是一个可推动接口，实现 Push 和Stop方法, 受到重力影响 public interface IPushable { void Push(Vector2 direction); void Stop(); } public class TestMovableCube : KinematicBody2D, IPushable { private Vector2 _velocity = Vector2.Zero; [Export] private float _pushSpeed = 100f; public override void _PhysicsProcess(float delta) { _velocity += Vector2.Down * 100f; _velocity = MoveAndSlide(_velocity); } public void Push(Vector2 direction) { _velocity += _pushSpeed * direction; } public void Stop() { _velocity = Vector2.Zero; } } 其次是 玩家/怪物的Push状态, 这里在每一帧计算正在推动的物体列表， 然后每帧调用IPushable.Push() 方法，每帧开始时和退出状态时需要将所有正在推动的物体停下来（否则将做匀速直线运动） /* 状态有四个生命周期, 进入, 更新， 物理更新， 退出 有 Init 接口函数用于初始化，有 Exit() 方法用于退出当前状态 */ public class Push : StateBase { private Player target; private List\u003cIPushable\u003e cacheCubes = new List\u003cIPushable\u003e(); public override void OnEnter() { target = agent as Player; GD.Print(\"Enter \", StateName); } public override void Update(float delta) { } public override void PhysicsUpdate(float delta) { target.GravityHandler(target.DefaultGravity.JumpGravity, delta); target.GestureHandler(); target.HorizontalHandler(); target.SnapHandler(); foreach (var cube in cacheCubes) { cube.Stop(); } cacheCubes.Clear(); for (int i = 0; i \u003c target.GetSlideCount(); i++) { // tips: Godot.Collections.Array dont support the c# interface var collision = target.GetSlideCollision(i); if (collision.Collider is IPushable pushable) { GD.Print(collision.Normal); cacheCubes.Add(pushable); pushable.Push(-collision.Normal); } } if ((!Input.IsActionPressed(\"ui_left\") \u0026\u0026 !Input.IsActionPressed(\"ui_right\")) || target.JumpRequest() || !target.IsOnFloor() ) { Exit(); } } public override void OnExit() { foreach (var cube in cacheCubes) { cube.Stop(); } GD.Print(\"Exit \", StateName); } } Tips: 这里为什么不让物体自己动? 而是要推动者维护一个推动列表呢？如果 IPushable 自己动，即使 Player 紧贴着 IPushable推动，IPushable仍然不能在每帧检测到有 Player 正在推它，这会导致 IPushable 移动时断断续续的（不清楚这是bug还是特性) ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:3","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"美化 - 添加进出口特效 由于这本来是一个原型项目，所以只实现见简单特效即可（主要是花里胡哨的我也不会），Lens的进出口使用激光门（就是两束激光） 激光实现 - RayCast2D - Position2D - Sprite - CPUParticals2D [Tool] public class Laser : RayCast2D { Sprite sprite; Position2D anchor; float default_length = 580f; Vector2 target = Vector2.Right*10; CPUParticles2D articles; public override void _Ready() { anchor = GetNode\u003cPosition2D\u003e(nameof(Position2D)); sprite = anchor.GetNode\u003cSprite\u003e(nameof(Sprite)); Enabled = true; articles = GetNode\u003cCPUParticles2D\u003e(\"LaserPartical\"); Scale = Vector2.One; } // // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta) { anchor.Rotation = anchor.Position.AngleToPoint(CastTo) + Mathf.Pi; float dis; if (!Engine.EditorHint) { if (IsColliding()) { target = GetCollisionPoint(); articles.GlobalPosition = GetCollisionPoint(); articles.Direction = GetCollisionNormal(); articles.Emitting = true; } else { articles.Emitting = false; } dis = ToLocal(target).Length(); } else { dis = CastTo.Length(); } anchor.Scale = new Vector2(dis / default_length, anchor.Scale.y); } } 激光使用了Energy Beams - Godot Shaders 的实现， 使用一个 Texture 表示一个激光，这种做法可以使用Shader 计算扰动，但是对于本题这种点到点激光，并且可能发生转动的情况下，还是很不方便，在计算起始/结束点和激光 Sprite 的Scale 的关系时不太好计算（主要是 Sprite 只能通过 Scale 调整大小而不便指定 Rect 的 Size， 好像也可以,emmm）， 激光命中的粒子就随便弄一弄就好了。 ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:4","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"一些思考核问题 在实现过程中遇到很多问题： 被推动的箱子时主动移动还是被动移动? 箱子使用 KinamicBody 还是RigidBody（能够模拟下落，抛，旋转）? 箱子应该从内部移动还是外部移动? 是否需要设计里世界物体Mask？（例如，红箱子只能显示红色物体，绿箱子只能显示绿物体，其实应该有Mask，这样可以增加关卡设计的多样性） 是否应该设置里世界物体的显示时间？（可以增加该机制） Godot.Collections.Array 不能存放 C# 接口，会报错，不知道是 Bug还是什么？ 是否应该有其他多边形状的 Lens 和 里世界物体？ （应该有的） Lens 的矩形是否应该有很多个进出口？（为了方便机制设计，应该有，所以一个Lens有很多个 PolyShape） 是否里世界物体应该高亮（应该的，为了区分里外物体，但是还没想好高亮应该怎么做？边缘发光，荧光，虚线还是整体发光？） 是否应该区分Lens 的可推动部分和不可推动部分？（应该，有利于复杂关卡设计） ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:5","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"使用 Godot 对WindowFrame 进行拙劣的模仿，观察视频中的窗体有以下性质： 窗体既是 UI 也是可以与玩家互动的 场景物体 窗口的位置可以由场景物理改变也可以由鼠标控制改变 玩家可以发射子弹，子弹碰到的边进入锁定状态，一段时间后子弹消失，并且解除锁定 考虑一下几种设计： ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-chuang-ti-hu-dong/:0:0","tags":null,"title":"[游戏机制] 窗体互动","uri":"/you-xi-ji-zhi-chuang-ti-hu-dong/"},{"categories":null,"content":"方案一 存在一个窗体对象window和场景对象rect 每一帧将rect大小和位置经过MPV变换后同步到窗口大小 每一个rect 对象有一个默认的初始大小 rect 对象持有四条边的对象 line，每个line对象有 follow/move/lock/idle状态 Follow 状态的边跟随 target(player) 运动 Move 状态的边能被鼠标拖动 Lock 状态的边在玩家移动过程中充当 墙 或 地板 Idle 状态，是场景中没有 target 时的状态 rect 对象实进入场景树的时候生成 windows 对象，并持有，rect退出场景树的时候回收 windows 对象 各个状态都有对应的 Physics Collision Layer / Mask，例如锁定状态的边会阻挡某些攻击，拖动时和锁定时与玩家的碰撞是不一样的。 using Godot; using System; public class InteractiveAnchor : RigidBody2D { public Vector2 velocity; public bool IsStop = false; public Vector2 StopPosition = Vector2.Zero; ColorRect rect; RandomNumberGenerator _random = new RandomNumberGenerator(); public delegate void InteractiveAnchorCallBack(InteractiveAnchor anchor); public InteractiveAnchorCallBack callback; // cache 一旦锁定目标，不可更改！！ InteractiveLine AnotherCache = null; public override void _Ready(); public void Init(Vector2 _velocity, InteractiveAnchorCallBack _callback); public override void _ExitTree(); // // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta); // 添加抖动将要删除时 public void _on_DeleteEffect_timeout(); void _on_Area2D_body_entered(Node body); void _on_Area2D_body_exited(Node body); void CacheCurrentState(Vector2 origin_global_position); } public class InteractiveArea : Area2D { public override void _Ready(); Node Scene; public override void _EnterTree(); public override void _PhysicsProcess(float delta); void _on_Area2D_body_entered(Node body); void _on_Area2D_body_exited(Node body); } public class InteractiveBorder : Node2D { // 显示区域大小 public Rect2 window; [Export] public Rect2 DefalutRect; [Export] public float BorderWidth; public InteractiveLine left; public InteractiveLine right; public InteractiveLine top; public InteractiveLine down; public InteractiveWindow interactiveWindow; public Vector2 Start; public Vector2 End; public Rect2 UIRect; public override void _Ready(); public override void _EnterTree(); public override void _Draw(); public override void _Process(float delta); public override void _PhysicsProcess(float delta); public void Reset(); public void SetRect(Rect2 _window); public void SetCollision(bool flag); } public class InteractiveLine : KinematicBody2D { public bool IsLocked; static public string IsSlideName = \"\"; public SegmentShape2D shape; public InteractiveWindow window; public Vector2 velocity = Vector2.Zero; public int ColllisionCount = 0; [Export] public Vector2 DefaultBias; public override void _Ready(); public override void _ExitTree(); public override void _PhysicsProcess(float delta); public void SetCollision(uint layer, uint mask); public void Reset(); public float DistanceToLine(Vector2 P, Vector2 A, Vector2 B); } public class InteractiveLineFollow : StateNode\u003cInteractiveLine\u003e { public override void Enter() { target.SetCollision(target.window.FollowLayer, target.window.FollowMask); } public override void _PhysicsUpdate(float delta) { /// 如果没有目标，就转移到Lock？ if(!target.window.IsLockTarget) { _machine.Transition\u003cInteractiveLineIdle\u003e(); return; } if(target.window.Target.IsInsideTree()) { target.GlobalPosition = target.window.Target.GlobalPosition + target.DefaultBias; } if(target.ColllisionCount != 0) { _machine.Transition\u003cInteractiveLineLock\u003e(); return; } } public class InteractiveLineIdle : StateNode\u003cInteractiveLine\u003e { public override void _PhysicsUpdate(float delta) { if(target.window.IsLockTarget) { _machine.Transition\u003cInteractiveLineFollow\u003e(); return; } } } public class InteractiveLineLock : StateNode\u003cInteractiveLine\u003e { Vector2 cachePosition = Vector2.Zero; public override void Enter() { target.IsLocked = true; cachePosition = target.Position; target.SetCollision(target.window.LockLayer, target.window.LockMask); } public override void Exit() { target.IsLocked = false; } public override void _PhysicsUpdate(float delta) { // TODO:这里是否可以不移动锁定的目标不移动 if(cachePosition != null) target.Position = cachePosition; if(target.ColllisionCount == 0) { _machine.Transition\u003cInteractiveLineFollow\u003e(); return; } if(","date":"2023-01-03","objectID":"/you-xi-ji-zhi-chuang-ti-hu-dong/:1:0","tags":null,"title":"[游戏机制] 窗体互动","uri":"/you-xi-ji-zhi-chuang-ti-hu-dong/"},{"categories":null,"content":"方案二 不使用 UI 对象，将交互和物理全部集中到一个 Rect 对象中。 交互窗体包含四条边，每条边包含碰撞设置和鼠标靠近检查（锁定状态） 每条边拥有相似的几种状态，特别的在拖动时，依然使用velocity来移动每条边 当鼠标左键按下 \u0026\u0026 鼠标位置在边的拖动区域时 ==\u003e 进入拖动状态 松开鼠标左键时 ==\u003e 退出拖动状态 拖动状态下，鼠标位置，边位置，边速度的关系如下 $$ velocity_L = \\frac{(pos_M - pos_L) \\cdot normal_L}{||normal_L||} $$ 这样，窗口移动始终比鼠标位置延后一帧，但是移动过程中可以进行物理检测 窗口根据三条边的位置绘制窗口（场景中绘制），并且生成一个mask覆盖整个屏幕（不使用方案一中生成相机纹理在windows中显示） 如果某条边的移动会使得 player 与其他物体碰撞，那么该移动应该被修正: 会与player碰撞的物体有两种可能： a. 场景中的物体 -\u003e 丢弃当前的移动 b.窗体中的自由对边 -\u003e 保持当前移动 c.窗体中的锁定对边 -\u003e 丢弃当前移动 为了使移动边感知到玩家的碰撞，需要为边增加一个Push状态（不用增加，写在Move里即可），该状态下每次移动时应该对玩家进行移动测试，如果通过测试则移动否则不移动。 在边的Move状态下，应该停止相机对 Player的跟踪 2D 引擎不能如3D一样剔除视锥外的物体，不渲染/不更新窗口外的物体只能通过碰撞来实现 a. 所有进入窗体的对象将恢复更新，退出窗体的对象停止更新 b. 场景对象持有所有场景物体的引用，所以当玩家进入窗口时可以直接调用场景节点的Stop方法，这将停止所有除（player，window，obj_in_window）的对象。 ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-chuang-ti-hu-dong/:2:0","tags":null,"title":"[游戏机制] 窗体互动","uri":"/you-xi-ji-zhi-chuang-ti-hu-dong/"},{"categories":null,"content":"情景引入 考虑以下情形，采集用户水平输入 float HorizontalInput 来控制 player 的水平位移 void Update(float delta) { velocity.x = HorizontalInput * WalkSpeed * delta; } 这样写有两个缺点： 当影响水平速度的因素不只是水平输入时，不同因素的叠加不方便。不应该是 = 而应该是 +=; 移动完全与输入一直，看起来很僵硬； ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:1:0","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"解决方案 所以需要有这么一个函数(缓动函数)，它对输入的响应由可控的延迟，但最终会与输入保持一致 // 添加示例函数1.1 为了使缓动曲线更好的模拟现实世界中由于力产生加速度的运动，这里使用一个二阶系统来描述： $$ y + k_1\\cdot y^{’} + k_2\\cdot y^{’’} = x + k_3 \\cdot x^{’} $$ 等价的写法： $$ y + k_1\\cdot \\frac{\\mathrm{d} y}{\\mathrm{d} t} + k_2\\cdot \\frac{\\mathrm{d} ^2 y}{\\mathrm{d}^2 t} = x + k_3 \\cdot \\frac{\\mathrm{d} x}{\\mathrm{d} t} $$ 通过调整 $k_1, k_2,k_3$ 可以改变图像的形状， // 插入示例图像1.2 现在添加三个变量： $$ f = \\frac{1}{2\\pi \\sqrt{k_2}}, \\quad \\theta = \\frac{k_1}{2\\sqrt{k_2}}, \\quad r = \\frac{2k_3}{k_1} $$ 解方程组可得： $$ k_1 = \\frac{\\theta}{\\pi f}, \\quad k_2 = \\frac{1}{(2\\pi f)^2}, \\quad k_3 = \\frac{r \\theta}{2\\pi f} $$ 原二阶系统的微分方程变为： $$ y +\\frac{\\theta}{\\pi f} \\cdot y^{’} + \\frac{1}{(2\\pi f)^2} \\cdot y^{’’} = x + \\frac{r \\theta}{2\\pi f} \\cdot x^{’} $$ 这里 $f, \\theta, r$ 都具有现实意义了 $f$ 以 $hz$ 为单位，代表系统固有频率，它描述系统对输入变化的响应速度 $\\theta$ 代表系统的阻尼系数，描述了系统如何最终趋于稳定 $r$ 控制系统的初始响应 当 $r = 0$ 时系统需要花费一点时间才能从禁止开始加速 当 $r \u003e 0$ 时系统立刻对变化做出反应 当 $r \u003e 1$ 时系统变化将冲过目标 当 $r \u003c 0$ 时系统会有抬手运动（先反向运动） 一般为机械链接设置 $r = 2$ 现在只剩下最后一个问题了，如何解二阶系统？ ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:2:0","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"二阶微分方程数值解 ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:3:0","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"1. 半隐式欧拉法 该方法在该问题下与复杂的 Verlet 积分法 有着相同的精度， 首先计算 x 变化率 $$ x^{’}{n+1} = \\frac{x{n+1} - x_n}{T} \\ $$ 然后计算 y 的变化 $$ \\begin{cases} y_{n + 1} = y_{n} + Ty^{’}{n} \\ \\quad\\ y^{’}{n+1} = y^{’}{n} + Ty^{’’} \\ \\end{cases} $$ 由于: $$ y^{’’} = \\frac{x + k_3 x^{’} - y - k_1y^{’}}{k_2} $$ 所以： $$ y^{’}{n+1} = y^{’}{n} + T\\cdot \\frac{x{n+1} + k_3 x^{’}{n+1} - y{n+1} - k_1y^{’}_{n}}{k_2} $$ 这存在一个问题，如果频率 $f$ 远大于帧率，系统将变得不稳定，会产生无穷大的值： 可以简单地设置 f 的取值范围 通过数学方法确保不发生极端情况 为了提供更多的鲁棒性，采用方案二 分析 不稳定产生的原因，该系统的本质是反馈系统，他的迭代输出将被反馈到后续的迭代用于计算，当帧间时间步长和参数相比太大时，随着时间增加，误差将逐渐累积，当超过某个临界值时，误差会开始滚雪球，迅速导致灾难性后果，为了计算该临界值，引入线性代数方法： $$ \\begin{cases} y_{n + 1} = y_{n} + Ty^{’}{n} \\ \\quad \\ y^{’}{n+1} = y^{’}{n} + T\\cdot \\frac{x{n+1} + k_3 x^{’}{n+1} -(y{n} + Ty^{’}{n}) - k_1y^{’}{n}}{k_2} \\end{cases} $$ 展开合并同类项： $$ \\begin{cases} y_{n + 1} = y_{n} + Ty^{’}{n} \\ \\quad \\ y^{’}{n+1} = \\frac{-T}{k_2} y_n + \\frac{k_2 - T^2 - Tk_1}{k_2}y^{’}{n} + \\frac{T}{k_2}x{n+1} + \\frac{Tk_3}{k_2}x^{’}_{n+1}\\ \\end{cases} $$ 矩阵表示如下： $$ \\begin{bmatrix} y\\ y^{’} \\end{bmatrix}_{n+1} = \\begin{bmatrix} 1 \u0026 T\\ -\\frac{T}{k_2} \u0026 \\frac{k_2 - T^2 - Tk_1}{k_2} \\end{bmatrix} \\cdot \\begin{bmatrix} y\\ y^{’} \\end{bmatrix}_{n} \\begin{bmatrix} 0 \u0026 0\\ \\frac{T}{k_2} \u0026 \\frac{Tk_3}{k_2} \\end{bmatrix} \\cdot \\begin{bmatrix} x\\ x^{’} \\end{bmatrix}{n+1} $$ 简写如下 $$ Y{n+1} = A\\cdot Y_n + B\\cdot X_{n+1} $$ 分析： $A$ 称为状态转移矩阵，他表示迭代是如何影响状态变量的，直观来说如果 $A$ 矩阵不导致状态变量 $Y$ 的增长，那该反馈是稳定的；考虑$A$ 作为值而非变量，利用特征值理论，记 $A$ 的特征值$\\lambda$ 如果 $\\lambda_i \u003c 1$, Y 将逐渐减小趋于稳定 如果 $\\lambda_i \u003e 1$, Y 迅速增大，很快变得无法控制 计算特征值如下： $$ det(A - \\lambda I) = 0 $$ 展开后 $$ k_2 \\lambda^2 + (T^2 + Tk_1 - 2k_2)\\lambda (k_2-Tk_1) = 0 $$ 解关于 $\\lambda$ 的二次方程 $$ \\lambda = \\frac{ -b \\pm \\sqrt{b^2-4ac}}{2a} $$ 令 $|\\lambda| \u003c 1$: 得: $$ T \u003c \\sqrt{4k_2 + k_1^2} - k_1 $$ 这里 如果时间步长大于临界值, 将拆分为多个了迭代来计算 public classs SecondOrderDynamics { private float T_crit; // critical stable time step public SecondOrderDynamics(float f, floatz, float r, Vector x0) { // update compute constants k1 = z / (PI * f); k2 = 1 / ((2 * PI * f) * (2 * PI * f)); k3 = r * z / (2 * PI * f); T_crit = 0.8f * (sqtr(4 * k2 + k1 * k1)); xp = x0; y = x0; yd = 0; } public Vector Update(float delta, Vector x, Vector xd = null) { if(xd == null) { xd = (x - xp) / delta; xp = x; } int interations = (int)Ceil(delta / T_crit); // take extra iterations if delta \u003e T_crit delta = delta / iterations; for(int i = 0; i \u003c iterations; i++) { y = y + delta * yd; yd = yd + delta * (x + k3 * xd - y - k1*yd) / k2; } return y; } } 此外，如果想避免迭代次数过多，可以限制 $k_2$ 的值（减缓运动） $$ k_2 \u003e \\frac{T^2}{4} + \\frac{Tk_1}{2} $$ float k2_stable = Max(k2, 1.1f * (T*T/4 + T*k1/2)); ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:3:1","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"2.零极点匹配法（高精度）没懂 public classs SecondOrderDynamics { private Vector xp; private Vector y, yd; private float _w, _z, _d, k1, k2, k3; public SecondOrderDynamics(float f, float z, float r, Vetor x0) { _w = 2 * PI * f; _z = z; _d = _w * sqrt(Abs(z*2-1)); k1 = z / (PI * f); k2 = 1 / (_w * _w); k3 = r * z / _w; xp = x0; y = x0; yd = 0; } public Vector Update(float delta, Vector x, Vector xd = null) { if(xd == null) { float k1_stable, k2_stable; if(_w * T \u003c _z) { k1_stable = k1; k2_stable = Max(k2, T * T / 2+ T * k1 / 2, T*k1); } else { float t1 = Exp(-_z * _w * T); float alpha = 2 * t1 * (_z \u003c= 1 ? cos(T * _d) : cosh(T * _d)); float beta = t1 * t1; float t2 = T / (1 + beta -alpha); k1_stable = (1 - beta) * t2; k2_stable = T * t2; } y = y + T * yd; yd = yd + T * (x + k3*xd -y - k1*yd) / k2_stable; return y; } } } ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:3:2","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"3. 其他数值解方法（略） 参考: t3ssel8r:Giving Personality to Procedural Animations using Math ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:3:3","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"线性模型.html import numpy as np import matplotlib.pyplot as plt import copy from IPython import display np.random.seed(0) data = [[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]] def load_data(): X = np.array(data).T label = copy.deepcopy(X[2,:].reshape(1,17)) X[2,:] = 1 assert X.shape == (3,17) assert label.shape == (1,17) return X, label $$ l(\\beta) = \\sum_{i=1}^{m}(-y_i \\beta^Tx_i+ln(1+e^{\\beta^T x_i})) $$ $$ = \\sum_{i=1}^{m}-y_i \\beta^Tx_i+\\sum_{i=1}^{m}ln(1+e^{\\beta^T x_i}) $$ $$ = (\\beta^TX)Y + np.sum(ln(1+e^{Y_i})) $$ 使用numpy实现如下： part_1 = np.dot(Y, label.T) part_2 = np.sum(np.ln(1+np.exp(Y))) def loss(label, Y): part_1 = -np.dot(Y, label.T) part_2 = np.sum(np.log(1+np.exp(Y))) return part_1 + part_2 ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:0","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"前向传播 $input = W,X$ $output = W^{‘T} X^{’} = W^T X+b$ def forward_propagation(W,X): Z = np.dot(W,X) A = 1/(1+np.exp(-Z)) return A ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:1","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"初始化参数: 使用随机初始化 n —— 特征值数量为 m —— 样本数量 $w^{’} = (w,b)$ $w.shape == （1,n+1）$ def initialization(n): return np.random.randn(1,n+1) # return np.zeros((1,n+1)) ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:2","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"反向传播 $$ dw = -\\sum_{i=1}^{m}x_i(y_i-p_1(x_i;\\beta)) $$ $$ dw = -(label-Y)X^T $$ def back_propagation(X,Y,label): return -np.dot((label-Y),X.T) ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:3","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"训练循环 使用梯度下降法 学习率 = 0.5 迭代次数 10000 def train(epoch=100,n = 2, learning_rate = 0.5, detial = True): X, label = load_data() W = initialization(n) losses = [] W_list = [] for i in range(0,epoch): Y = forward_propagation(W,X) l = loss(label, Y) dw = back_propagation(X,Y,label) losses.append(float(l)) W += learning_rate * dw if i % 100 == 0: W_list.append(copy.deepcopy(W)) if i % 1000 == 0 and detial ==True: print(\"This is {}th epoch , loss = {}\".format(i, l)) return W_list, losses def draw(W): W = W[0] x = np.linspace(0.2,0.8,100) y = -(W[0] * x + W[2])/W[1] plt.plot(x,y) for plot in data: if plot[2] == 0: c = 'red' else: c = 'green' plt.scatter(plot[0],plot[1],c=c) def show(W_list): for W in W_list: plt.clf() display.clear_output(wait=True) draw(W) plt.pause(0.001) W_list,losses = train(epoch=10000,n=2,learning_rate=.01,detial=False) show(W_list[:100]) plt.plot(losses) [\u003cmatplotlib.lines.Line2D at 0x7f1b3a14aa50\u003e] ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:4","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"svm.html 线性核SVM 和 高斯核SVM SMO 算法解析 最优化目标 $$\\max_{\\alpha} =\\sum_{i=1}^{m}\\alpha_i - \\sum_{i=1}^{m} \\sum_{j=1}^{m}\\alpha_i\\alpha_jy_iy_jx_i^Tx_j \\tag{1}$$ $$\\text{ s.t. } \\qquad \\alpha_i \\ge 0,\\quad \\sum_{i=1}^{N}\\alpha_iy_i = 1 \\tag{2}$$ 约束条件 $$ $$ 算法原理 我们可以先确定 两个$\\alpha_i,\\alpha_j$. 在例子中设$i=1 , \\quad j=2$. 此时最大化目标： $$arg\\max_{\\alpha_1, \\alpha_2}W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 - \\frac{1}{2}K_{1,1}y_1^2\\alpha_1^2 - \\frac{1}{2}K_{2,2}y_2^2\\alpha_2^2 - K_{1,2}y_1y_2\\alpha_1\\alpha_2 - y_1\\alpha_1\\sum_{i=3}^{m}\\alpha_iy_iK_{i,1} - y_2\\alpha_2\\sum_{i=3}^{m}\\alpha_iy_iK_{i,2} + C \\tag{3}$$ 根据(2) $$\\alpha_1y_1 + \\alpha_2y_2 = -\\sum_{i=3}^{N}\\alpha_iy_i = \\eta$$ 两边同时乘以$y_1,由于y_i^2 = 1$ $$\\alpha_1 = \\eta y_1 - \\alpha_2y_1y_2 \\tag{4}$$ 令： $$v_1 = \\sum^{N}{i=3}\\alpha_iy_iK{i,1}, \\quad v_2 = \\sum^{N}{i=3}\\alpha_iy_iK{i,2} \\tag{5}$$ 将 (4), (5) 带入(3) $$ W(\\alpha_2) = - \\frac{1}{2}K_{1,1}(\\eta - \\alpha_2y_2)^2 - \\frac{1}{2}K_{2,2}\\alpha_2^2 - K_{1,2}y_2\\alpha_2(\\eta - \\alpha_2y_2) - v_1(\\eta - \\alpha_2y_2) - v_2y_2\\alpha_2 + \\alpha_1 + \\alpha_2 + C \\tag{6}$$ 由于需要更新$\\alpha_2$所以令$\\frac{dW}{d\\alpha} = 0$ $$\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -\\alpha_2(K_{1,1} + K_{2,2} - 2K_{1,2}) + K_{1,1}\\eta y_2 - K_{1,2}\\eta y_2 + v_1y_2 - v_2y_2 - y_1y_2 + y_2^2 = 0 \\tag{7}$$ 对(7)式变形，使得$\\alpha_2^new$能被$\\alpha_2^old$表示(而不是用不方便的\\eta)： SVM预测值如下(该式子不需要保留所有的x，因为很多无关的x的alpha都为0，因此alpha需要初始化为0)： $$f(x) = \\sum_{i=1}^{N}\\alpha_iy_iK(x_i,x) + b \\tag{8}$$ 则v可以表示为： $$ v_1 = \\sum^{N}{i=3}\\alpha_iy_iK{1,i} = f(x_1) - \\alpha_1y_1K_{1,1} - \\alpha_2y_2K_{1,2} - b $$ $$v_2 = \\sum^{N}{i=3}\\alpha_iy_iK{2,i} = f(x_2) - \\alpha_1y_1K_{1,2} - \\alpha_2y_2K_{2,2} - b $$ 已知： $$\\alpha_1= (\\eta - \\alpha_2y_2)y_2$$ 可得到： $$v_1 - v_2 = f(x_1) - f(x_2) - K_{1,1}\\eta + K_{1,2}\\eta + \\alpha_2y_2(K_{1,1}+K_{2,2}-2K_{1,2}) \\tag{9}$$ 将(9)带入(7): $$\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -(K_{1,1} + K_{2,2} - 2K_{1,2})\\alpha_2^{new} + (K_{1,1} + K_{2,2}- 2K_{1,2})\\alpha_2^{old} + y_2(y_2 - y_1 + f(x_1) - f(x_2))$$ 记误差项$E_i = f(x_i) - y_i$ 令$\\theta = K_{1,1,}+K_{2,2}-2K_{1,2}$ 可以得到最终表达式： $$\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -\\theta\\alpha_2^{new}+ \\theta\\alpha_2^{old}+y2(E_1-E_2) = 0$$ 得到： $$\\alpha_2^{new} = \\alpha_2^{old} + \\frac{y_2(E_1- E_2)}{\\theta} \\tag{10}$$ 到了这里，如果要更新参数，仅需计算E，和\\theta 然后计算\\alpha2 原始解的修剪 现在考虑约束条件 上面通过对一元函数求极值的方式更新了参数得到了$\\alpha_2^{new,unclipped}$ 现在通过对原始解的修正得到$\\alpha_2^{new,cilpped}$ $$\\alpha_2^{new,unclipped} = \\alpha_2^{old} + \\frac{y_2(E_1- E_2)}{\\theta} \\tag{10}$$ 约束条件（画图分析）： $if \\quad y_1 \\ne y_2 :$ $$ 上界：\\qquad L = max(0, \\quad \\alpha_2^{old} - \\alpha_1^{old})$$ $$ 下界：\\qquad H = max(C, \\quad C+\\alpha_2^{old} - \\alpha_1^{old})$$ $elif \\quad y_1 = y_2 :$ $$ 上界：\\qquad L = max(0, \\quad \\alpha_2^{old} + \\alpha_1^{old} -C)$$ $$ 下界：\\qquad H = max(C, \\quad \\alpha_2^{old} + \\alpha_1^{old})$$ 更新参数都可以计算：$\\alpha_1^{new}$ 由： $$\\alpha_1^{old}y_1 + \\alpha_2^{old}y_2 = \\alpha_1^{new}y_1 + \\alpha_2^{new}y_2 $$ 得到： $$\\alpha_1^{new} = \\alpha_1^{old} + y_1y_2(\\alpha_2^{old} - \\alpha_2^{new})$$ 最后由式(6.17)-\u003e(6.18)可得到： $$b = \\frac{1}{m}\\sum_{s=1}^{m}[1/y_s - \\sum_{m}^{i=1}\\alpha_iy_ix_i^Tx_s]$$ 3.启发式选择变量 上述分析是在从N个变量中已经选出两个变量进行优化的方法，下面分析如何高效地选择两个变量进行优化，使得目标函数下降的最快。 第一个变量的选择 第一个变量的选择称为外循环，首先遍历整个样本集，选择违反KKT条件的$\\alpha_i$作为第一个变量 接着依据相关规则选择第二个变量(见下面分析),对这两个变量采用上述方法进行优化。 当遍历完整个样本集后，遍历非边界样本$(0\u003cα_i\u003cC)$中违反KKT的$\\alpha_i$作为第一个变量，同样依据相关规则选择第二个变量，对此两个变量进行优化。当遍历完非边界样本集后，再次回到遍历整个样本集中寻找，即在整个样本集与非边界样本集上来回切换，寻找违反KKT条件的αiαi作为第一个变量。直到遍历整个样本集后，没有违反KKT条件$\\alpha_i$，然后退出。 边界上的样本对应的$\\alpha_i = 0$或者$\\alpha_i = C$，在优化过程中很难变化，然而非边界样本$0\u003cα_i\u003cC$会随着对其他变量的优化会有大的变化。 KTT条件 $$\\alpha_i = 0 \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b)\\ge1 $$ $$\\alpha_i = C \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b)\\le 1 $$ $$0 \\lt \\alpha_i \\lt C \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b) =1 $$ 第二个变量的选择 SMO称第二个变量的选择过程为内循环，假设在外循环中找个第一个变量记为$\\alpha_1$，第二个变量的选择希望能使$\\alpha_2$有较大的变化，由于$\\alpha_2$是依赖于$|E1−E2|$,当$E1$为正时，那么选择最小的$Ei$作为$E2$,如果$E1$为负，选择最大$Ei$作为$E2$，通常为每个样本的$Ei$保存在一个列表中，选择最大的$|E1−E2|$来近似最大化步长。 有时按照上述的启发式选择第","date":"2023-01-03","objectID":"/svm/:0:0","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"定义训练集 $$X_{train} \\in \\R^{n \\times m}$$ $$x_i \\in \\R^n,即每一个样本有n个特征$$ $$label \\in {-1,1},二分类问题$$ ","date":"2023-01-03","objectID":"/svm/:0:1","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"多种核函数 def LinearKernel(x_i, x_j): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") return np.dot(x_i.T, x_j) def GaussKernel(x_i, x_j, sigmoid): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") if sigmoid \u003c= 0: raise Exception(\"sigmoid must be a positive number\") return np.exp(-np.dot((x_i - x_j).T, (x_i - x_j))/(2 * sigmoid**2)) def PolyKernel(x_i, x_j, d): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") if d \u003c 0: raise Exception(\"d must be a Semi-positive number\") return LinearKernel(x_i, x_j)**d def LaplaceKernel(x_i, x_j, s): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") if s \u003c= 0: raise Exception(\"sigmoid must be a positive number\") # print(np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / sigmoid)) return np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / s)[0][0] def SigmoidKernel(x_i, x_j, beta, theta): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") if theta \u003e= 0: raise Exception(\"theta must be a negetive number\") if beta \u003c= 0: raise Exception(\"theta must be a positive number\") return np.tanh(beta * LinearKernel(x_i, x_j) + theta) def K(x_i, x_j, kernel = \"linear\", s = .5, beta = 1, theta = -1, d = 2): # print(x_i.shape, x_j.shape) kernel = kernel.lower() try: if kernel == 'linear': return LinearKernel(x_i, x_j) elif kernel == 'gauss': return GaussKernel(x_i, x_j, s) elif kernel == 'poly': return PolyKernel(x_i, x_j, d) elif kernel == 'laplace': return LaplaceKernel(x_i, x_j, s) elif kernel == 'sigmoid': return SigmoidKernel(x_i, x_j, beta, theta) except Exception as err: print('An exception happened: ' + str(err)) if __name__ == \"__main__\": x_i = np.ones((10,1)) x_j = np.random.randn(10,1) print(np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / 1)) print(K(x_i,x_j,kernel=\"Laplace\", s=1)) [[0.005973]] 0.005973003723489288 ","date":"2023-01-03","objectID":"/svm/:1:0","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"生成同心圆数据 import numpy as np def load(type = \"circle\"): x = np.random.uniform(-1,1,(100,1)) y = np.random.uniform(-1,1,(100,1)) x_train = np.c_[x,y].T print(x_train.shape) label_train = np.ones((100,1)) mask = (x**2 + y**2 ) \u003c .5 label_train[mask] = -1 x1 = np.random.uniform(-1,1,(100,1)) y1 = np.random.uniform(-1,1,(100,1)) x_test = np.c_[x1,y1].T print(x_test.shape) label_test = np.ones((100,1)) mask = (x1**2 + y1**2 ) \u003c .5 label_test[mask] = -1 return x_train, label_train, x_test, label_test if __name__ == \"__main__\": x_train, label_train, x_test, label_test = load() print(x_train.shape, label_train.shape, x_test.shape, label_test.shape) (2, 100) (2, 100) (2, 100) (100, 1) (2, 100) (100, 1) ","date":"2023-01-03","objectID":"/svm/:1:1","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"参照第一个SMO推导笔记需要实现以下功能： 初始化参数（主要是\\alpha） 由于采用缓存（用一个列表记录）所有的$E_i = y_i - f(x_i)$ 所以每一次更新参数$\\alpha$后都需要更新$E_i, E_j$ 因为由KKT条件约束，所以需要对最后的结果进行修剪 所以需要实现 clip() $f(index_i)用于实现对训练集的某一个特征向量计算预测值$ $predict(x_i)用于预测任意给定的特征向量x_i$ select()函数的内循环和外循环用于选择最不满足KKT条件的并且能够使得更新效果最明显的$\\alpha_i \\quad \\alpha_j$ loss()用于计算E update_a2()用于更新$\\alpha_2$ update_a1()使用$\\alpha_2$和$\\alpha_1^{old}$更新$\\alpha_1$ SMO()是smo算法的主循环 以上函数与SMO算法紧密相关，为了方便参数，数据集，的传输将他们放到一个SMO类中实现 class SMO: def __init__(self, x, y, kernel = \"Laplace\", C=10): self.x = copy.deepcopy(x) self.y = copy.deepcopy(y) self.m = x.shape[1] self.n = x.shape[0] self.kernel = kernel self.C = C def init(self): # self.w = np.random.randn(self.n, 1) self.b = np.zeros((1, 1)) self.a = np.zeros((self.m, 1)) E = [] for i in range(0, self.m): E.append(self.loss(i)) self.E = E # 每次更新参数后需要更新E def updateE(self, i, j): self.E[i] = self.loss(i) self.E[j] = self.loss(j) def clip(self, index_1, index_2, old_1, old_2): # get H, L alpha = self.a[index_2,:][0] if self.y[index_1, :] != self.y[index_2, :]: L = max(0.0, old_2[0] - old_1[0]) H = max(self.C, self.C + old_2[0] - old_1[0]) else: # print(\"----------\" , self.C, old_2[0], self.C + old_2[0],'-------------') L = max(0.0, old_2[0] + old_1[0] - self.C) H = max(self.C, old_2[0] + old_1[0]) if alpha \u003c L: return L elif alpha \u003e H: return H else: return alpha def f(self, x_index): k = np.zeros(self.y.shape) for i in range(0, self.m): k[i,:] = copy.deepcopy(K(self.x[:,i].reshape(-1,1), self.x[:,x_index].reshape(-1,1), kernel = self.kernel)) return np.sum(self.a * self.y * k)+self.b # 此处是选择第二个变量，第一个变量仅需要无脑便利就好了 # 需要传入第一个变量的index以计算E_1 # 是否可以将select写成一个生成器？ def select(self): for i in range(0, self.m): # label用于标志是否违反KKT label = False temp = self.y[i, :] * self.f(i) if self.a[i, :] == 0: if temp \u003c 1 : label = True elif 0 \u003c self.a[i, :] and self.a[i, :] \u003c self.C: if temp \u003e 1: label = True else: if temp != 1: label = True # 如果违反KKT条件，进入内循环选择第二个a if label == True and self.E[i] \u003c= 0: j = np.argmax(np.array(self.E)) yield i,j if label == True and self.E[i] \u003e0: j = np.argmin(np.array(self.E)) yield i,j # 需要得到边界变量的下标值 boolen = (self.a \u003e 0) \u0026 (self.a \u003c self.C) edgeVar = [] for i in range(0, len(boolen)): if boolen[i] == True: edgeVar.append(i) for i in edgeVar: # label用于标志是否违反KKT label = False temp = self.y[i, :] * self.f(i) if self.a[i, :] == 0: if temp \u003c 1 : label = True elif 0 \u003c self.a[i, :] and self.a[i, :] \u003c self.C: if temp \u003e 1: label = True else: if temp != 1: label = True # 如果违反KKT条件，进入内循环选择第二个a if label == True and self.E[i] \u003c= 0: j = np.argmax(np.array(self.E)) yield i,j if label == True and self.E[i] \u003e0: j = np.argmin(np.array(self.E)) yield i,j # E_i = f(x_i) - y_i def loss(self, index): return self.f(index) - self.y[index, :] def update_a2(self, alpha2_old, index_1, index_2): theta = K(self.x[:,index_1].reshape(-1,1), self.x[:,index_1].reshape(-1,1), kernel = self.kernel) + K(self.x[:,index_2].reshape(-1,1), self.x[:,index_2].reshape(-1,1), kernel = self.kernel) - 2*K(self.x[:,index_1].reshape(-1,1), self.x[:,index_2].reshape(-1,1), kernel = self.kernel) if theta \u003c 0.001 and theta \u003e= 0: theta = 0.001 if theta \u003e -0.001 and theta \u003c0: theta = 0.001 dE = self.E[index_1] - self.E[index_2] # print(\"in update_a2 theta:{}, dE:{}, y2:{}\".format(theta, dE, self.y[index_2])) return alpha2_old + (self.y[index_2] * dE) / theta def update_a1(self, alpha1_old, alpha2_old, alpha2_new, index_1, index_2): return alpha1_old + self.y[index_1] * self.y[index_2] * (alpha2_old - alpha2_new) def SMO(self, maxtimes): for i in range(0, maxtimes): if i % 10 == 0: print(\"this is {}th loop.\".format(i)) for i, j in self.select(): temp = copy.deepcopy(self.a[j]) self.a[j] = self.update_a2(self.a[j], i, j) self.a[j] = self.clip(i, j, self.a[i], temp) self.a[i] = self.update_a1(self.a[i], temp, self.a[j], i, j) self.updateE(i, j) # 更新b self.b = np.sum(1/self.y)/self.m for i in range(0, self.m): self.b -= (self.f(i)/self.m) print(self.b) def predict(self, x): k = np.zeros(self.y.shape) for i in range(0,","date":"2023-01-03","objectID":"/svm/:1:2","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"导入数据 此处生成同心圆数据，以区别线性核和非线性核之间的区别 x_train, y_train, x_test, y_test = load() # plt.scatter(x_train[0, :], x_train[1, :], c = y_train[:, 0]) (2, 100) (2, 100) ","date":"2023-01-03","objectID":"/svm/:1:3","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"使用高斯核的SVM 此处$\\sigma = 0.5$,取值为1时，准确率就很低了，不知道怎么回事（先补一下核函数更多的技术了， 狗头.jpg） smo = SMO(x_train, y_train, C = 2, kernel = \"gauss\") smo.init() smo.SMO(110) y_pred = smo.predictAll(x_test) evaluate(y_test, y_pred) draw_svm(smo) this is 0th loop. this is 10th loop. this is 20th loop. this is 30th loop. this is 40th loop. this is 50th loop. this is 60th loop. this is 70th loop. this is 80th loop. this is 90th loop. this is 100th loop. 1.0542578147143928 The roc_auc_score is 0.982048143614851 The accuracy is 0.89 precision recall f1-score support class0 0.80 1.00 0.89 43 class1 1.00 0.81 0.89 57 accuracy 0.89 100 macro avg 0.90 0.90 0.89 100 weighted avg 0.91 0.89 0.89 100 ","date":"2023-01-03","objectID":"/svm/:1:4","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"使用线性核的SVM smo = SMO(x_train, y_train, C = 2, kernel = \"linear\") smo.init() smo.SMO(110) y_pred = smo.predictAll(x_test) evaluate(y_test, y_pred) draw_svm(smo) this is 0th loop. this is 10th loop. this is 20th loop. this is 30th loop. this is 40th loop. this is 50th loop. this is 60th loop. this is 70th loop. this is 80th loop. this is 90th loop. this is 100th loop. 0.27041462716608683 The roc_auc_score is 0.4618523051815585 The accuracy is 0.48 precision recall f1-score support class0 0.41 0.49 0.45 43 class1 0.55 0.47 0.51 57 accuracy 0.48 100 macro avg 0.48 0.48 0.48 100 weighted avg 0.49 0.48 0.48 100 ","date":"2023-01-03","objectID":"/svm/:1:5","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"调用之前写过的决策树C4.5 from dt import buildTree, Node, predictAll, predict, draw_tree import pandas as pd X_train = np.r_[x_train, y_train.T] X_train = pd.DataFrame(X_train.T, columns=[\"x\",'y',\"label\"]) X_test = np.r_[x_test, y_test.T] X_test = pd.DataFrame(X_test.T, columns=[\"x\",'y',\"label\"]) Y_test = np.array(list(X_test[\"label\"])).reshape(-1,1) root = Node(Dataset=X_train, attrList = ['x','y']) root = buildTree(root) Y_pred = predictAll(root ,X_test) evaluate(Y_test, Y_pred) draw_tree(root) plt.scatter(X_train[\"x\"], X_train[\"y\"], c = 0 - X_train[\"label\"]) The roc_auc_score is 0.7105263157894737 The accuracy is 0.67 precision recall f1-score support class0 0.57 1.00 0.72 43 class1 1.00 0.42 0.59 57 accuracy 0.67 100 macro avg 0.78 0.71 0.66 100 weighted avg 0.81 0.67 0.65 100 \u003cmatplotlib.collections.PathCollection at 0x7f523e323310\u003e ","date":"2023-01-03","objectID":"/svm/:1:6","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"分析 对于同心圆这种线性不可分的数据，使用linear kernel只能得到约50/100的准确度 使用决策树，这里由于决策变量只有x，y所以，这里的决策树虽多两层，对于特征向量较小的数据集不友好 使用拉普拉斯核（测试时用的拉普拉斯核，准确率略高于高斯核） 或者 高斯核在该种线性不可分的数据集中起到了很好的升维作用 使用神经网络可以得到很好的效果（在神经网络实现的时候，测试过该数据集，随着层数的增加，能达到99/100的准确率） import tensorflow==2.0.0 Cannot run import tensorflow because of system compatibility. AI Studio prepared an entire environment based on PaddlePaddle already. Please use PaddlePaddle to build your own model or application. ","date":"2023-01-03","objectID":"/svm/:1:7","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"参考列表 Wialliam Fiset’s Algorithms Keon’s Algorithms Xtaci’s Algorithms Labuladong’s Fucking-Algorithms Geekxh’s Hello-Algorithms Algorithm-Visualizer Justjavac’s Free-Programming-Books Imarvinle’s Awesome-CS-Books Jeffe’s Algorithms Course 主要关注其中 操作系统、算法、图形学、设计模式、游戏引擎、C#、 C/C++ 、编译器中间语言、元编程 Jeffe’s Crouse 用于学习，Wialliam Fiset’s Algorithms, Keon’s Algorithms, Xtaci’s Algorithms 用于拓展补充，labuladong 的算法小抄, 小浩算法 用于练习 这是一个利用空闲时间学习的长期计划，或许需要几年时间，学不完没关系，学一点赚一点，加油！ ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:0:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"数据结构 Balance Trees AVL Tree (recursive) Red Black Tree (recursive) Binary Search Tree Splay Tree Dynamic Array Dynamic Array (integer only, fast) Fenwick Tree Fenwick Tree (range query, point update) (range update, point query) Fibonacci Heap Hashtable Hashtable (double hashing) Hashtable (linear probing) Hashtable (quadratic probing) Hashtable (sparate chaning) Linked List Priority Queue Min Binary Heap Min Indexed Binary Heap (sorted key-value pairs, similar to hash-table) Min D-Heap Min Indexed D-Heap (sorted key-value pairs, similar to hash table) Queue Queue (integer only, fixed size, fast) Queue (linked list, generic) Segment Tree Segement Tree (array based, compact) Segment Tree (linked list generic) Sparse Table Stack Stack (integer only, fixed size, fast) Stack (linked list, generic) Stack (array, generic) Suffix Array Suffix Array (O(n^2logn)) Suffix Array (O(nlog^2(n)) Suffix Array (O(nlogn)) Trie Union Find ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:1:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"数组 Array shuffle 2D Array ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:2:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"动态编程 Coin change problem Edit distance (iterative) Edit distance (recursive) Knapsack 0/1 Knapsack unbounded (0/inf) Maximum contiguous subarray Longest Common Subsequence (LCS) Longest Increasing Subsequence (LIS) Longest Palindrome Subsequence (LPS) Traveling Salesman Problem (dynamic programming, iterative) Traveling Salesman Problem (dynamic programming, recursive) Minimum Weight Perfect Matching (iterative, complete graph) Examples: ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:3:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"Adhoc Magic Cows Narrow Art Gallery ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:3:1","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"Tiling problems Tiling Dominoes Tiling Dominoes and Trominoes Mountain Scenes ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:3:2","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"计算几何 Angle between 2D vectors - O(1) Angle between 3D vectors - O(1) Circle-circle intersection point(s) - O(1) Circle-line intersection point(s) - O(1) Circle-line segment intersection point(s) - O(1) Circle-point tangent line(s) - O(1) Closest pair of points (line sweeping algorithm) - O(nlog(n)) Collinear points test (are three 2D points on the same line) - O(1) Convex hull (Graham Scan algorithm) - O(nlog(n)) Convex hull (Monotone chain algorithm) - O(nlog(n)) Convex polygon area - O(n) Convex polygon cut - O(n) Convex polygon contains points - O(log(n)) Coplanar points test (are four 3D points on the same plane) - O(1) Line class (handy infinite line class) - O(1) Line-circle intersection point(s) - O(1) Line segment-circle intersection point(s) - O(1) Line segment to general form (ax + by = c) - O(1) Line segment-line segment intersection - O(1) Longitude-Latitude geographic distance - O(1) Point is inside triangle check - O(1) Point rotation about point - O(1) Triangle area algorithms - O(1) [UNTESTED] Circle-circle intersection area - O(1) [UNTESTED] Circular segment area - O(1) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:4:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"图论 Tree algorithms 🎥 Rooting an undirected tree - O(V+E) 🎥 Identifying isomorphic trees - O(?) 🎥 Tree center(s) - O(V+E) Tree diameter - O(V+E) 🎥 Lowest Common Ancestor (LCA, Euler tour) - O(1) queries, O(nlogn) preprocessing Network flow Bipartite graph verification (adjacency list) - O(V+E) 🎥 Max flow \u0026 Min cut (Ford-Fulkerson with DFS, adjacency list) - O(fE) Max flow \u0026 Min cut (Ford-Fulkerson with DFS, adjacency matrix) - O(fV2) 🎥 Max flow \u0026 Min cut (Edmonds-Karp, adjacency list) - O(VE2) 🎥 Max flow \u0026 Min cut (Capacity scaling, adjacency list) - O(E2log2(U)) 🎥 Max flow \u0026 Min cut (Dinic’s, adjacency list) - O(EV2) or O(E√V) for bipartite graphs Maximum Cardinality Bipartite Matching (augmenting path algorithm, adjacency list) - O(VE) Min Cost Max Flow (Bellman-Ford, adjacency list) - O(E2V2) Min Cost Max Flow (Johnson’s algorithm, adjacency list) - O(E2Vlog(V)) Main graph theory algorithms Articulation points/cut vertices (adjacency list) - O(V+E) Bellman-Ford (edge list, negative cycles, fast \u0026 optimized) - O(VE) 🎥 Bellman-Ford (adjacency list, negative cycles) - O(VE) Bellman-Ford (adjacency matrix, negative cycles) - O(V3) 🎥 Breadth first search (adjacency list) - O(V+E) Breadth first search (adjacency list, fast queue) - O(V+E) Bridges/cut edges (adjacency list) - O(V+E) Find connected components (adjacency list, union find) - O(Elog(E)) Find connected components (adjacency list, DFS) - O(V+E) Depth first search (adjacency list, iterative) - O(V+E) Depth first search (adjacency list, iterative, fast stack) - O(V+E) 🎥 Depth first search (adjacency list, recursive) - O(V+E) 🎥 Dijkstra’s shortest path (adjacency list, lazy implementation) - O(Elog(V)) 🎥 Dijkstra’s shortest path (adjacency list, eager implementation + D-ary heap) - O(ElogE/V(V)) 🎥 Eulerian Path (directed edges) - O(E+V) 🎥 Floyd Warshall algorithm (adjacency matrix, negative cycle check) - O(V3) Graph diameter (adjacency list) - O(VE) 🎥 Kahn’s algorithm (topological sort, adjacency list) - O(E+V) Kruskal’s min spanning tree algorithm (edge list, union find) - O(Elog(E)) 🎥 Kruskal’s min spanning tree algorithm (edge list, union find, lazy sorting) - O(Elog(E)) Kosaraju’s strongly connected components algorithm (adjacency list) - O(V+E) 🎥 Prim’s min spanning tree algorithm (lazy version, adjacency list) - O(Elog(E)) Prim’s min spanning tree algorithm (lazy version, adjacency matrix) - O(V2) 🎥 Prim’s min spanning tree algorithm (eager version, adjacency list) - O(Elog(V)) Steiner tree (minimum spanning tree generalization) - O(V3 + V2 _ 2T + V _ 3T) 🎥 Tarjan’s strongly connected components algorithm (adjacency list) - O(V+E) 🎥 Topological sort (acyclic graph, adjacency list) - O(V+E) Topological sort (acyclic graph, adjacency matrix) - O(V2) Traveling Salesman Problem (brute force) - O(n!) 🎥 Traveling Salesman Problem (dynamic programming, iterative) - O(n22n) Traveling Salesman Problem (dynamic programming, recursive) - O(n22n) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:5:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"线性代数 Freivald’s algorithm (matrix multiplication verification) - O(kn2) Gaussian elimination (solve system of linear equations) - O(cr2) Gaussian elimination (modular version, prime finite field) - O(cr2) Linear recurrence solver (finds nth term in a recurrence relation) - O(m3log(n)) Matrix determinant (Laplace/cofactor expansion) - O((n+2)!) Matrix inverse - O(n3) Matrix multiplication - O(n3) Matrix power - O(n3log(p)) Square matrix rotation - O(n2) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:6:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"数学 Arbitrary Integer [UNTESTED] Chinese remainder theorem Prime number sieve (sieve of Eratosthenes) - O(nlog(log(n))) Prime number sieve (sieve of Eratosthenes, compressed) - O(nlog(log(n))) Prime test(trial division) Prime test(Miller-Rabin’s method) Totient function (phi function, relatively prime number count) - O(n1/4) Totient function using sieve (phi function, relatively prime number count) - O(nlog(log(n))) Extended euclidean algorithm - ~O(log(a + b)) Greatest Common Divisor (GCD) - ~O(log(a + b)) Fast Fourier transform (quick polynomial multiplication) - O(nlog(n)) Fast Fourier transform (quick polynomial multiplication, complex numbers) - O(nlog(n)) Primality check - O(√n) Primality check (Rabin-Miller) - O(k) Least Common Multiple (LCM) - ~O(log(a + b)) Modular inverse - ~O(log(a + b)) Prime factorization (pollard rho) - O(n1/4) Relatively prime check (coprimality check) - ~O(log(a + b)) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:7:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"搜索算法 Binary search (real numbers) - O(log(n)) Interpolation search (discrete discrete) - O(n) or O(log(log(n))) with uniform input Ternary search (real numbers) - O(log(n)) Ternary search (discrete numbers) - O(log(n)) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:8:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"排序算法 Bubble sort - O(n2) Bucket sort - Θ(n + k) Counting sort - O(n + k) Heapsort - O(nlog(n)) Insertion sort - O(n2) Mergesort - O(nlog(n)) Quicksort (in-place, Hoare partitioning) - Θ(nlog(n)) Quicksort3 (Dutch National Flag algorithm) - Θ(nlog(n)) Selection sort - O(n2) Radix sort - O(n*w) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:9:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"字符串算法 Booth’s algorithm (finds lexicographically smallest string rotation) - O(n) Knuth-Morris-Pratt algorithm (finds pattern matches in text) - O(n+m) Longest Common Prefix (LCP) array - O(nlog(n)) bounded by SA construction, otherwise O(n) 🎥 Longest Common Substring (LCS) - O(nlog(n)) bounded by SA construction, otherwise O(n) 🎥 Longest Repeated Substring (LRS) - O(nlog(n)) Manacher’s algorithm (finds all palindromes in text) - O(n) Rabin-Karp algorithm (finds pattern match positions in text) - O(n+m) Substring verification with suffix array - O(nlog(n)) SA construction and O(mlog(n)) per query ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:10:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"其他 Bit manipulations - O(1) List permutations - O(n!) 🎥 Power set (set of all subsets) - O(2n) Set combinations - O(n choose r) Set combinations with repetition - O((n+r-1) choose r) Sliding Window Minimum/Maximum - O(1) Square Root Decomposition - O(1) point updates, O(√n) range queries Unique set combinations - O(n choose r) Lazy Range Adder - O(1) range updates, O(n) to finalize all updates Linear congruential generator Maximum subarray problem Bit-Set Double linked list Skip list Dynamic order statistics Interval tree Prefix Tree(Trie) Suffix Tree B-Tree hash Hash by multiplication Hash table Universal hash function Perfect hash Java’s string hash FNV-1a string hash SimHash Bloom Filter 密码学 SHA-1 Message Digest Algorithm MD5 Base64 Push–Relabel algorithm Huffman Coding Word segementation A* algorithm K-Means Knuth–Morris–Pratt algorithm Disjoint-Set 8-Queen Problem ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:11:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"记录我的所思所想和努力生活的每一天！🧠🔆🌃 ","date":"2023-01-03","objectID":"/record/:0:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.1 多崎作的巡礼之年 你要记得那些大雨中为你撑伞☔的人 帮你挡住外来之物的人 黑暗中默默抱紧你的人 逗你笑的人 陪你彻夜聊天的人 坐车来看望你的人 陪你哭过的人 在医院陪你的人 总是以你为重的人 带着你四处游荡的人 说想念你的人💕 是这些人组成你生命中一点一滴的温暖 是这些温暖使你远离阴霾 是这些温暖使你成为善良的人 ","date":"2023-01-03","objectID":"/record/:1:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.5 忘掉种过的花，重新的出发，放弃理想吧 🥹 ","date":"2023-01-03","objectID":"/record/:2:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.5 反驳对《孤勇者》无病呻吟的恶评：如果平凡是病， 那么大多数人没有无病呻吟 。如果孤独是病，那么所有人都在无病呻吟。 ","date":"2023-01-03","objectID":"/record/:3:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.6 听歌 《那女孩对我说》，“那女孩对我说，说我保护她的梦” ","date":"2023-01-03","objectID":"/record/:4:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.28 《化身孤岛的蓝鲸》 我是只化身孤岛的蓝鲸 有着最巨大的身影 鱼虾在身侧穿行 也有飞鸟在背上停 我路过太多太美的奇景 如同伊甸般的仙境 而大海太平太静 多少故事无人倾听 我爱地中海的天晴 爱西伯利亚的雪景 爱万丈高空的鹰 爱肚皮下的藻荇 我在尽心尽力地多情 ","date":"2023-01-03","objectID":"/record/:5:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.19 “在信息时代，进入编程领域的壁垒完全不存在了。即使有也是自我强加的。如果你想着手去开发一些全新的东西，你不需要数百万美元的资本。你只需要足够的比萨和健怡可乐存在你的冰箱里，有一台便宜的PC用于工作，以及让你坚持下来的奉献精神。我们睡在地板上。我们跋山涉水。” —–约翰·卡马克 卡马克在计算机图形学方面做出了很多突出贡献，他是一个黑客，梦想家，信念坚定的理想主义者 💕💕💕💕！！ ","date":"2023-01-03","objectID":"/record/:6:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.19 孤独又自由 ","date":"2023-01-03","objectID":"/record/:7:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.25 听歌《没有理想的人不伤心》-新裤子 你曾热爱的那个人 这一生也不会再见面 你等在这文化的废墟上 已没人觉得你狂野 那些让人敬仰的神殿 只在无知的人心中灵验 我住在属于我的猪圈 这一夜无眠 我不要在失败孤独中死去 我不要一直活在地下里 物质的骗局 匆匆的蚂蚁 没有文化的人不伤心 我不要在失败孤独中死去 歌曲似乎讲述了这样一个故事：因为某个原因原本的生活遭到背叛（因为原曲中有一个最恨的人：推测是背叛）变得支离破碎，随之破灭的是我的热情和理想。我去了自己最爱的书店，这是他曾经与我一起去过的书店。在这里你陷入回忆，回忆起曾今的理想和努力，原来都被现实的金钱绑架。陷入物质的骗局，你的人生像地下的蚂蚁，碌碌，失败 且孤独。我愤怒于世人不懂我心中的热情，愤怒于这个世界不给理想主义者留下生存空间。但是我不甘心在失败孤独中死去，伤心伤心伤心。。。 ","date":"2023-01-03","objectID":"/record/:8:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.25 Free Software Foundation GNU 宣言 Emacs 一个自由软件编辑器 万圣节文档(一系列来源可靠的备忘录)，终于知道为什么这么多人不喜欢微软了 Eric S. Raymond五部曲 关于开源世界的一切 通过这些能了解开源软件诞生的起因和时代背景 ","date":"2023-01-03","objectID":"/record/:9:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"202210.26 “最后一个问题。罗素勋爵，假定这段录像将被我们的后人看到，如同死海古卷一般，在一千年后被人看见，你觉得有什么该对他们那一代人说的？有关您的一生？以及一生的感悟” 节选\rI should like to say two things, one intellectual and one moral. The intellectual thing I should want to say is this: When you are studying any matter, or considering any philosophy, ask yourself only what are the facts and what is the truth that the facts bear out. Never let yourself be diverted either by what you wish to believe, or by what you think would have beneficent social effects if it were believed. But look only, and solely, at what are the facts. That is the intellectual thing that I should wish to say. The moral thing I should wish to say…I should say： love is wise, hatred is foolish. In this world which is getting more closely and closely interconnected we have to learn to tolerate each other, we have to learn to put up with the fact that some people say things that we don’t like. We can only live together in that way and if we are to live together and not die together we must learn a kind of charity and a kind of tolerance which is absolutely vital to the continuation of human life on this planet.\" —- Bertrand Russell. ","date":"2023-01-03","objectID":"/record/:10:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.2 脑洞：如果人类实现永生那么衡量商品价格的东西还是社会必要劳动时间么？ ","date":"2023-01-03","objectID":"/record/:11:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.7 《窗子》 红叶落到床头，可不知缘由。 这是冬天还是秋天？在你的树冠和枝丫。 风已来过几次，咯吱咯吱。 这窗头不远也不近，是我的别有用心。 ","date":"2023-01-03","objectID":"/record/:12:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.11 电影《爱玛》里，当哈丽特问伍德豪斯小姐：“你为何不结婚呢？你如此天生丽质。” 伍德豪斯回答，自己没有结婚的想法，在情愫未到时，不必改变现状，等到深陷爱河时，想法自然会改变。 就像那句话：智者不入爱河，愚者自甘堕落，遇你难做智者，甘愿沦为愚者。 ","date":"2023-01-03","objectID":"/record/:13:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.11 错误 - 郑愁予 我打江南走过 那等在季节里的容颜如莲花的开落 东风不来，三月的柳絮不飞 你的心如小小的寂寞的城 恰若青石的街道向晚 跫音不响，三月的春帷不揭 你的心是小小的窗扉紧掩 我达达的马蹄是美丽的错误 我不是归人，是个过客。 这诗真美啊！ ","date":"2023-01-03","objectID":"/record/:14:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.22 《起风了》改编自日本歌手高桥优谱曲、作词并演唱的歌曲《ヤキモチ》 原版表达了一种干净的喜欢和爱恋，歌词有一种直击心灵的真实感， 非常动情。改编讲述了一个步履蹒跚的老人回到了故乡， 没有亲切而是近乡情怯。故乡的天空像以前那么温暖， 随着风吹起， 想起了往事…… 节选\r我终将青春还给了她 连同指尖弹出的盛夏 心之所动 就随风去了\r呜呜呜， 太好哭了。 ","date":"2023-01-03","objectID":"/record/:15:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.23 温暖是治疗世间一切痛苦的良药，还有孤独也是。 ","date":"2023-01-03","objectID":"/record/:16:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.12.6 南京大屠杀纪念 美国对印第安人实施种族灭绝的历史事实和现实证据 ","date":"2023-01-03","objectID":"/record/:17:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.1.6 祝我生日快乐！ 新的一年，孤独为伴，风雨兼程！ 在今后的每一年，我希望保持真诚和坦率，审慎和敏锐。 希望所有向着理想前进的人们，披荆斩棘，勇往直前。 ","date":"2023-01-03","objectID":"/record/:18:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.1.8 阳光灿烂的日子 或许我读不懂姜文的晦涩的镜头语言 但是 久远的，青春的，似真似幻的记忆涌入脑中，让我如此难过和手足无措。 今天是悲伤的🥹🥹🥹。 ","date":"2023-01-03","objectID":"/record/:19:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.1.22 流浪地球 ","date":"2023-01-03","objectID":"/record/:20:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.1.30 这个时代以及此前此后的时代, 共产主义是人类最美好的理想。 ","date":"2023-01-03","objectID":"/record/:21:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.2 As I Began to Love Myself 卓别林 节选\rAs I began to love myself I found that anguish and emotional suffering are only warning signs that I was living against my own truth. Today, I know, this is AUTHENTICITY. As I began to love myself I understood how much it can offend somebody as I try to force my desires on this person, even though I knew the time was not right and the person was not ready for it, and even though this person was me. Today I call it RESPECT. As I began to love myself I stopped craving for a different life, and I could see that everything that surrounded me was inviting me to grow. Today I call it MATURITY. As I began to love myself I understood that at any circumstance, I am in the right place at the right time, and everything happens at the exactly right moment, so I could be calm. Today I call it SELF-CONFIDENCE. As I began to love myself I quit stealing my own time, and I stopped designing huge projects for the future. Today, I only do what brings me joy and happiness, things I love to do and that make my heart cheer, and I do them in my own way and in my own rhythm. Today I call it SIMPLICITY. As I began to love myself I freed myself of anything that is no good for my health – food, people, things, situations, and everything that drew me down and away from myself. At first I called this attitude a healthy egoism. Today I know it is LOVE OF ONESELF. As I began to love myself I quit trying to always be right, and ever since I was wrong less of the time. Today I discovered that is MODESTY. As I began to love myself I refused to go on living in the past and worry about the future. Now, I only live for the moment, where EVERYTHING is happening. Today I live each day, day by day, and I call it FULFILLMENT. As I began to love myself I recognized that my mind can disturb me and it can make me sick. But As I connected it to my heart, my mind became a valuable ally. Today I call this connection WISDOM OF THE HEART. We no longer need to fear arguments, confrontations or any kind of problems with ourselves or others. Even stars collide, and out of their crashing new worlds are born. Today I know THAT IS LIFE! ","date":"2023-01-03","objectID":"/record/:22:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.4 路人 西贝不知为何，明明想和你说话。却骗你说，风雨正好，该去写点诗句。 不必嘲讽我，你笑出声来，我也当是天籁。 不必怀有敌意，你所有心计，我都当是你对我的心意。 我的宿命分两段，未遇见你时，和遇见你以后。 你治好我的忧郁，而后赐我悲伤。 忧郁和悲伤之间的片刻欢喜，透支了我生命全部的热情储蓄。 想饮一些酒，让灵魂失重，好被风吹走。 可一想到终将是你的路人，便觉得，沦为整个世界的路人。 风虽大，都绕过我灵魂。 ","date":"2023-01-03","objectID":"/record/:23:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.4 转自新华社下的评论 目前我们的年轻人大致可分为三类 第一类熟悉历史了解过往，甚至真正读过一些选论，能站在历史的高度以发展的眼光全面的思考问题。他们对犯过的错误和遭受过的挫折有一定认识，深知这一路走来的不容易。因此他们能较为全面的分析当下，既能指出不足，也能看到进步。他们对未来抱有希望，怀揣着使命感，有望成为社会的中坚力量。 第二类对历史有粗略了解，或仅对特定时期有较为深入的研究，知道 选 论 的某些片段，但由于缺乏全面认识，想法往往趋于片面。他们怀念曾经的辉煌，崇拜老一辈，但却忽视了每个时代都有困难要克服，都有问题要解决。他们难以接受现在的不足，看不起取得的进步，经常借古讽今，担心甚至认定路已经走歪，对未来多为悲观态度。 第三类则陷于历史虚无，谜语人，乐子，无情的烂梗机器，搞笑的怪话大王。发生过的事，书本上的话，于他们而言不过是梗罢了。自认为看透了一切，但由于对历史缺乏认识，实质上是极容易被带偏思想的。他们是可悲的，首先战斗力上就不行，除了在网络上抱团发泄情绪外，别无所长。他们看不见努力和进步，把自己埋在阴谋论之中。他们的知识水平也不够，不足以让他们分辨出事物的真假对错。他们更不知道自己的言论在他人看来是多么的不解和迷惑，仿佛魔怔了一般。” ","date":"2023-01-03","objectID":"/record/:24:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.4 “这里的每一个人都是囚徒。” ","date":"2023-01-03","objectID":"/record/:25:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.5 suicide.com 这从来都是不容易的！ ","date":"2023-01-03","objectID":"/record/:26:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.5 未均等的享受成果，也不必承担相应义务 ","date":"2023-01-03","objectID":"/record/:27:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.6 无论我们怎么去粉饰学生时代，或常有的刻苦学习，或时有的情窦初开。 不得不承认，我们从没有真正学习和思考，也没有真正去爱。 仅有的是，为虚假目标努力奋斗 和 被荷尔蒙支配的欲望。 ","date":"2023-01-03","objectID":"/record/:28:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.8 我们就这样扬着船帆奋力前进,逆水行舟,而浪潮奔流不歇,不停地将我们推回到过去。————《了不起的盖茨比》 ","date":"2023-01-03","objectID":"/record/:29:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.9 《呓语》1 我将这封信长埋地底 亲爱的大地 因何在倾听我的疑问 无边的星空也为你带来迷惘？ 短暂的万古代长夜里 我想听听你的呓语 是否同样向往壮阔和寂寞？ ","date":"2023-01-03","objectID":"/record/:30:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.12 《岁月神偷》 时间是让人猝不及防的东西 晴时有风阴有时雨 争不过朝夕 又念着往昔 ","date":"2023-01-03","objectID":"/record/:31:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.14 The Communist Manifesto 我想追求的是爱情的自由，性的自由。这种自由与婚姻、家庭、财产无关。 可遗憾的是，我所在的时代，共产主义遥遥无期。那就这样吧！ ","date":"2023-01-03","objectID":"/record/:32:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.16 曾经有一份真诚的爱情摆在我面前，可是我没有去珍惜，等到失去的时候才后悔莫及，尘世间最痛苦的事莫过于此，如果上天能够给我一个再来一次的机会，我会对那个女孩说三个字，我爱你，如果非要在这份爱上加一个期限，我希望是一万年…… ","date":"2023-01-03","objectID":"/record/:33:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.17 这是上中学时看过的一部电影 《HINOKIO》 中的小插曲，映像很深刻 ","date":"2023-01-03","objectID":"/record/:34:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.18 不值得等待的就不要不要等待！ ","date":"2023-01-03","objectID":"/record/:35:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.19 ","date":"2023-01-03","objectID":"/record/:36:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.22 resilient, 英语词汇, 意思是 “能够从困难或挫折中恢复或弹回的” quijotesco, 西班牙语词汇, 意思是 “像堂吉诃德一样热情有远见的人，受到高尚而不切实际的理想所激励” 取 quijotesco, 的前半部分和 resilient 的后半部分结合起来，形成一个新的词汇, quijolient --- 来自 new bing(chatGPT-4)的设计 我希望成为一个 resilient 和 resilient 的人, 所以我将小站取名为 Quijolient ! ","date":"2023-01-03","objectID":"/record/:37:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.26 如果天总不亮，那就摸黑生活。 如果发出声音是危险，那就保持沉默。 如果自觉无力发光，那就蜷伏角落。 但不要习惯了黑暗就为黑暗辩护，不要为自己的苟且而得意。 不要讽那些比自己更勇敢的人们。 你可以卑微如尘土，不可扭曲如蛆虫。 做人当做报晓的雄鸡，莫做待宰的羔羊。 --- 曼德拉 ","date":"2023-01-03","objectID":"/record/:38:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.26 麦卡锡主义是指1950年至1954年间肇因于美国参议员麦卡锡的美国国内反共、极右的典型代表，它恶意诽谤、肆意迫害疑似共产党和民主进步人士，乃至一切有不同政见的人。 — 《百度百科》 ","date":"2023-01-03","objectID":"/record/:39:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.26 爱情也许是我们从短暂急促的一生当中可能得到的最好礼物，最慷慨的馈赠。 我不明白，宝马车里哭和自行车上笑。到底是反讽还是男性视角中对女性的想象，但是这种符号的存在已经说明了社会中一定存在这样的现象，或是局部的或是普遍的。 ","date":"2023-01-03","objectID":"/record/:40:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.36 不设定范围和焦点的争论毫无意义。 ","date":"2023-01-03","objectID":"/record/:41:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.2.27 最近正在尝试优化 2D 角色控制器，发现 godot 的 AnimatableBody2D / CharacterBody2D 有魔法一样的功能（指不需要手动处理移动平台和玩家贴合等东西）。所以想学一学实现方式。 代码阅读计划 physics_body_2d, godot 是将所有的2D物理节点代码都放到了一起，有差不多2k行，有点离谱。慢慢读吧！ ","date":"2023-01-03","objectID":"/record/:42:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.5 “我们走后，他们会给你们修学校和医院，会提高你们的工资，这不是因为他们良心发现，也不是因为他们变成了好人，而是因为我们来过” ","date":"2023-01-03","objectID":"/record/:43:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.7 “我也头圆顶天，足方履地，一般有九窍四肢，五脏六腑，何以比人不同？”（吴承恩《西游记》第二回） ","date":"2023-01-03","objectID":"/record/:44:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.7 愿中国青年都能摆脱冷气，只是向上走， 不必听自暴自弃者流的话。 能做事的做事，能发声的发声。 有一份热，发一分光， 就令萤火一般，也可以在黑暗里发一点光， 不必等候炬火。 此后如竟没有炬火，我便是唯一的光。 倘若有了炬火，出了太阳， 我们自然心悦诚服的消失， 不但毫无不平，而且还要随喜赞美这炬火或太阳， 因为他照了人类，连我都在内。 我又愿中国青年都只向上走， 不必理会这冷笑和暗箭。 --- 热风 ","date":"2023-01-03","objectID":"/record/:45:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.8 正义是集体利益的表现 我认为这种说法在解构人们关于公正的朴素追求，我相信那个只存在于语言和想象中的 “公平、正义、道德\"一定对应着一种现实。 原始人类群居时会分配资源，分配的正义是什么？每个人获得相同的食物？劳动的人获得更多食物？幼年、孱弱的人获得更多食物？提出正义分配的标准方法是几乎不可能的，这因为以生存作为前提，正义与分配存本质冲突。 所以公正问题是在人类个体组成社会的过程中产生的关于分配的问题。有限的历史中，正义从未完全践行，为什么\"正义\"的想象会出现在大脑中？或许正义的概念来自于广泛的非正义，因此正义想象的出发点都是个人而非整体。所以正义的实践不是提出一个看似代表了正义的社会契约，而是充分解决个人需求。通过消除分配来解构非正义！ 在此基础上谈论正义时，我们在谈论一个 物质资源无限扩张的同时个体需求有限扩张 的社会。所以追求公正的做法是： 在资源有限时发展生产力并保证一定程度的正义。 发展生产力的同时限制个体需求的扩张 任何一个时代都不能通过自我牺牲的方式作为通向未来社会的桥梁，即使发展生产力如此重要，也不能在发展时忽略当下时代的人作为 非工具的一面。 物质资源无限扩张的同时个体需求有限扩张 这要求不能依靠大量人口来实现生产力的发展，因为人口增加的意味着更大的需求增加，这样只会陷入永无止境的剥削和压迫。所以要实现公正，应该更多的通过工具去替代人类劳动。 所以人类追求正义的过程，就是人类脱离工具性的过程。就是在人类的工具性中剥离’他者’成分的过程。 ","date":"2023-01-03","objectID":"/record/:46:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.9 你永远吵不过喷子, 因为一个知识越贫乏的人 越是拥有一种莫名其妙的勇气和一种莫名其妙的自豪感。 因为知识越贫乏，他所相信的东西就越绝对，因为他根本没有听过与此相对的观点。 互联网的信息太多了，我们时常会介入自己不熟悉的领域，可能会带着各种偏见，多重标准，和不知源头想象。所以需要常常反省！常常反省！ ","date":"2023-01-03","objectID":"/record/:47:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.13 如何评价拼多多疑似利用漏洞攻击用户手机，窃取竞争对手软件数据，防止自己被卸载？ 拼多多apk内嵌提权代码，及动态下发dex分析 深蓝洞察 2022 年度最“不可赦”漏洞 ","date":"2023-01-03","objectID":"/record/:48:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.13 他们以斗争的方式丢弃武器，他们依然活着 ","date":"2023-01-03","objectID":"/record/:49:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.15 无产者在不断地被割裂！ ","date":"2023-01-03","objectID":"/record/:50:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.15 现代的卢德铁锤还能砸得烂超级计算机么？ ","date":"2023-01-03","objectID":"/record/:51:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.16 “伪善是邪恶向美德的致敬” ","date":"2023-01-03","objectID":"/record/:52:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.19 昨晚突然感受到一阵空虚，我记得上次这种感觉还是在刚上大学, 刚和女朋友分手，找不到生活的意义的时候。 此刻，我对未来感到迷茫，不知道怎么面对惨淡的现实。自己热爱的事情做的一塌糊涂，又饿又没钱。我突然意识到我花费很多时间去做的事情没有价值(市场意义上)也没人认可。在这一阵无意义感包围中，我又感受到了孤独，是那种贯穿我前18年的孤独，他又一次如恶疾一样缠着我。 ","date":"2023-01-03","objectID":"/record/:53:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.25 永不过时是一种悲哀 ","date":"2023-01-03","objectID":"/record/:54:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.30 为什么不喝酒呢? 因为每个人内心中都有一个魔鬼, 我知道它的存在, 不想让他伤害身边的人! 另外, 理性是人区别于动物的原因, 我不愿丢弃理性的活着! 最后, 酒没有饮料好喝! ","date":"2023-01-03","objectID":"/record/:55:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.3.30 《塞尔达传说: 王国之泪》真有点牛逼了， 作为程序， 我完全不知道展示出的这几个玩法该怎么实现。 操！ ","date":"2023-01-03","objectID":"/record/:56:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.4.1 请诚实的，诚实的告诉自己：那些些孤单的，感动的，遗憾的到底是不是爱情，它们确实不是爱情。 ","date":"2023-01-03","objectID":"/record/:57:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.4.13 上大学以来好多有趣的东西不断吸引着我，我见识了许多，也感受到许多迷惘。也染上一些坏习惯，也变得很懒，不自觉。变得越来越迟钝越来越笨。 这一切是怎么造成的呢？上大学时，有的课说不去就不去，虽然会在私下里补回来，但是这样的模式无疑会花费大量的时间。每次到期末就想在最后一周一口吃个大胖子，囫囵吞枣式的学习，这样真的不好，不光是对知识本身的理解不全面细致，而且容易忘。今后的这两年，我需要试图改变自己的学习和生活方式，探索出一条不那么枯燥而且有效有趣的学习模式。 其实中学时老师就已经教过我们学习的方法了：不要浮躁，静下心来，才能学得更好！ 一步一个脚印的学习 关心政治，但不入脑 越是往后知识的纵深越深，无限细化是没有穷尽的，所以需要确保理解当前深度再往下学习 确保每一个知识都有适当的练习，而不是仅仅从脑中过一遍 保持良好作息，绝不熬夜，就算没有学完也不熬夜 去运动，去运动，去运动 确保每周末最多只花一天时间玩游戏 (塞尔达传说传说除外) 玩的每一个游戏都要去理解其背后的设计思想 不要沉迷色情的东西（ 坚持写博客（技术上的 + 非技术上的） 其实我囫囵吞枣式的学习是由于 DeadLine 和 自身的不自觉 导致的，虽然我现在才意识到这个问题，但是为时不晚，对于一生的学习来说，这5年半不过是 1/14，仅此。 对于生活，我希望能保持对生活的热爱，希望能找到心有灵犀的伴侣，希望变得勇敢和独立！ ","date":"2023-01-03","objectID":"/record/:58:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.4.15 去工作了，与之前相比工资除以4了，心里的落差很大，但是 自由和理想是无价的。 ","date":"2023-01-03","objectID":"/record/:59:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.4.27 在阳光从来都照不到的阴暗的角落，一个关于青苔，杂草，蚂蚁，昆虫 和庞然巨物的世界，\u003e 短暂的太阳光都被当作神圣时刻。你将化身为小动物在 角落世界 里冒险，去探索那些无人涉足过的隐秘角落吧！ 一个冒险游戏设定想法, 与《北京折叠》的想法很相似，每一个城市在同一个时空中，折叠着许多不同的世界，如果不仔细就感受不到，我想通过这个游戏，让大家去关心那些常被我们忽视的世界（各种意义上。 ","date":"2023-01-03","objectID":"/record/:60:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2023.4.28 我讨厌鲜花，我很嫉妒幸福的人，我也对他们的遭遇感到惋惜， 我喜欢鲜花，我想成为幸福的人，我也对他们的幸福感同身受， ","date":"2023-01-03","objectID":"/record/:61:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"L层神经网络.html Neural Network ","date":"2023-01-03","objectID":"/neural-network/:0:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"实现方式：采用BP算法，使用梯度下降来优化W，b ","date":"2023-01-03","objectID":"/neural-network/:1:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"需要实现的函数如下： initial():根据用户自定义的层layer-\u003e[ $n_1, n_2,n_3,…,n_m$ ]来初始化参数W，b sigmoid():输入$X \\in R^{m x n}$ ，返回$A = \\frac{1}{1+e^{-WX + b}}$ liner_propagation():实现一层的前向传播，返回 A，并且缓存中间量Z L_layers_propagation():实现L层的前向传播，并且缓存所有中间层的A，Z predict():使用训练好的模型Ws，bs预测某一输入特征向量对应的预测值 back_propagation():实现一层的反向传播 L_back_propagation():实现L层链式反向传播 update_parameters():每一个epoch更新参数 evaulate():评估模型 model():主循环，BP算法梯度下降的循环 load_data():加载数据 在整体的设计中并没有loss函数的出现，是因为，在反向传播过过中，dloss/dW的计算并不涉及loss的值，dloss/dW的表达式中仅有y_truth 和 y_pred 链式偏微分 推导（这里是根据西瓜书上原始公式推导，所以是累计神经网络） ","date":"2023-01-03","objectID":"/neural-network/:2:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"由于在布置编程作业之前就自己实现了一下神经网络，所以实现的是任意层数和任意数量神经元的神经网络，所以就改下参数交作业了 由于神经网络层数可能会非常多，所以在反向传播时loss对每一层的W，b求导会重复很多中间步骤 $$设：\\beta^i \\in R^{m \\cdot n}$$ $$ A^{i-1} \\in R^{n \\cdot s}$$ $$ Z^{i} \\in R^{m \\cdot s}$$ $$Z^i = W^i A^{i-1} + b^i = \\beta^i A^{i-1}, $$ $$A^i = sigmoid(Z^i);$$ $$\\frac{\\partial E}{\\partial \\beta^i} = \\frac{\\partial Z^i}{\\partial \\beta^i} \\cdot \\underbrace{ \\frac{\\partial A^i}{\\partial Z^i} \\cdot \\overbrace {\\frac{\\partial E}{\\partial A^i}}^{\\partial A^i} }_{\\partial Z^i} ， \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad （1.1）$$ $$ \\frac{\\partial E}{\\partial A^{i-1}} = \\frac{\\partial Z^i}{\\partial A^{i-1}} \\cdot \\underbrace {\\frac{\\partial A^i}{\\partial Z^i} \\cdot \\overbrace{ \\frac{\\partial E}{\\partial A^i} }^{\\partial A^i} }_{\\partial Z^i}, \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad （1.2）$$ 其中： $$\\partial A^i由上一层反向传播提供,$$ 现在考虑每一层反向传播的计算 已知: $$\\frac{\\partial E}{\\partial A^k}, \\frac{\\partial A^k}{\\partial Z^k}, \\qquad其中：k是层数$$ 求解: $$\\frac{\\partial E}{\\partial {Z^k}_{i,j}} \\qquad其中： i,j \\in { i,j | i \\in (1,Z^k.shape[0]， j \\in (1,Z^k.shape[1])}$$ 分析： 由于 （暂时忽略掉上标，仅在需要的时候添加） $$Z = \\beta A$$ $$Z_{i,j} = \\sum_{k=1}^{n}\\beta_{i,k}A_{k,j}$$ 该式子表明 $$Z_{i,j}的值与同行\\beta{i,k}$$ $$即每一个\\beta与Z的第a行相关$$ $$那么要计算\\frac{\\partial E}{\\partial \\beta_{a,b}}$$ $$即需要\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s}\\frac{\\partial E}{\\partial Z_{a,k}} \\frac{\\partial Z_{a,k}}{\\partial \\beta_{a,b}}$$ $$而：\\frac{\\partial Z_{a,k}}{\\partial \\beta_{a,b}} = A_{b,k}$$ $$那么：\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s}\\frac{\\partial E}{\\partial Z_{a,k}} \\cdot A_{b,k}$$ $$\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s} {(\\frac{\\partial E}{\\partial Z})}{a,k} \\cdot A{b,k}$$ $$ = \\sum_{k=1}^{s}(\\frac{\\partial E}{\\partial Z}){a,k}(A^T){k,b}$$ $$所以有：\\frac{\\partial E}{\\beta} = dZ A^T$$ 由于推导的迭代式子中包含A, Z, 等前向传播产生的中间结果， 所以在前向传播时需要将它们缓存下来 import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation import sys import copy from IPython import display import time from sklearn.metrics import roc_curve, auc, accuracy_score, confusion_matrix, classification_report, roc_auc_score # 设置随机种子，避免每次的结果不一样 np.random.seed(1) %matplotlib inline ","date":"2023-01-03","objectID":"/neural-network/:3:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"初始化函数initial(layers) input: layers -\u003e [layer_1, layer_2, layer_3, ..., layer_m] output: paramters -\u003e dict() parameters[\"w\"] = temp_w -\u003e list() parameters['layers'] = layers -\u003e list() def initial(layers): parameters = dict() temp_w = list() for i in range(1, len(layers)): temp_w.append(np.random.randn(layers[i], layers[i-1])) parameters[\"w\"] = temp_w parameters['layers'] = layers return parameters ","date":"2023-01-03","objectID":"/neural-network/:4:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"激活函数 Sigmoid() 激活函数种类： sigmoid():“S\"形函数$f(x) = \\frac{1}{1+e^{-WX + b}}$$ ReLU():线性修正单元$f(x) = max(0,x)$ tanh():双曲正切函数$f(x) = \\frac{e^x-e^{-x}}{e^x+e^{-x}}$ ELU: PReLU: LReLU:x负半轴斜率比较小的PReLU def sigmoid(A): return 1/(1+np.exp(-A)) ","date":"2023-01-03","objectID":"/neural-network/:5:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"前向线性传播 $Z = WX + b$ $A = \\frac{1}{1+e^-Z}$ def liner_propagation(w, A): Z = np.dot(w, A) A = sigmoid(Z) return Z, A ","date":"2023-01-03","objectID":"/neural-network/:6:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"L层的前向传播 是L次linear_propagation的叠加 由于反向传播的需要，这里的L层前向传播需要缓存每一层的A，Z到A_cache and Z_chache def L_layers_propagation(parameters, x): A_cache = list() Z_cache = list() cache = dict() A_cache.append(x) Z_cache.append(x) w = parameters[\"w\"] layers = parameters['layers'] for i in range(0, len(layers) - 1): Z, A = liner_propagation(w[i], A_cache[i]) assert Z.shape == A.shape Z_cache.append(Z) A_cache.append(A) cache[\"A\"] = A_cache cache[\"Z\"] = Z_cache return cache ","date":"2023-01-03","objectID":"/neural-network/:7:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"Loss函数（均方误差） 如果要实现任意loss函数，只会影响链式传播哦的最后一项，而不会影响链式传播的中间过程 由于最近DDL多，所以任意loss函数的实现，在寒假实现 def lossFunc(Y_pre, Y_true, method = \"MSE\"): temp = Y_pre - Y_true return .5 * np.dot(temp, temp.T) ","date":"2023-01-03","objectID":"/neural-network/:7:1","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"预测函数 input = x output = y $y = f(x)$ $y\u003e.5$ =\u003e $y=1$ $y\\le .5$ =\u003e $y= 0$ def predict(parameters, x, draw = False): Y = L_layers_propagation(parameters, x)['A'][-1] if draw == False: Y[Y \u003e .5] = 1 Y[Y \u003c= .5] = 0 return Y ","date":"2023-01-03","objectID":"/neural-network/:8:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"反向传播函数 back_propagation 实现反向传播的难点在于求梯度 求梯度的方法如下： $dx = \\frac{f(x) - f(x-\\Delta x)}{\\Delta x}$ 老师上课提到的这种方法会导致精确度问题 如当在梯度下降算法中设定$\\Delta x= \\eta$时该算法退化为 W := W - loss(x-learning_rate) 2.利用求偏导法则，一层一层的求偏导 使用类似 tensorflow 的 Autograd 的计算图，将每一个参数变量加入计算图中，然后可以找到变量之间的关联然后求导(实现过于复杂，对于简单的全链接网络没必要这样做) 使用高等数学中的多变量求导，结合线性代数的矩阵变换进行 实数 对 矩阵 的 链式求导 参考 矩阵求导术（下） 矩阵求导术（上） 引入克罗内克积实现矩阵的链式求导，在注释代码中是没经过花间的Kron积，运算量极大，经过化简得到简单的矩阵表达式 def back_propagation(W, A_prev, dZ): # dZA_prev = np.diag( (A_prev * (1 - A_prev)).T.flatten() ) # I = np.eye(A_prev.shape[1]) # dZ_prev = np.dot(np.dot(dZA_prev,np.kron(I, W.T)), dZ) # I = np.eye(W.shape[0]) # dW = np.dot(np.kron(A_prev, I),dZ) # print(A_prev.shape, W.shape, dZ.shape) dZ_prev = np.multiply( A_prev * (1 - A_prev), np.dot(W.T,dZ)) dW = np.dot(dZ,A_prev.T) return dZ_prev, dW def L_back_propagation(cache, parameters, y): w = parameters[\"w\"] layers = parameters[\"layers\"] L = len(layers) - 1 A = cache[\"A\"] dW_list = list() dZ_prev = A[L] * (1 - A[L]) * (A[L] - y) for i in reversed(range(0, L)): dZ_prev, dW = back_propagation(w[i], A[i], dZ_prev) dW_list.append(dW) cache[\"dW\"] = dW_list return cache ","date":"2023-01-03","objectID":"/neural-network/:9:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"更新参数 pass def update_parameters(cache, parameters, learning_rate): w = parameters[\"w\"] layers = parameters[\"layers\"] L = len(layers) - 1 dW = cache[\"dW\"] for i in range(L): w[i] -= dW[L-i-1] * learning_rate # b[i] = b[i] - db[len(b)-i-1] * learning_rate parameters[\"w\"] = w return parameters ","date":"2023-01-03","objectID":"/neural-network/:10:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"evaulate 使用准确度作为评估标准 def evaluate(Z, Y): bools = Z == Y accuracy = np.sum(np.reshape(bools,bools.size))/Y.shape[1] return accuracy def evaluate_detial(y_t, y_p): y_test = copy.deepcopy(y_t) y_pred = copy.deepcopy(y_p) print(\"The roc_auc_score is {}\".format(roc_auc_score(y_test, y_pred))) tpr,fpr,thresholds = roc_curve(y_test,y_pred) plt.subplot(1,2,1) plt.plot(fpr, tpr) plt.xlim([0.0, 1.0]) plt.ylim([0.0, 1.0]) plt.title('ROC curve for diabetes classifier') plt.xlabel('False Positive Rate (1 - Specificity)') plt.ylabel('True Positive Rate (Sensitivity)') plt.grid(True) # mean = np.sum(y_pred)/y_pred.shape[0] y_pred[(y_pred \u003c 0.5)] = 0 y_pred[(y_pred \u003e= 0.5)] = 1 # plt.scatter(x_test[0, :], x_test[1, :], c = y_pred[:, 0]) print(\"The accuracy is {}\".format(accuracy_score(y_test[:,0], y_pred[:,0]))) # 计算召回， 查全率， 查准率 。。。。 target_names = ['class0','class1'] print(classification_report(y_test,y_pred,target_names = target_names)) ## 绘图 def Plot(X, label, parameters): x_min, x_max = X[0,:].min() - .5, X[0,:].max() + .5 y_min, y_max = X[1,:].min() - .5, X[1,:].max() + .5 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) Z = predict(parameters, np.c_[xx.ravel(), yy.ravel(), np.ones((yy.ravel().shape))].T) Z = Z.reshape(xx.shape) plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral) plt.scatter(X[0,:],X[1,:],c=label[0,:]) ","date":"2023-01-03","objectID":"/neural-network/:11:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"load_data 加载数据的管道 def load_data(shape = \"circle\"): X = np.random.rand(2,200) one = np.ones((1,200)) X = np.vstack((X,one)) C = [] for x in X.T: if shape == \"circle\": # 同心圆 if (x[0]-.5)**2 + (x[1]-.5)**2 \u003c .03: C.append(1) elif (x[0]-.5)**2 + (x[1]-.5)**2 \u003c .13: C.append(0) else: C.append(1) elif shape == \"xor\": # 四分 if (x[0] - .5)*(x[1] - .5) \u003e=0: C.append(1) else: C.append(0) x_min, x_max = X[0,:].min() - .05, X[0,:].max() + .05 y_min, y_max = X[1,:].min() - .05, X[1,:].max() + .05 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) test = np.c_[xx.ravel(), yy.ravel(), np.ones((yy.ravel().shape))].T return X, np.array(C).reshape(1,-1), test, (xx,yy) ","date":"2023-01-03","objectID":"/neural-network/:12:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"Back Propagation(BP算法的整体框架) 使用梯度下降的优化方法 其他可用的优化方法 SGD 随机梯度下降 MBGD （Mini Batch Gradient Descent）用于样本容量大，内存/现存不够的情况 Momentum 动量梯度下降 Nesterov NAG Adagrad Adaelta Adam def model(X, Y, test,canvs, layers, learning_rate = 0.01, epoch = 1000, detial = True, draw = False): parameters = initial(layers) draw_param = [] for i in range(epoch): cache = L_layers_propagation(parameters, X) cache = L_back_propagation(cache, parameters, Y) parameters = update_parameters(cache, parameters, learning_rate) if i % 500 == 0 and draw == True: # draw_param.append(copy.deepcopy(parameters)) yield predict(parameters, test, draw = True).reshape(canvs[0].shape) if i % 1000 == 0 and detial == True: print(\"this is {}th epoch.\".format(i)) Y_predict = predict(parameters, X, draw=False) accuracy = evaluate(Y, Y_predict) print(\"accuracy is {}\".format(accuracy)) if draw == False: return parameters ","date":"2023-01-03","objectID":"/neural-network/:13:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"实现累计BP算法 def model_caculate(X, Y, X_test, Y_test, layers, learning_rate = 0.01, epoch = 1000, interval = 50): parameters = initial(layers) Loss = [] loss = None Acc = [] accuracy = None start = time.time() Y_predict = None for i in range(epoch): cache = L_layers_propagation(parameters, X) cache = L_back_propagation(cache, parameters, Y) loss = lossFunc(Y, cache[\"A\"][-1]) parameters = update_parameters(cache, parameters, learning_rate) if i % interval == 0: Loss.append(loss[0,0]) Y_predict = predict(parameters, X_test, draw=False) accuracy = evaluate(Y_test, Y_predict) Acc.append(accuracy) if i % (interval * 50) == 0: now = time.time() print(\"Calculate Dense Net:~$ {}th epoch, accuracy: {}, loss:{}, time:{}-\".format(i, accuracy, loss[0,0], now - start)) start = time.time() return Loss, Acc, Y_predict X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] epoch = 25000 Loss, accuracy, Y_pred = model_caculate(X, label, X, label, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, 500) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(label.T, Y_pred.T) Calculate Dense Net:~$ 0th epoch, accuracy: 0.725, loss:21.40100100371333, time:0.0010008811950683594- Calculate Dense Net:~$ 2500th epoch, accuracy: 0.725, loss:19.748958341789084, time:0.7027204036712646- Calculate Dense Net:~$ 5000th epoch, accuracy: 0.725, loss:18.484585855571503, time:0.7009453773498535- Calculate Dense Net:~$ 7500th epoch, accuracy: 0.705, loss:16.377806924887945, time:0.6996634006500244- Calculate Dense Net:~$ 10000th epoch, accuracy: 0.87, loss:10.950215467935237, time:0.7041025161743164- Calculate Dense Net:~$ 12500th epoch, accuracy: 0.88, loss:9.160948492962692, time:0.701648473739624- Calculate Dense Net:~$ 15000th epoch, accuracy: 0.885, loss:8.84026852930535, time:0.6946816444396973- Calculate Dense Net:~$ 17500th epoch, accuracy: 0.965, loss:6.105461022050368, time:0.685279369354248- Calculate Dense Net:~$ 20000th epoch, accuracy: 0.99, loss:2.3057686501449832, time:0.7090015411376953- Calculate Dense Net:~$ 22500th epoch, accuracy: 0.99, loss:0.958385284049958, time:0.6965689659118652- The roc_auc_score is 1.0 The accuracy is 1.0 precision recall f1-score support class0 1.00 1.00 1.00 55 class1 1.00 1.00 1.00 145 micro avg 1.00 1.00 1.00 200 macro avg 1.00 1.00 1.00 200 weighted avg 1.00 1.00 1.00 200 ","date":"2023-01-03","objectID":"/neural-network/:13:1","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"实现标准BP算法（也就是Mini-batch = 1，这样的话在python下使用for循环喂数据会非常慢） def model_std(X, Y, X_test, Y_test, layers, learning_rate = 0.01, epoch = 1000, interval = 50): parameters = initial(layers) Loss = [] Acc = [] accuracy = None loss = None Y_pred = None start = time.time() for i in range(epoch): for j in range(0, X.shape[1]): cache = L_layers_propagation(parameters, X[:, j].reshape(3, -1)) cache = L_back_propagation(cache, parameters, Y[:, j].reshape(1, -1)) parameters = update_parameters(cache, parameters, learning_rate) if i % interval == 0: Y_pred = predict(parameters, X_test, draw = False) loss = lossFunc(Y_test, Y_pred)[0,0] Loss.append(loss) accuracy = evaluate(Y_test, Y_pred) Acc.append(accuracy) if i % (interval * 20) == 0: now = time.time() print(\"Stander Dense Net:~$ {}th epoch, accuracy: {}, loss:{}, time:{}\".format(i, accuracy, loss, now - start)) start = time.time() return Loss, Acc, Y_pred X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] epoch = 33300 Loss,accuracy, Y_pred = model_std(X, label, X, label, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, epoch/50) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(label.T, Y_pred.T) Stander Dense Net:~$ 0th epoch, accuracy: 0.65, loss:35.0, time:0.018254756927490234 ","date":"2023-01-03","objectID":"/neural-network/:13:2","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"动态可视化训练过程 def main(epoch= 50000, detial=True, draw=False): X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] if draw == True: for im in model(X, label, test, canvs, layers, learning_rate=0.01, epoch= epoch, detial = detial, draw = True): plt.clf() display.clear_output(wait=True) plt.contourf(canvs[0] ,canvs[1], im, cmap=plt.cm.Spectral) plt.scatter(X[0,:], X[1,:],c=label[0,:]) plt.pause(0.01) else: parameters = model(X, label, test, canvs, layers, learning_rate=0.01, epoch= 30000, detial = detial, draw = draw) Plot(X, label, parameters) main(epoch= 20000, detial=False, draw=True) 西瓜数据集3.0$\\alpha$上的分类 ","date":"2023-01-03","objectID":"/neural-network/:14:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"导入数据 import numpy as np import copy def load(): data = np.array([[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]]) Y = copy.deepcopy(data[:, 2].reshape(-1, 1).T) data[:, 2] = 1 X = copy.deepcopy(data.T) X_test = copy.deepcopy(np.c_[X[:, 0:2],X[:, -3:-1]]) Y_test = copy.deepcopy(np.c_[Y[:, 0:2],Y[:, -3:-1]]) X_train = copy.deepcopy(X[:, 2:-2]) Y_train = copy.deepcopy(Y[:, 2:-2]) return X_train, Y_train, X_test, Y_test, X, Y X_train, Y_train, X_test, Y_test, X, Y = load() print(Y.shape) ","date":"2023-01-03","objectID":"/neural-network/:14:1","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"累计BP X_train, Y_train, X_test, Y_test, X, Y = load() X_train.shape, Y_train.shape, X_test.shape, Y_test.shape layers = [3,5,1] epoch = 5500 interval = 1 Loss, accuracy, Y_pred = model_caculate(X_train, Y_train, X_test, Y_test, layers, learning_rate=0.1, epoch= epoch, interval = interval) #开始画图 x = np.linspace(0, 25000, epoch/interval) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(Y_test.T, Y_pred.T) X, label, test, canvs = load_data() X.shape, label.shape ","date":"2023-01-03","objectID":"/neural-network/:14:2","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"标准BP算法 由于实现了累计误差的算法， 所以可以将样样本拆分得到mini-batch的神经网络就是标准BP算法 layers = [3,5,1] epoch = 5500 interval = 1 Loss,accuracy, Y_pred = model_std(X_train, Y_train, X_test, Y_test, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, epoch/50) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(Y_test.T, Y_pred.T) 模型比较 标准BP算法收敛更快 累计BP在python可以通过矩阵运算向量化加速,在迭代过程中震荡变小 累计BP 更占用内存，而标准BP可以一边读一边运算，收敛速度变慢但是梯度方向更准确 Minibatch = n，可以通过调节n的大小使其达到一个合适的值，其收敛速度和迭代的准确性都能提高！ ","date":"2023-01-03","objectID":"/neural-network/:14:3","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"神经网络的优势 相对于决策树，线性模型，神经网络可以通过增加层数/增加神经元的方式拟合任意非线性函数 在之前的同心圆数据集中，神经网络的表达能力远远优于其他模型 \\begin{split} \u0026 C(F , G) = \\frac{F \\cdot G+(1 - F\\otimes G)}{2}\\ \u0026 F\\cdot G = \\vee_U(\\mu_F(u_i)\\land\\mu_G(u_i)) \\ \u0026 F\\otimes G = \\vee_U(\\mu_F(u_i)\\vee\\mu_G(u_i)) \\end{split} ","date":"2023-01-03","objectID":"/neural-network/:14:4","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"中央处理器(Central Processing Unit，简称CPU) ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:0:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"CPU 功能和基本结构 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:1:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"CPU 功能 指令控制（取指，分析，执行） 操作控制一条指令执行，需要控制的各个门电路信号 时间控制 系统时钟 数据加工 算术逻辑运算 中断处理 异常和特殊请求的处理 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:1:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"结构 运算器 算术逻辑单元，暂存寄存器，累加寄存器，通用寄存器组，程序状态字寄存器 控制器 程序计数器，指令寄存器，指令译码器，存储器地址寄存器，存储器数据寄存器 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:1:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"指令执行过程 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:2:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"1. 指令周期 取指周期： 从内存中读取指令 间址周期：取一次和多次间址 执行周期： 中断周期：每条指令执行完成后查询中断请求，如果有中断请求则进入中断周期 为了区别不同周期，使用标志触发器 FE, IND, EX, INT 表示各个周期，取 1 为有效值 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:2:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"2. 指令周期的数据流 取指周期 PC -\u003e MAR -\u003e 地址总线 -\u003e 主存 CU读命令 -\u003e 控制总线 -\u003e 主存 主存 -\u003e 数据总线 -\u003e MDR -\u003e IR CU控制信号 -\u003e PC+1 间地周期 Ad(IR) -\u003e MAR -\u003e 地址总线 -\u003e 主存 CU 读命令 -\u003e 控制总线 -\u003e 主存 主存 -\u003e 数据总线 -\u003eMDR 中断周期 CU控制SP-1， SP-\u003eMAR-\u003e地址总线-\u003e主存 CU写命令-\u003e控制总线-\u003e主存 PC-\u003eMDR-\u003e数据总线-\u003e主存（存入断点） CU（中断服务程序入口） -\u003e PC ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:2:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"3. 指令执行方案 单周期：每条指令时钟周期数固定 多周期：每条指令使用不同周期数，但是指令只能一条执行完才能执行下一条 流水线：流水（参考MIPS 五级流水） ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:2:3","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"数据通路的功能和基本结构 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:3:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"1. 数据通路功能 描述信息从什么地方开始，中间经过了哪些寄存器和开关，传送到哪个寄存器 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:3:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"2. 数据通路结构 CPU内单总线方式：所有东西通过公共同通路传输，冲突概率较高，性能低 CPU内三总线方式：提高效率，数据总线，地址总线，控制总线 专用数据通路方式：需要传送数据的地方直接安排连线，性能高，硬件量大 寄存器间数据传送 PC -\u003e Bus Bus -\u003e MAR 主存 \u0026 CPU 信息传送 PC -\u003e Bus -\u003e MAR 1 -\u003e R MEM(MAR) -\u003e MDR MDR -\u003e Bus -\u003e IR 执行算术逻辑运算 Ad(IR) -\u003e Bus -\u003e MAR 1 -\u003e R MEM-\u003e数据线-\u003eMDR MDR -\u003e Bus -\u003eY (ACC) + (Y) -\u003e Z Z -\u003e ACC ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:3:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"控制器 计算机的五大功能部件 控制器部件 运算器部件 输入设备 / 输出设备 内存储器 他们之间通过 数据总线、地址总线、控制总线 相互通信，其中输入输出设备是通过接口电路连接的 控制器部件从数据总线接受指令 从运算器不见接受指令转移地址 送出 指令地址 到 地址总线 向系统中的部件提供运行所需的控制信号 控制器的主要功能： 取指令和指出下一条指令的地址 对指令进行译码 和 测试，以产生相应操作的控制信号 指挥并控制 CPU、主存、输入输出设备之间的数据流动方向 根据控制器产生微操作控制信号的方式不同，分为硬布线控制器 和 微程序控制器， 其中 PC 和 IR 是相同的，但是确定和表示指令执行步骤的办法和需要的控制信号是不同的 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:4:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"硬布线控制器 根据指令要求、当前时序、外部和内部状态，按时间顺序发送一系列微操作控制信号（也叫做组合逻辑控制器）。 区别于微程序控制器使用的微指令，硬布线控制器是直接采用组合逻辑电路实现机器指令，以 “使用最少零部件，去的最高速度” 作为设计目标，优点是速度快（电路延迟），缺点是不易添加新的功能 硬布线控制单元图 硬布线控制单元，从 CU 中分离出 操作码译码器， 节拍发生器，其中操作译码器将 N 位操作码翻译为 $2^N$ 位， 再输入 CU。 节拍发生器 产生的节拍(T1, T2, T3, …) 由 机器主频(CLK) 分频得到，CU 使用 操作码， 节拍信号， 状态标志 在不同的节拍输出不同的控制信号（微操作命令 $C_i$） 使用节拍的原因 首先信号发出到稳定需要一个极短的时间间隔，所以 CPU 需要有一个最短时间（类似于我们的普朗克时间），其次，一个 机器指令，需要由多个微操作来完成，微操作按照一定的顺序生效，所以需要节拍 来区分微操作顺序 例如： 操作A -\u003e 操作B -\u003e 操作C out = T1 * A + T2 * B + T3 * C 按节拍顺序执行操作，总之技巧是通过逻辑组合控制各个开关,结合节拍器控制顺序（详见4） 硬布线控制器的时序系统和微操作 时钟周期：时钟信号控制的节拍发生器，每个节拍的宽度正好是时钟周期，每个节拍内可以完成一个/几个需要同时完成的操作 机器周期：所有指令执行的基准时间（完成一个基本操作需要的时间），通常取存取周期作为基准时间，在存储字长等于指令字长时，存取周期 = 机器周期 一个机器周期内，完成若干微操作，通过时钟信号控制产生每个微操作 指令周期：取出并执行一条指令的时间 微操作命令分析：指令分为三个周期 取值周期-\u003e间址周期-\u003e执行周期 取址 PC -\u003e MAR 1 -\u003e R M(MAR) -\u003e MDR MDR -\u003e IR OP(IR) -\u003e CU (PC) + 1 -\u003e PC 间址周期 Ad(IR) -\u003e MAR 1 -\u003e R M(MAR) -\u003e MDR 执行周期 a. 非访存指令 CLA // 清ACC COM // 取反 SHR // 算术右移 CSL // 循环左移 STOP // 停机指令 b. 访存指令 ADD X // 加法指令 Ad(IR) -\u003e MAR, 1 -\u003e R M(MAR) -\u003e MDR (ACC) + (MDR) -\u003e ACC STA X // 存数指令 Ad(IR) -\u003e MAR, 1 -\u003e W ACC -\u003e MDR MDR -\u003e M(MAR) LDA X // 取数指令 Ad(IR) -\u003e MAR, 1 -\u003e R M(MAR) -\u003e MDR MDR -\u003e ACC c. 转移指令 JMP X =\u003e Ad(IR) -\u003e PC BAN X =\u003e A0 * Ad(IR) + (~A0) * (PC) -\u003e PC CPU 控制方式 控制一条指令本质是依次执行一个确定的微操作序列， 不同指令对应的微操作数量和复杂度不一样,因此每条指令执行时间不相同，使用以下三种方法控制： 同步控制 所有控制信号都来自统一系统时钟，一最长微操作和最繁琐微操作为标准，采取统一、相同时间间隔、相同节拍数 作为机器周期来运行不同指令 特点：简单，速度慢（因为短命令也需要经过长周期） 异步控制 不存在 基准信号，各个部件按照自身固有速度工作，通过异步应答方式交流 特点：快速，控制复杂 联合控制 介于同步和异步之间，对不同的指令的微操作实行大部分采用同步控制，小部分采用异步控制 硬布线控制单元设计步骤 步骤一: 列出微操作命令时间表 以下是 CLR， COM， SHR 等10条机器指令微操作命令的时间表，观察表结构，共有工作周期标记、节拍、状态条件、微操作命令信号、微操作命令表项，其中一个工作周期可能包含多个节拍， 其中一个节拍内可以完成多个独立的微操作命令（不独立的命令会造成冲突） 步骤二: 微操作信号综合 $$ 微操作控制信号 = 机器周期 \\land 节拍 \\land 脉冲 \\land 操作码 \\land 机器状态条件 $$ 根据表构造逻辑表达式，然后经过化简整理得到可用现有门电路实现的微操作命令逻辑表达式： 步骤三: 绘制微操作命令组合电路图（没什么技巧，就嗯画） ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:4:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"微程序控制器 在电路和机器指令之间添加了一层微程序，根据机器指令生成微指令序列（微程序），使用微程序来实现机器指令功能，而微程序是存储在 控制存储器（CM in CPU） 中的指令序列，优点是规整、灵活、可维护，缺点是每次都要从 CM 中取微指令，速度慢 微程序控制基本概念 就是把微操作信号 代码化， 使每条机器指令转化为一段微程序存入控制存储器中（CM），微程序包含若干微指令，每条微指令对应1/n个微操作。 微命令 \u0026 微操作 ： 机器指令 -\u003e 微操作序列，在微程序控制计算机中，将控制部件向执行部件发送的控制命令称为微命令，例如：打开或关闭某个门电位信号，微操作是微命令的执行过程。 注意微命令的 相容 和 相斥 微指令 \u0026 微周期：微指令是若干微命令的集合（命令就是一位，指令就是一行），存放为微指令的控制存储器单元地址成为微地址，微指令包含两部分信息： 操作控制字段：控制信号 顺序控制字段：下一条微指令地址 微周期是指读取并执行一条微指令花费的时间 主存储器 \u0026 控制存储器：主存是在 CPU 外部的RAM， 控制存储器是在 CPU 内部的ROM 程序 \u0026 微程序： 微程序是机器指令的实时解释器，是在CPU 制造时预先设计和存储的，对程序员透明的 相关寄存器：地址寄存器(MAR)， 微地址寄存器(CMAR)，指令寄存器(IR)，微指令寄存器(CMDR / $\\mu$IR) 微程序控制器组成和工作过程 组成 控制存储器，微指令寄存器，微地址形成部件（产生最初地址和后继地址），微地址寄存器 工作过程 取微指令公共操作 ==\u003e 机器开始时，自动将取指微程序入口地址送入 CMAR，并取址；一般时 CM 的 0号地址，该微程序完成后 主存中取出的机器指令就存储在 IR 中 IR 操作码 ==\u003e 微地址形成部件 ==\u003e 微程序入口地址 ==\u003e CMAR 从CM 中逐条取出指令并执行，执行完一段微程序后回到取址微程序入口，周而复始 微指令的编码方式 直接编码 ： 无需译码，每一位表示一个微命令，简单直观快速，并行性好，缺点是控制存储器容量变大 字段直接编码：将微指令的微命令分成若干小段，把互斥性微命令组合在同一字段，把相容性微命令组合在不同字段，每个字段独立编码，各个字段编码单独定义，互不干扰 优点：缩短字长 缺点：通过译码电路减速 分段原则 互斥命令同段，相容命令不同段 每个段信息为不能太多 每个小段留出一个状态表示无命令（000），因此状态数 = $2^N - 1$ 字段间接编码：一个字段某些命令需要由另一些字段来解释，进一步减小了字长，削弱了并行能力，通常作为辅助手段 微指令的地址形成方式 有两种基本类型 直接由微指令的下地址字段指出（断定方式） 根据机器指令的操作码形成，通过微地址形成部件形成 几种额外类型： 增量计数 (CMAR) + 1 -\u003e CMAR, 连续存放 根据标志位决定微指令分支转移地址 通过测试网络形成 由硬件直接产生微程序入口地址 加电后第一条微指令地址可以由专门的硬件电路产生 微指令的格式 水平型微指令： 指令中一位对应一个控制信号，优点：程序短，执行速度快；缺点：微指令长，编写微程序麻烦 垂直型微指令：采用类似机器指令的 操作数 | 操作码 | 操作码 的结构，优点：微指令短，简单，规整，便于编写；缺点是微程序长执行速度慢 混合型微指令：在垂直型的基础上增加一些不太复杂的并行操作，性能折中 微程序控制单元的设计步骤 写出微操作命令的节拍安排 这里与之前的微操作表的区别是： 取指阶段需要将 IR的操作码送往微地址形成部件, OP(IR) -\u003e CMAR 每条微指令执行完成后都需要形成后继微指令 , 微地址形成部件 -\u003e CMAR 确定微指令格式 微指令编码方式，后继指令形成方式，微指令字长 一般根据微操作个数决定编码方式，确定微指令操作控制字段位数， 由微指令数决定微指令顺序控制字段位数 按操作控制字段位数和顺序控制字段位数决定微指令字长 动态微程序设计和毫微程序设计 动态微程序就是可以更改的微程序，一般使用 EPROM，豪微程序试就是在微程序和电路之间再增加一层解释程序 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:4:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"异常和中断机制 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:5:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"概念 异常 是 CPU 内部产生的意外事件，被称为内中断，是内部检测，与执行的指令相关的同步事件 中断 是 CPU 发出的中断请求，被称为外中断，由外部设备触发，与当前执行指令无关 描述如下： CPU 在执行用户程序第 i 条指令是检测到异常事件 或 第 i 条指令后发现一个中断请求信号，则 CPU 打断当前用户程序，然后转到相应的异常或中断处理程序去执行。 若异常或中断处理程序能解决相应问题，则在处理程序的最后 CPU 指向异常或中断返回指令，回到被打断的用户程序第 i 条指令或 第 i + 1 条指令继续执行 若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序 一般来说，对终端和异常的具体处理由操作系统（和驱动程序）完成 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:5:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"分类 异常的分类 故障（Fault）：在故障指令启动后，指令结束前被检查到的异常事件，例如：译码时出现非法操作码；取数据时发生缺页缺段；除数为0；其中有的能通过磁盘调入主存来解决，像除数为0这样的异常不能解决并回到原断点继续执行，必须终止进程的执行 自陷（Trap）：是预先安排的一种异常，事先在程序中用一条特殊的指令或通过特殊标志的设定来人为造成陷阱，执行到被设置了陷阱的指令时，CPU 在执行完自陷指令后，自动根据不同陷阱进行相应处理，然后返回自陷指令的下一条执行。 特别的，如果当前指令是转移指令，那不会返回到下一条指令继续执行，而是返回到目标指令继续执行 例如：程序断点调试， 系统调用指令，条件自陷指令都属于陷阱指令，执行到这些指令时，无条件的或有条件的自动调出操作系统内核程序进行执行 故障异常和自陷异常属于程序性异常 终止（Abort）：指令执行过程中发生了使计算机无法继续执行的硬件故障，如控制器出错，存储器校验错误等，程序无法继续执行，只能终止，此时调出中断服务程序来重启系统，这种异常和故障不由特定指令造成，而是随机发生的，属于硬件异常 中断的分类 可屏蔽中断：通过可屏蔽中断请求线INTR 向 CPU 发送的中断请求，CPU可通过在中断控制器中设置相应的屏蔽字来屏蔽或不屏蔽它，被屏蔽的中断请求不会送到 CPU 不可屏蔽中断：通过专门的 不可屏蔽中断请求线NMI 向 CPU 发出中断请求，通常是紧急的硬件故障，如电源掉电 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:5:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"响应 过程为 ： 关中断 -\u003e 保存断点和程序状态 -\u003e 识别异常和中断并转移到相应的处理程序 **关中断 在保存断点和程序状态期间不能被新的中断打断，通过设置中断允许(IF)触发器 来实现禁止响应新的中断： IF == 1 开中断，允许响应中断 IF == 0 关中断，不允许响应中断 保存断点和程序状态 将程序断点（返回地址）送到栈或特定寄存器，通常保存在栈中（为了支持异常或中断的嵌套），状态字寄存器 PSWR 也需要保存到栈或者特定寄存器中。 识别异常和中断并转移到相应处理程序 异常大多数采用软件识别，中断由硬件识别和软件识别两种方式 软件识别是 CPU 设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或终端查询程序，按优先级查询异常状态寄存器，以检查中断或异常的类型，先查询到的先处理，然后转到内核中相应处理程序 硬件识别也就是向量中断，异常或中断程序的首地址称为中断向量，所有中断向量存放在中断向量表中，每个异常或中断都被指定一个中断类型号，在中断向量表中类型号和中断向量一一对应，因为可以根据类型号快速找到对应的处理程序。 中断或异常的响应是不可被打断的。中断响应结束后 CPU 就从 PC 中取出中断服务程序的第一条指令开始执行，直到中断返回，整个过程是由软硬件协同完成的 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:5:3","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"*指令流水线 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"1. 基本概念 MIPS 指令流水将指令分成以下五个阶段，每一个时钟到来就会有一条指令进入流水 取指(IF) 从存储器/Cache中取指令（PC，指令寄存器，下一条指令地址计算逻辑） 译码(ID) 对指令进行译码，（操作控制器，去操作数逻辑，立即数符号扩展） 执行(EX) 执行运算/计算地址，（ALU，分支地址计算模块） 访存(MEM) 访问存储器，（数据存储器读写模块） 写回(WB) 将计算结果写回寄存器堆， （寄存器写入控制模块） 区分阶段的企图是，划分 CPU 运行过程中的阶段，分析他们的关联性方便同时多条指令在不同部件上运行 流水原则：流水阶段个数以最复杂指令所用的功能段个数为准，流水长度以最耗时操作花费时间为准 便于流水的指令集特征： 指令长度尽量一致，简化取指，译码 指令格式尽量规整，比如第几位是寄存器编号，第几位是地址，这样方便指令未知时直接通过位数取操作数 采用 Load / Store 指令，这样可以包访存指令的地址计算和运算指令的执行步骤规整在同一周期（不懂什么意思） 数据和指令对齐存放，减少访存次数 大量连续任务才能提高流水效率，流水延长单个指令执行时间，缩短整体执行时间 Tips:流水线需要多个锁存器来存储上一流水阶段的计算结果，控制信号，等来进行下一阶段计算 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"2. 流水线冒险 结构冒险 多条指令同时访问同一资源（例如：存储器，取指和访存都要访问） 解决： 访存时流水暂停 区分数据存储器 和 指令存储器（事实上 L1 cache 就是这样区分的） 数据冒险 分为 写后读、 读后写、 写后写 三种 解决： 流水暂停(stall，硬件实现), NOP空指令(编译器实现) 数据旁路技术（数据前推） 编译优化调整指令顺序 控制冒险 指令跳转、调用过程、返回等会改变 PC 寄存器值的指令，会导致控制冒险 以前采用延迟槽方法（即在跳转指令后插入无论如何都要执行的指令），现代 CPU 都使用分支预测的方法，预测成功什么都不会发生，预测失败就清空流水线 解决： 分支预测 （分为动态和静态预测） 预取转移成功和不成功两个方向的指令 加快提前形成条件码 提高转移方向的猜准率 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"3. 性能指标 流水线吞吐率(TP) $$ TP = \\frac{n}{T_k} = \\frac{n}{(k+n-1)\\Delta t}\\ TP_{max} = \\lim\\limits_{n\\rightarrow\\infty}\\frac{n}{(k+n-1)\\Delta t} = \\frac{1}{\\Delta t} $$ 流水线加速比(S) $$ S = \\frac{T_0}{T_k} = \\frac{kn\\Delta t}{(k+n-1)\\Delta t}\\ S_{max} = \\lim\\limits_{n\\rightarrow\\infty}\\frac{kn\\Delta t}{(k+n-1)\\Delta t} = k $$ 其中，n 是指令数量， k 是流水阶段数， $\\Delta t$ 是时钟周期 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:3","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"4. 高级流水线技术 处理机一次发射多条指令的多发射技术，增加流水线级数的超流水线技术 超标量流水线技术：不能调整指令执行顺序，并行执行指令搭配 超长指令字技术：也称静态多发射技术，编译程序挖掘程序潜在并行性，将多条能并行的指令组合成一条具有多个操作码的指令（几百位），需要多个部件处理 超流水线技术：增加级数，每级的操作量减小，纳闷呢时钟周期就可以减小，但是依然是一个周期进入一条指令，总的来讲效率提高 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:4","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"多处理器基本概念 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"SISD、SIMD、MIMD SISD 是传统的串行计算机结构，包含一个处理器一个存储器，指令按规定顺序执行，SISD 为了提高效率采用流水的方式，之前的内容大都是 SISD 结构 SIMD 是指一个指令同时对多个数据流进行处理，成为数据级并行技术，通常由一个指令控制部件、多个处理单元组成，每个单元执行同一条指令，但每个处理单元都有自己的地址寄存器，因此每个单元都有不同的数据地址，因此，不同处理单元在不同数据集上执行相同的指令。 一个应用程序被编译后可能按SISD在串行硬件上执行，也可能按SIMD 组织并运行于并行硬件上 SIMD 在使用 for 循环处理数组时最有效，例如：对16对数据进行运算的 SIMD 指令如果在16个ALU中同时运算，只需要一次运算时间就能完成。SIMD 在使用 case-switch 语句时效率最低，此时每个执行单元必须根据不同数据执行不同操作。 MISD 是同时执行多条指令，处理同一个数据，实际上不存在这样的计算机 MIMD 同时执行多条指令处理不同数据，分为多计算机系统 和 多处理器系统 多计算机系统中每个计算机节点都具有各自私有的存储器，和独立的主存空间，不能相关通过存取指令访问。需要通过消息传递进行数据传送。 多处理器系统是共享多处理器系统SMP的简称，它共享单一地址空间，通过存取指令访问多有存储器 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"硬件多线程 目的减小线程切换开销 细粒度多线程 多个线程之间轮流交换执行指令，线程间指令不相关，可以乱序并行执行。处理器能在每个时钟周期切换线程 粗粒度多线程 在线程出现较大开销阻塞时切换线程，如 cache 缺失。这种情况下，当发生流水阻塞时，必须清除被阻塞的流水线，新的线程指令开始执行前需要重载流水线，因此开销很大 同时多线程（SMT） 是上述两种多线程技术的变体。在实现指令级并行的同时，实现线程级并行，也就是说，在一个时钟周期内，发射多个不同线程中的多条指令执行。Intel 中的超线程技术就是同时对线程，即在一个单处理器或单个核中设置两套线程状态部件，共享高速缓存和功能部件。 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"多核处理器 多个处理单元集成到单个CPU，每个核可以有自己的 cache，也可以共享 cache，共享主存储器 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:3","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"共享内存多处理器 通过存储器中的共享变量相互通信，可以在各个处理器自己的虚拟地址空间单独运行 统一存储访问（UMA）多处理器：分为基于总线，基于交叉开关网络，基于多级交换网络 连接等几种处理器 非统一存储访问（NUMA）多处理器：处理器中不带高速缓存时被称为 NC-NUMA，带有一致性高速缓存时被称为 CC-NUMA 最初内存控制器没有整合进 CPU， 需要通过北桥的内存控制器访问内存，这种架构随着 多核 CPU 的发展而达到瓶颈（争用前端总线），所以NUMA 架构诞生，每个 CPU 分配一个内存区域，而 CPU 之间通过 QPI 总线相连，CPU 通过 QPI 访问其他CPU的远程内存。 由于内存共享， 对于共享变量需要使用同步机制，例如对变量加锁 3 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:4","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"指令 计算机指令是机器码，是汇编码，是硬件软件交互界面；指令长度是CPU指令长度（例如：32 位/64位） 常规的指令形式是 OP + Address * n; 指令字长和机器字长没有固定关系，通常有半指令字长，单指令字长，双指令字长，此外指令长度可以是固定的也可以是不定的，通常来说定长指令更易于处理 零地址指令 不需要操作数的指令(空操作，停机，关中断指令)， 堆栈计算机指令 一地址指令 $OP(A_1)\\rightarrow A_1$(自增,自减,求反求补) $(ACC)OP(A-1)\\rightarrow ACC$, 隐含约定地址， 计算寻址范围 二地址指令 算术指令，逻辑运算指令 指令含义 $(A_1)OP(A_2)\\rightarrow A_1$ 三地址指令 $(A_1)OP(A_2)\\rightarrow A_3$, 如果地址均为主存地址， 完成该类指令需要四次访存(取指令 * 1， 取操作数2， 存放结果1) 四地址指令 最后一个地址 $A_4$ 是下一条将要执行的指令 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:1:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"指令扩展 虽然现代处理器采用大都采用定长指令，但是为了在此基础上保留指令的丰富类别，采用可变长操作码的定长指令；这意味着操作码位数长度不变，且分散在指令的不同位置，这将增加指令的译码难度，增加控制器复杂度。 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:2:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"指令操作类型 数据传送 寄存器之间的传送(MOV) 从内存单元读取数据到CPU寄存器(LOAD) 从CPU寄存器写数据到内存单元(STORE) 算术和逻辑 加(ADD)、 减(SUB)、 乘(MUL)、 除(DIV)、 比较(CMP)、 加1(INC)、 减1(DEC)、 与(AND)、或(OR)、 取反(NOT)、 亦或(XOR) 移位操作 算法移位、逻辑移位、循环移位 转移操作 无条件转移(JMP) 条件转移(BRANCH) 调用(CALL) 返回(RET) 陷阱(TRAP) 输入输出操作 完成 CPU 与外部设备交换数据或传送控制命令及状态信息 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:3:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"指令寻址方式 ’’ 寻址方式是指寻找指令或指令操作数有效地址的方式 ’' 寻址方式分为指令寻址和数据寻址两类 指令中数据字段代表的不是真实地址而是形式地址， 形式地址结合寻址方式可以计算真实地址 如果 A 表示寄存器编号或者内存地址， 那么 (A) 表示其中保存的值 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:4:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"指令寻址 顺序寻址: 程序计数器PC++，自动形成下一条指令地址 跳跃寻址: 跳跃寻址的地址依然是由 PC 寄存器指出的， 指令跳跃收到 状态寄存器 和 操作数的控制，跳跃地址可以是直接由标记符得到，也可以由当前指令偏移得到；即 绝对地址 和 相对地址 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:4:1","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"数据寻址 本质是如何在指令中 表示 操作数的地址，如何用这种表示计算出 操作数地址 隐含寻址 例如单地址指令中隐含的地址一样，操作数地址隐含在操作码的定义里 立即数寻址 补码表示操作数直接在指令中给出，例如 ADD 1 1 优点 是过程中不用访存 缺点 立即数长度限制了立即数范围 直接寻址 直接在指令中指出操作数地址的真实值 优点 是简单仅访问一次内存 缺点 是指令长度决定了地址的上限，操作数的地址修改不容易！ 间接寻址 指令地址给出操作数地址所在储存单元的地址， 也就是需要一次间接寻址，间接寻址也可以是多次间接寻址，通过主存中取得的字的第一位的取值判断是否是取得操作数地址： 取 0， 表示当前地址是操作数地址 取 1， 表示当前地址是操作数间址 优点 扩大寻址范围，方便子程序返回 缺点 多次访存， 一般扩大寻址地址的方法是寄存器间接寻址 寄存器寻址 直接在指令字中给出操作数所在寄存器编号 优点 不访问主存，执行速度快， 支持向量矩阵运算 缺点 寄存器价格贵，数量有限 寄存器间接寻址 在指令字中给出寄存器编号，该寄存器内存储操作数的地址 优点 速度更快，用于扩展寻址范围 缺点 只能一次间址，需要访问主存 相对寻址 相对寻址是相对于 PC 上加上指令偏移量 A 而形成的有效地址，A 可正可负，补码表示 优点 操作数地址不固定，广泛用于转移指令 缺点 A 的位数决定寻址范围 注意 PC 寄存器取下一条指令后自增，然后再加上偏移量 基址寻址 实际地址 EA = (BR) + A，即基址 + 形式地址。基址寄存器是面向操作系统的，主要解决程序逻辑空间与储存器物理空间无关 优点 扩大寻址范围，利于多道程序设计，利于编写非线性程序（浮动程序），用于各种页表，段表实现 缺点 形式地址位数较短 变址寻址 变址寄存器寻址是 形式地址 A + 变址寄存器 IX，这里的变址寄存器区别于基址寄存器，是面向用户的，其中 IX 的位数足以表示整个存储空间 优点 扩大寻址范围，便于编制循环程序，用于实现数组，因为指令中的 A 是固定的， 而IX是可以由用户设定的 缺点 A 不可变？硬找借口？ 堆栈寻址 堆栈是存储器(或专用寄存器)中一块特定的，后进先出的(LIFO) 原则管理的存储区，该存储区中 读/写单元的地址使用一个特定寄存器SP给出的，硬堆栈/软堆栈。 硬堆栈 是寄存器堆栈，速度快，成本高，不适合做大容量堆栈 软堆栈 是主存中划分的一段区域，速度稍慢，成本低，适合大容量 寻址方式 有效地址 访存次数 隐含寻址 程序指定 0 立即寻址 A是操作数 0 直接寻址 EA=A 1 一次间接寻址 EA=(A) 2 寄存器寻址 EA=R_i 0 寄存器一次间接寻址 EA=(R_i) 1 相对寻址 EA=(PC)+A 1 基址寻址 EA=(BR)+A 1 变址寻址 EA=(IX)+A 1 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:4:2","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"程序的机器码表示 - 汇编 x86 处理器中包含8个32位通用寄存器 寄存器名称 位数 说明 EAX 32 累加器(Accumulator) EBX 32 基址寄存器(Base Register) ECX 32 计数寄存器(Count Register) EDX 32 数据寄存器(Data Register) ESI 32 变址寄存器(Index Register) EDI 32 变址寄存器(Index Register) EBP 32 堆栈基指针(Base Pointer) ESP 32 堆栈顶指针(Stack Pointer) 说明 前四个寄存器 EAX, EBX, ECX, EDX 都是32位寄存器，但是可以仅仅访问其中的半字例如：($EAX = AH + AL$), 除EBP和ESP外，其余寄存器的使用是比较任意的。 x64 汇编增加了几个寄存器和引入新的指令格式，在此仅学习 x86汇编。 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"环境配置 vscode + MASM/TASM 插件 测试代码如下： DATA SEGMENT MESG DB \"This is an Assembly Language Programe.\", 0DH, 0AH, \"$\" SPACE DB \" \", \"$\" DATA ENDS CODE SEGMENT ASSUME CS:CODE, DS:DATA START: MOV AX, DATA MOV DS, AX ; 将 DATA 段的段首址存入 DS MOV BX, 01H ; BX 初始值设为 1 AGAIN: MOV DX, OFFSET MESG ; 取欲显示的字符偏移量赋给 DX MOV AH, 09H ; 调用 9号(显示)DOS功能子程序 INT 21H MOV CX, BX ; 将 BX 的值赋给 CX INC BX NEXT: MOV DX, OFFSET SPACE ; 取空格字符偏移量赋给 DX MOV AH, 09H INT 21H LOOP NEXT ; 继续显示空格字符，直到 CX 为 0 CMP BX, 10 ; BX 与 10 比较 JBE AGAIN ; 没显示 10 次，转移到 AGAIN 继续执行程序 MOV AH, 4CH INT 21H ; 返回 DOS CODE ENDS END START 右键 运行/调试 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:1","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"汇编指令格式 AT\u0026T格式和Intel格式区别如下 项目/区别 AT\u0026T Intel 大小写 小写 大小写不敏感 操作数 第一个为源操作数,第二个为目的操作数 第一个位目的操作数，第一个为源操作数 前缀 寄存器前缀%，立即数前缀$ 不需要前缀 寻址 使用\"(“和”)\" 使用\"[\" 和 “]” 复杂寻址 disp(base, index, scale), 表示偏移量，基址寄存器， 变址寄存器，比例因子;如 8(%edx, %eax, 2) [edx+eax*2+8] 数据长度 在操作码后边一个字符表示操作数大小 b-\u003ebyte, w-\u003eword, l-\u003elong 显式的注明byte ptr, word ptr, dword ptr 注意 由于32位或64位体系结构都是由16位扩展而来，因此用 word(字) 表示16位 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:2","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"常用机器指令 汇编指令通常可以分为 数据传送指令， 逻辑计算指令， 控制流指令 以下以** Intel 格式**为例介绍重要指令: 约定 \u003creg32\u003e 表示eax,ebx,edx,…. \u003creg16\u003e 表示ax, bx, dx \u003creg8\u003e 表示ah, al, bh,bl,… \u003cmem\u003e 表示内存地址，如[eax]、[var+4]、dword ptr [eax+ebx] \u003ccon\u003e 表示8位、16位或32位常数 mov 指令 将 第二个操作数(寄存器，内存，常数内容) 复制到 第一个操作数(寄存器或内存)，不能用于内存到内存的复制 mov \u003creg\u003e,\u003creg\u003e mov \u003creg\u003e,\u003cmem\u003e mov \u003cmem\u003e,\u003creg\u003e mov \u003creg\u003e,\u003ccon\u003e mov \u003cmem\u003e,\u003ccon\u003e push 指令 将操作数压入内存的栈，常用于函数调用。ESP 是栈顶指针，压栈前 ESP-=4，栈增长方向与内存地址增长方向相反，然后将操作数压入 ESP 指示的地址 push \u003creg32\u003e push \u003cmem\u003e push \u003ccon32\u003e // 栈元素固定 32 位 eg: push eax push [var] pop 指令 将栈顶元素送出，pop指令将 ESP 地址内容出栈，再将 ESP 值加 4 pop edi pop [ebx] add/sub 指令 将两个操作数相加/减，结果保存到第一个操作数中 add \u003creg\u003e,\u003creg\u003e / sub \u003creg\u003e,\u003creg\u003e add \u003creg\u003e,\u003cmem\u003e / sub \u003creg\u003e,\u003cmem\u003e add \u003cmem\u003e,\u003creg\u003e / sub \u003cmem\u003e,\u003creg\u003e add \u003creg\u003e,\u003ccon\u003e / sub \u003creg\u003e,\u003ccon\u003e add \u003cmem\u003e,\u003ccon\u003e / sub \u003cmem\u003e,\u003ccon\u003e inc/dec 指令 操作数自增自减指令 inc \u003creg\u003e / dec \u003creg\u003e inc \u003cmem\u003e / dec \u003cmem\u003e // eg: dec eax inc dword ptr [var] imul 指令 带符号整数乘法指令，有两种形式 1. 两个操作数相加结果保存到第一个操作数 2. 三个操作数后两个数相加结果保存到第一个操作数 imul \u003creg32\u003e,\u003creg32\u003e imul \u003creg32\u003e,\u003cmem\u003e imul \u003creg32\u003e,\u003creg32\u003e,\u003ccon\u003e imul \u003creg32\u003e,\u003cmem\u003e,\u003ccon\u003e // tag: 这里显然不能存储到 \u003cmem\u003e 所以该过程最多只有一次非读指令访存 // 如果乘法操作可能溢出，则编译器溢出标志 OF = 1，是CPU调溢出处理程序 idiv 指令 带符号整数除法指令，他只有一个操作数，而被除数为 edx:eax中的内容（是拼接的64位整数），操作结果有两部分：商和余数，商-\u003eeax, 余数-\u003eedx // (edx:eax) / op_1 = edx:eax idiv \u003creg32\u003e idiv \u003cmem\u003e // eg: idiv ebx idiv dword ptr [var] and/or/xor 指令 结果放在第一个操作数里 and \u003creg\u003e,\u003creg\u003e / or \u003creg\u003e,\u003creg\u003e / xor \u003creg\u003e,\u003creg\u003e and \u003creg\u003e,\u003cmem\u003e / or \u003creg\u003e,\u003cmem\u003e / xor \u003creg\u003e,\u003cmem\u003e and \u003cmem\u003e,\u003creg\u003e / or \u003cmem\u003e,\u003creg\u003e / xor \u003cmem\u003e,\u003creg\u003e and \u003creg\u003e,\u003ccon\u003e / or \u003creg\u003e,\u003ccon\u003e / xor \u003creg\u003e,\u003ccon\u003e and \u003cmem\u003e,\u003ccon\u003e / or \u003cmem\u003e,\u003ccon\u003e / xor \u003cmem\u003e,\u003ccon\u003e // eg: and eax, 0fH xor edx, edx not 指令 位反转指令，将操作数每一位反转 not \u003creg\u003e not \u003cmem\u003e // example: not byte ptr [var] neg 指令 取负指令 neg \u003creg\u003e neg \u003cmem\u003e // eg: neg eax shl/shr 指令 逻辑移位指令， l 为左， r 为右，第一个操作数是被移位，第二个操作数是移位位数 shl \u003creg\u003e,\u003ccon8\u003e / shr \u003creg\u003e,\u003ccon8\u003e shl \u003cmem\u003e,\u003ccon8\u003e / shr \u003cmem\u003e,\u003ccon8\u003e shl \u003creg\u003e,\u003ccl\u003e / shr \u003creg\u003e,\u003ccl\u003e shl \u003cmem\u003e,\u003ccl\u003e / shr \u003cmem\u003e,\u003ccl\u003e // cl 是 8 位寄存器 // eg： shl eax, 1 shr ebx cl 标签 IP 寄存器是 CPU 硬件结构，其值是不能直接指定的，只能通过控制流指令来更改，在 x86 汇编中使用标签来标记代码地址 movesi, [ebp+8] begin: xor ecx, ecx mov eax, [esi] jump 指令 直接跳转类似 goto 语句 jmp \u003clabel\u003e // eg: jmp begin j\u003ccondition\u003e 指令 条件转移指令 je \u003clabel\u003e (jump when equal) jne \u003clabel\u003e (jump when not equal) jz \u003clabel\u003e (jump when last result was zero) jg \u003clabel\u003e (jump when greater than) jge \u003clabel\u003e (jump when greater than or equal to) jl \u003clabel\u003e (jump when less than) jle \u003clabel\u003e (jump when less than or equal to) // eg: cmp eax, ebx jle done // tips:这里的跳转指令并不依赖某个寄存器的值，而是依赖 由cmp和test指令确定的 CPU 的状态值 cmp/test 指令 cmp 用于比较两个操作数的值，test 对两个数进行逐位与运算，他们不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码 cmp \u003creg\u003e,\u003creg\u003e / test \u003creg\u003e,\u003creg\u003e cmp \u003cmem\u003e,\u003creg\u003e / test \u003cmem\u003e,\u003creg\u003e cmp \u003creg\u003e,\u003cmem\u003e / test \u003creg\u003e,\u003cmem\u003e cmp \u003creg\u003e,\u003ccon\u003e / test \u003creg\u003e,\u003ccon\u003e // tips:cmp,test和jcondotion指令搭配使用，举例： cmp dword ptr [var], 10 // 比较 4 字节 jne loop // 相等继续执行，否则跳转到loop test eax, eax // 测试eax 是否为0 jz xxxx // 为0则设置标志位 ZF 位1，跳转到 xxxx 处执行 call/ret 指令 用于实现子程序（过程，函数等）的调用和返回， call 指令将当前执行的指令地址入栈，然后无条件转移到有标签指示的指令。call指令还会保存调用之前的信息。 ret 实现了子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址。 call \u003clabel\u003e ret ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:3","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"过程调用机器表示 使用 call/ret 指令实现过程调用，假定过程P(调用者) 和 过程Q(被调用者)，过程调用步骤如下： P 将入口参数放在 Q 能访问到的地方 P 将返回地址存到特定的地方，然后将控制权转移到 Q (IP寄存器指向) Q 保存 P 的现场(通用寄存器的内容)，并为自己的非静态局部变量分配空间 执行过程 Q Q 回复 P 的现场，将结果放到 P 能访问到的地方，并释放局部变量所占空间 Q 取出返回地址，将控制转移到 P 注意 ： 上述步骤中需要为入口参数，返回地址，过程P现场，过程Q局部变量，返回结果 找到存放空间，而用户可见的寄存器数量是有限的，因此需要在内存中用一个栈来存放数据，EAX、ECX、EDX是调用者保存寄存器，其保存和恢复过程由P负责。EBX、ESI、EDI 是被调用则保存寄存器，每一个过程都有其自己的栈区，成为栈帧(Stack Frame)。寄存器 EBP指示栈底，ESP 指向栈顶，栈从高地址向低地址增长。 例如 // 被调用函数/过程 int add(int x, int y){ return x + y; } // 调用者过程 int caller(){ int temp1 = 125; int temp2 = 80; int sum = add(temp1, temp2); return sum; } 经过 GCC 编译后 caller 过程的汇编码如下 ： caller: # stage 1 pushl %ebp movl %esp, %ebp # 系统栈 \u0026\u0026 用户栈 # ebp 和 esp 是 用户栈 指针 # 而 push 指令是对系统栈的操作 # 1. 将当前用户栈基址压入系统栈 # 2. 新用户栈基址设为栈顶指针 subl $24, %esp # 为当前过程开辟 24B 内存空间(栈帧) # 此时 esp = ebp - 24，所以栈顶指针更小 # 这里 只用了 28B，是因为 GCC 规定栈帧必须是16B的整数倍 # stage 2 定义变量 movl $125, -12(%ebp) # 这里的变量是由 esp 向 ebp 方向依次放置 movl $80, -8(%ebp) # stage 3 传入函数参数 movl -8(%ebp), %eax mov %eax, 4(%esp) # temp2 先入栈 movl -12(%ebp), %eax movl %eax, (%esp) # temp1 后入栈 # stage 4 调用函数 call add # stage 5 取出函数返回值 movl %eax, -4(%ebp) # 将返回值取出到变量 sum movl -4(%ebp), %eax # 将 sum 作为返回值 # 返回值是通过 eax 寄存器返回的，所以E(A|C|D)X寄存器是由调用者返回的 # stage 6 离开 add 函数 leave # 等价于： # movl %ebp, %esp # popl %ebp # stage 7 退出当前 caller 过程 ret add 过程对应过程的汇编码如下 push %ebp mov %esp, %ebp mov 0xc(%ebp), %eax # 将参数2放入寄存器 # 这里的栈帧是有高位向低位 # 函数参数是从右往左入栈 mov 0x8(%ebp), %edx # 将参数1放入寄存器 lea (%edx, %eax, 1), %eax # 将add_1传入add_2 # 这里是直接通过地址计算 # 使用 lea 指令是因为不占用 ALU，比较快 # 使用单指令代替了多条指令 pop %ebp ret Question：传入参数时是将参数的临时变量拷贝到了 4(%esp) 和 (%esp)，但是为什么在 add 过程中取参数时是取的 0xc(%ebp) 和 0x8(%ebp)？？ Answer： 因为 call 指令会改变 esp 寄存器的值，会将函数返回地址入栈，然后 esp += 4 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:4","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"选择语句机器表示 以 c 语言为例，选择语句主要是 if-then, if-then-else, switch, 编译器条件码(标志位)设置指令各类转移指令来实现选择结构语句 条件码（标志位） 条件码是CPU维护的状态寄存器，他们描述算术逻辑操作的属性，可以检测这些寄存器来执行分支指令： CF 进(借)位标志，适用于最近的无符号整数加减运算，有进(借)位 CF = 1 ZF 零标志，标志最近操作结果是否为0 SF 符号标志，标志最近的带符号数运算结果，负 :SF = 1 OF 溢出标志，标志最近带符号数运算结果是否溢出 由于OF，SF对无符号数无意义， CF对带符号数无意义，常见的算术逻辑运算指令都会设置条件码 IF 语句 通用形式如下 if(test_expr) then_statement else else_statement 翻译为 goto 语句形式 t = test_expr; if(!t) goto false; then_statement goto done; false: else_statement done: 对于下面的 c 语言函数 int get_count(int *p1, int *p2) { if(p1 \u003e p2) return *p2; else return *p1; } 将得到以下汇编码 movl 8(%ebp), %eax movl 12(%ebp), %edx cmpl %edx %eax jbe .L1 movl (%edx), %eax jmp .L2 .L1: movl (%eax), %eax .L2: SWITCH 语句 对于 小范围 和 小量 的选择语句，使用 跳转表，对于大范围或者大量的选择语句编译器还是会和 if-then-else 一样的方式来处理 跳转表即： .L12: .long .L3 .long .L4 .long .L5 .long .L6 .long .L7 .long .L8 这样就可以通过 相对于 .L12 的偏移量来计算真实的跳转目的地了，这样的跳转只需一个指令来找到跳转目的，而不是多层的 if-else 嵌套，有点字典内味了。这也解释了为什么switch-case语句需要break来退出case，因为所有的case在地址上是连续的。 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:5","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"循环语句机器表示 常规的循环语句 有while,for, do-while 大多数编译器都将上述三种形式的循环语句转化为do-while 语句 DO-WHILE 循环 do body_statement while(text_expr) goto 语句形式 loop: body_statement t = test_expr; if(t) goto loop; WHILE循环 while(test_expr) body_statement 在第一次执行循环体之前先执行一次 t = test_expr; if(!t) goto done; do body_statement while(text_expr); done: t = test_expr if(!t) goto done; loop: body_statement t = test_expr; if(t) goto loop; done: FOR 循环 一般形式 for(init_expr; test_expr; update_expr) body_statement 转化为 while 循环 init_expr; while(test_expr){ body_statement update_expr; } 转化为 goto 语句 init_expr; t = test_expr; if(!t) goto done; loop: body_statement update_expr; t = test_expr; if(t) goto loop; done: int nsum_for(int n){ int i; int result = 0; for(i = 1; i\u003c=n; i++) result += i; return result; } ==== 编译 ====\u003e movl 8(%ebp), %ecx movl $0, %eax movl $1, %edx cmp %edx, %ecx jg .L2 .L1: addl %edx, %eax addl $1, %edx cmpl %ecx, %edx jle .L1 .L2: 直接按照模板即可 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:6","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"最近 Nreal Air 眼睛发售，看到有玩家自制的 游戏王AR 游戏，能将怪物真的召唤到场地，非常震撼，于是思考能不能将传统的游戏类型用AR来表达呢？ 很自然的想到了 马里奥赛车：实况，借鉴这样的思路可以想到一种全新的游戏类型，以马里奥：奥德赛为例，AR眼睛首先识别出所在场景中所有的物体，这里主要包括以下类别： 平台 常见可交互物体（例如放在茶几上的书📕📖） 游戏通过识别出的几何体来构建场景🌃，按照模板关卡程序生成关卡，在各个物体的背后埋藏小惊喜（可以在现实中移动物体，可以操作马里奥与物体交互），这些物体都是程序预设的可交互物体模型，玩家通过发现各个现实场景中的潜在的关卡模板，然后进行闯关，通过关卡即可收集该关卡模板，并能够与朋友分享🧑‍🤝‍🧑 这个想法需要解决以下技术难点： 稳定的识别出预设物体 通过一个只包含3D几何体的场景，生成关卡 要决定哪些物体将变为平台，哪些能将玩家吹起来，哪些是移动平台，等 要决定在什么放置金币🪙，放置怪物，放置惊喜 需要程序来决定如何通过金币，惊喜，来引导玩家走向终点 如果现有的场景无法构建出关卡，还要决定在什么位置添加平台，辅助完成关卡 玩家如何操作角色（手柄🕹🎮？手势？APP？） 其中最复杂的应该是生成场景的规则？这是一个复杂的工程，想到这里就不往下想了🧠，想也想不明白，等着任天堂做吧？交给你了任天堂💕！ ","date":"2023-01-03","objectID":"/idea-xr-you-xi-ling-gan/:0:0","tags":null,"title":"XR 游戏灵感","uri":"/idea-xr-you-xi-ling-gan/"},{"categories":null,"content":"动机 Tween 节点可以用于创建补间动画，但是由于只能指定固定缓动函数，并且不能使用 value = f(time) 的形式计算值，所以需要设计一个新的缓动函数类，并实现对应的Inspector插件 通常的缓动曲线都是选用 三角函数，或者使用贝塞尔曲线绘制的自定义曲线，为了逼近现实的运动感，这里实现一种自动控制系统里常用的二阶曲线 ","date":"2023-01-03","objectID":"/godot-huan-dong-qu-xian-jie-dian-she-ji/:0:1","tags":null,"title":"[Godot] 缓动曲线节点设计","uri":"/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"categories":null,"content":"SecondOrderCurves 设计 首先时二阶系统需要的三个参数，在 Godot 中使用 Vector3 表示， 以及运算过程的中间变量 // 使用插件修复 Godot 不识别自定义类型的 Bug [RegisteredTypeAttribute(nameof(SecondOrderCurves), \"\", nameof(Godot.Object))] public class SecondOrderCurves : Godot.Object { [Export] public Vector3 Parameters = Vector3.One; private Vector2 xp; private Vector2 y, yd; private float k1, k2, k3; private float T_crit; // 用于处理单时间片无法完成的模拟 } 二阶系统的参数只有三个变量，但是我们需要一个输入函数 X(y), 和得到一个响应函数Y(y)，其中输入函数是必须的，它决定以某一时刻系统的输入, 而响应函数可以在游戏运行时实时模拟。 // 输入函数由一些点组成，是折线函数 [Export] public Array\u003cRect2\u003e points = new Array\u003cRect2\u003e() { new Rect2(new Vector2(0, 300), new Vector2(10, 10)), new Rect2(new Vector2(200, 300), new Vector2(10, 10)), new Rect2(new Vector2(200, 150), new Vector2(10, 10)), new Rect2(new Vector2(400, 150), new Vector2(10, 10)), }; 点集是 `X(t)` 的离散表示，对于连续值得输入，需要在两个点之间进行插值，这里简单的采用线性插值 public Vector2 Interpolate(float x) { for(int i = 0; i \u003c points.Count - 1; i++) { if(points[i].GetCenter().x \u003c= x \u0026\u0026 x \u003c= points[i+1].GetCenter().x) { float y1 = points[i].GetCenter().y; float y2 = points[i+1].GetCenter().y; float x1 = points[i].GetCenter().x; float x2 = points[i+1].GetCenter().x; return new Vector2(x, (y1 - y2) / (x1 - x2) * (x - x2) + y2); } } return -1 * Vector2.One; } 对于某时刻 t 一个 X(t) 对应一个X(t); 为了计算 Y(t)，这里采用逐帧计算， // 输入 X(t), 和 delta， 得到当前t时刻的Y(t) public Vector2 Interpolate(Vector2 x, float delta) { Vector2 xd = (x - xp) / delta; xp = x; int iterations = Mathf.CeilToInt(delta / T_crit); // take extra iterations if delta \u003e T_crit delta = delta / iterations; for(int i = 0; i \u003c iterations; i++) { y = y + delta * yd; yd = yd + delta * (x + k3 * xd - y - k1*yd) / k2; } return y; } ","date":"2023-01-03","objectID":"/godot-huan-dong-qu-xian-jie-dian-she-ji/:0:2","tags":null,"title":"[Godot] 缓动曲线节点设计","uri":"/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"categories":null,"content":"编辑器插件设计 可以参考 Godot.Curve 的实现，但是没有开放 gdscript/c# 接口，只能使用c++拓展，比较繁琐，就自行实现显示和交互逻辑。 编辑器绘图 为了能在编辑器中看到效果，需要在编辑器环境中预览响应函数 Y(t) 的形状。所以使用 point_set 存储曲线值， 表现效果如下图所示： // 只有标记为 Tool 的脚本才会在编辑器环境被加载 [Tool] public class CurveCanvas : Control { Array\u003cVector2\u003e point_set = new Array\u003cVector2\u003e(); Vector2 point_size = Vector2.One * 10; } 模拟每帧的Y(t) 计算： public void ReDraw(SecondOrderCurves curve = null) { // 缓存 cached if(curve != null) { cachedCurve = curve; } else { return; } point_set.Clear(); Vector2 start = Transform(cachedCurve.StartPoint); Vector2 end = Transform(cachedCurve.EndPoint); if(start.x == -1 || end.x == -1 || cachedCurve == null) { return; } // points.Sort(new PointComp()); // Godot.Collection.Array 不支持排序，需要实现一下 cachedCurve.Init(start); int iter = 200; for(int i = 0; i \u003c iter; i++) { Vector2 x = Transform(cachedCurve.Interpolate(cachedCurve.StartPoint.x + i* (cachedCurve.EndPoint.x - cachedCurve.StartPoint.x) / iter)); Vector2 point = cachedCurve.Interpolate(new Vector2(x.y, x.y), 0.01f); point_set.Add(new Vector2(x.x * RectSize.x, (1 - point.x) * RectSize.y)); } Update(); } 由于 Godot 是以右下为正，所以需要对坐标进行转换 private Vector2 Transform(Vector2 point) { return new Vector2(point.x / RectSize.x, (RectSize.y - point.y) / RectSize.y); } 使用 Godot 的绘图函数 public override void _Draw() { // 具体就不展示了，是一些繁琐的代码 DrawMesh(); DrawPoints(); DrawCurve(); DrawInteractive(); } 编辑器交互 为了能够添加/移动/删除图像上的点， 需要实现以下功能： 单击鼠标左键添加点 长按鼠标左键移动点 单机鼠标右键删除点 public override void _Process(float delta) { cover_index = cachedCurve.FindPoint(GetLocalMousePosition()); SafeDragingArray = new Rect2(GetRect().Position, GetRect().Size - Vector2.One * 10); // 退出拖动的调节 if(Dragging \u0026\u0026 IsMouseIn \u0026\u0026 0 \u003c= DraggingIndex\u0026\u0026 DraggingIndex \u003c cachedCurve.points.Count \u0026\u0026 SafeDragingArray.HasPoint(GetLocalMousePosition())) { (cachedCurve.points[DraggingIndex]) = new Rect2(GetLocalMousePosition(), point_size); } Update(); } 监听鼠标输入，在Godot 中连接 CurveCanvas 的鼠标信号 void _on_CurveCanvas_gui_input(InputEvent @event) { if(!IsMouseIn) { return; } if(@event is InputEventMouseButton mouse) { if(mouse.ButtonIndex == (int)ButtonList.Left) { // 1. 创建节点 if(cover_index == -1 \u0026\u0026 !mouse.Pressed \u0026\u0026 !Dragging) { cachedCurve.points.Add(new Rect2(GetLocalMousePosition(), point_size)); } // 2. 开始拖动 if(cover_index != -1 \u0026\u0026 mouse.Pressed) { Dragging = true; DraggingIndex = cover_index; } // 3. 结束拖动 if(!mouse.Pressed) { if(Dragging) ReDraw(); Dragging = false; DraggingIndex = -1; } ReDraw(); } if(mouse.ButtonIndex == (int)ButtonList.Right) { // 删除当前 cover 的节点 if(cover_index != -1 \u0026\u0026 !mouse.Pressed) { cachedCurve.points.RemoveAt(cover_index); } ReDraw(); } } } 编辑器插件（踩坑） Godot 的编辑器插件功能非常多，可以添加Dock，Inspector，主屏幕，等插件。几乎可以实现编辑器阶段的的所有拓展；这里我们主要使用 Inspector 插件来编辑 SecondOrderCurves.parameters. plugin.cs 首先在 plugin.cs 中添加加载/删除 CurveEditorInspector 的代码 tips: 千万不能忘记添加[Tool]，第一次 Build 时会报错，然后再Build一次就Ok了，原因是 C# 是需要编译的而gdscript可以热更新，所以干儿子者不如亲儿子。 #if TOOLS using Godot; using System; [Tool] public class plugin : EditorPlugin { CurveEditorInspector inspector; public override void _EnterTree() { inspector = GD.Load\u003cCSharpScript\u003e(\"res://addons/curve_editor/CurveEditorInspector.cs\").New() as CurveEditorInspector; AddInspectorPlugin(inspector); } public override void _ExitTree() { RemoveInspectorPlugin(inspector); } } #endif EditorInspectorPlugin.cs EditorInspectorPlugin 是一个大坑，它有两种主要的运行模式： 修改单属性 修改多属性 起初我不明白 AddPropertyEditor 和 AddPropertyEditorForMultipleProperties 有什么区别，他们似乎具有相似的行为。后来理解了，在 AddPropertyEditorForMultipleProperties 中指定的属性名列表和在AddPropertyEditor 中指定属性名，这样Godot就会知道需要序列化哪些字段，并且在来回切换窗口或者充气Godot后，已经被编辑的属性能够不被重置。 using Godot; using System; #if TOOLS public class CurveEditorInspector : EditorInspectorPlugin { public override bool CanHandle(Godot.Object @object) { if(@object is SecondOrderCurves) { AddPropertyEditorForMultipleProperties(\"\", new string [] {\"F\", \"Z\", \"R\"}, new CurveEditorProperty()); return true; } return false; } public override bool ParseProperty(Godot.Object @object, int type, string path, int hint, string hintText, int usage)","date":"2023-01-03","objectID":"/godot-huan-dong-qu-xian-jie-dian-she-ji/:0:3","tags":null,"title":"[Godot] 缓动曲线节点设计","uri":"/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"categories":null,"content":"Show Show Way 最后展示一下运行效果 ","date":"2023-01-03","objectID":"/godot-huan-dong-qu-xian-jie-dian-she-ji/:0:4","tags":null,"title":"[Godot] 缓动曲线节点设计","uri":"/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"categories":null,"content":"Dynamic Global lllumination(GI) ","date":"2022-12-30","objectID":"/games104/:0:0","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Ray Tracing 先上祖师爷 $$ L_0(x, \\omega_0) = L_e(x,\\omega_0) + \\int_{H^2}f_r(x,\\omega_0,\\omega_i)L_i(x,\\omega_i)\\cos\\theta_id\\omega_i $$ $$ outgoing = emitted + reflected $$ 光照中最困难的部分就是积分，一个trick的方法是 蒙特卡洛积分，基于此就产生了蒙特卡洛光线追踪 原理： 从像素点打出光纤，碰到物体做一次bounce，随着bounce次数增加，计算量是指数级的 缺点： 量的地方很少，只有很少机会打中发光点 计算量大 采样次数越多，噪点越少 难点：采样 tips：所以 Lumen 重点解决的就是采样 采样 均匀采样 概率分布函数（按照PDF分布）采样 就是按照概率分布函数来采样，这样能更好的计算积分，朴素的来说，就是往更亮的地方发射更多的光线 例如：对于天空采样，那么使用 cos 函数（方向靠近正上方发射更多的射线）将会获得噪声更少的图像 例如：对于光暗差别很大的场景使用 GGX PDF 可以获得对比度更强的光照效果 但是这些都是特例，不具有普遍意义，这给我们的启示是 要往亮的地方发射更多的射线 但是上述的算法都是离线计算（用于电影动画广告？中的），但是对于游戏来说，需要一种 realtime 的方法 ","date":"2022-12-30","objectID":"/games104/:1:0","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Lumen 的起始点 Lumen 这一系列方法的基本思路就是 Photon Mapping 思路如下： 提出从光源发射光子，光子最终停留在物体表面，最终渲染就是根据物体表面光子的分布来计算最终颜色 Reflective Shadow Maps(RSM, 2005) 这个工作是这一系列方法的开山鼻祖 ","date":"2022-12-30","objectID":"/games104/:2:0","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"RSM 方法 原文链接 ：Reflective Shadow Maps 渲染物体是从相机视角去看世界的，渲染阴影的时候是从光的视角去看世界的。 Reflective Shadow Maps 的意思就是：从光的角度去看世界，记录所有被照亮的表面，这个表面就是不考虑光线追踪的情况下，光子第一次到达的场景。 空间所有中第一次被照亮的点会散射出光线照亮其他物体，那么在渲染任何一个眼睛看到的点的时候，只需要将所有散射出来的 radiance 收集起来即可。 也就是说对于每一个需要被渲染的像素点， 我们知道所有能照亮该点的亮点（在光的第一次传播被照亮的点），那么计算被渲染点和亮点之间的距离即可知道光照强度。（这个牛逼啊） 缺点：是渲染复杂度太高 优化1 使用了 Cone Tracing 来优化算法，就是发射许多圆锥去照亮点，如果 Cone 中的 RSM 越多那么就越亮，大概是这么个意思。后来还有更好的方法例如： 对 RSM 做 MIP，对于漫反射面使用较大的圆锥去采样，对于光滑的表面用角度较小的圆锥去采样。 优化2 因为间接光照是低频的，所以在屏幕空间可以不用逐像素采样，而是采用 逐 k 像素采样，在 Lumen 中也有类似的思想（原来这么早就有了，看来Lumen是个大缝合怪） 优化3 Cone Tracing 采样时，可以认为 空间位置相差太大 或者 法线朝向相差太大 的点被认为是无效点，就不采样，而是在第一次样样结束后进行一次单独采样，类似的 在 Lumen 中对于稀疏采样不work的点，会进行一次单独的加强采样采样（这个也是抄的） 总结 将光子注入到世界的方法 但是没有想到 MIP方法 在低分辨率稀疏点采集间接光照进行插值，但是在特殊区域进行加强采样 使用 Cone 进行蒙特卡洛积分 没有检测遮挡 只能解决单次传播 RSM 是非常具有启发性的算法 ","date":"2022-12-30","objectID":"/games104/:2:1","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Light Propagation Volumes(LPV) 上一个算发解决了将光子注入空间，这个算法解决光子在空间中传播，虽然是一个非常具有启发性的算法，但是在数学上有点问题 重点是 Propagation， 但是想法很淳朴： 将空间划分为很多 Voxel，对于每个 Voxel，接收到的光照是一个球面分布，球面无论采集多少个点都可以等价为加权累积到一起，可以用SH（双曲正弦函数）函数表达，这里 在GAMES 202 中会详细的讲，这个104讲得很笼统，不好理解（之后补202的时候仔细搞搞）。 这个方法老师也没看懂，我肯定看不懂了，物理学意义是数学意义都点问题。 ","date":"2022-12-30","objectID":"/games104/:2:2","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Sparse Voxel Octree for Real-time Global IIIumination(SVOGI) Nvidia 的工作，这个想法也很淳朴，解决对空间划分的粗细的问题，有以下事实： 有的 Voxel 中没有物体是空的 有的 Voxel 中是实心物体，只有表面有光 使用硬件的保守光栅化：对于很小很薄的三角形保证至少有一个 Voxel 在里边，也就是说保证再小再薄的三角形也能被体素化，那就能收集所有表面的 Voxel，那就是用八叉树来对空间划分，但是在实现中 八叉树每个节点不止存子节点和父节点，还存了三个相邻节点，这使得做 过滤，抗锯齿的时候很方便，所以这个数据结构很复杂。 这里有一个巧妙的思想： 使用 Cone 进行采样，而空间是类似 MIP 的八叉树划分，那么很近的地方，Cone 采样到的 Voxel 很少，但是很远的 地方Cone 采样到的Voxel就很多，而 MIP 的思想中，越靠近根节点的 一个 Voxel 就是很多小的 Voxel 的平均，这样就很巧妙的解决了 Cone 采样，越远点越多的情况。 很多算法细节无法考证，并且八叉树在GPU 上不好表达，而且现在已经没人用这个算法了。 ","date":"2022-12-30","objectID":"/games104/:2:3","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Voxelization Based Global IIIumination(VXGI) 对于 GI 来说，是眼睛看到的区域最重要的部分，并且对于近处进行高精度采样，对远处进行低精度采样。 那么就是近距离的Voxel 很小，远处的 Voxel 很大，就行了。这种方法实现起来清晰明确简单，并且是 GPU 友好的。 trick1 循环UV，这样不会出错，但是不太懂这个的原理 trick2 按照距离来确定 Voxel 大小会导致屏幕空间上不管近远的 Voxel 大小都是几乎一致的。相当于 “地月距离和地日距离400倍，月球大小和太阳大小400倍，所以导致太阳月球看起来一样大。” 这样就很好,很一致！！ 那么光穿过 Voxel 能穿过多少呢？往往体素不是纯黑和纯透明的，而是有一定的透光率。 所以可以将体素中的实体投影到各个方向按照面积计算各个方向的透光率（三个方向） 那么就可以按照以下步骤来渲染 光线注入，计算每一个被直接照亮的 Voxel 对于屏幕上的每一个像素进行 Cone Tracing(可以不用每一个，可以 稀疏采样 + 加强采样) 基于 BRDF 生成采样圆锥，如果表面比较粗糙生成均匀的多个圆锥，如果表面比较光滑生成角度比较集中的圆锥 圆锥越远的时候使用 ClipMap 越上层的数据（近大远小） 光线传播累计不透明度，完全不透明后就不再传播 问题： 透明度累计时，直接计算乘法不合理，可能光经过一层左半遮挡，经过一层右半遮挡就全挡完了，但是乘法就还剩0.25，会产生漏光现象 在这种注入光子的思路中，该方法时集大成者！！！下面是另一种思路的算法，屏幕空间全局光照 ","date":"2022-12-30","objectID":"/games104/:2:4","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Screen Space Global IIIumination(SSGI) 最开始 在 GDC 上讲的方法，在计算反射时，例如光滑的地面反射墙壁，我们要渲染地面上的某个点，那么知道地面的法线，知道相机的方向，计算视线投射到地面时的出射方向即可，再利用这个方向去查询第一个碰到的物体。查询碰撞的方法可以使用GPU提供的屏幕空间的碰撞。 Hierachical Tracing DX12支持，他会自动将我的Z-buffer做成 mips，mip的下层都包裹着上层，然后利用类似二分的方法来做碰撞检测。大致思路是这样的，复杂度是log的，大致的思路是这样的，但是细节不清楚。 并且计算反射的 Light 是可以 Reuse 的，就是前一次光照得到点会成为后一次计算点的一个新的灯泡。大概理解，细节不理解。。。 优点：处理很光滑的物体，效果很好，有很多BUG，但是非常有用，处理很近的contact shadow，hit点很准，场景复杂度无关(仅基于深度图)，处理动态物体 ","date":"2022-12-30","objectID":"/games104/:2:5","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Lumen（重点，简称左脚踩右脚渲染） “Ray Tracing is slow” 所以需要 Lumen “Sampling is hard” 所以需要 Lumen Low-res filtered scene space probes lit full pexels ","date":"2022-12-30","objectID":"/games104/:3:0","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Phase1：Fast Ray Trace in Any Hardware Signed Distance Field(SDF) 有向距离场，物体的 外部为+，表面为0，内部为- SDF 和 顶点在本质上是对偶的 但是SDF 有很多优良性质 均匀的 连续的（可微的） 先对 Mesh 做SDF 再对空间做SDF SDF 支持统一的线性变换 对于很细的面，难以表达，所以稍微扩张一下 光纤可以很快的找到表面，光一步步向物体推进，当靠近表面时，SDF 会告诉我们应该走多大的步长，当到达表面时是0，当进入表面后，这个值是负数，又能够退回到表面。 做 Cone Tracing 时，可以预估目标的距离（按照圆的比值）：这个不懂 Mesh SDF LoD（多细节层次） SDF 导数是表面法线 做 MIP 节省40% 空间 Global SDF：将所有物体的SDF 合成一个低精度的场景的SDF 合成算法（由Mesh合成场景） 更新算法（物体是移动的） 总的来说就是，使用 SDF 来表达每一个Mesh 和场景，这样带来了很多计算上的好处，它能提高 Ray Tracing 的效率，从而不依赖于硬件的 Ray Tracing ","date":"2022-12-30","objectID":"/games104/:3:1","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Phase2 Radiance Injection and Caching 这一部分解决：如何抓住光的？ Mesh card 就以相机为原点，对场景中所有物体进行快照，记录该物体 AABB Box 对应的各个面的光照信息（法线，光照，自发光，等），并且这个快照是LoD的（近处高分辨率，远处低分辨率） Surface Cache：分配一个 4096x4096的空间，将每一个 Instance 的Card放到空间里，随着相机的移动，可能会替换（硬件提供方法来压缩），是对直接光照信息的一个表达（将光子固化在表面），在相机移动和物体移动时采用脏更新。 Lighting Cache Pipeline： 做逐像素的直接光照（做shadow map，不会错的离谱） 知道 Mesh 的各种光线相关的图，并且通过 SDF 可以很快的判断遮挡信息，所以可以很快的计算出直接光照图 对于多个光源，累加在一起即可 在场景中建立 Voxelize 表达，并且将当前帧的光照信息传递给下一帧 建立体素，来采样，本来我们的SDF是近距离精准，远距离模糊的，远距离模糊那怎么看有没有打到物体上呢？就应该使用 Global SDF， 但是 Global SDF 只能定位到像素点，而不能定位到具体某个 Instance。 Lumen的解决方法是：对于近处的物体，可以精准的拿到光照信息，对于远处的的物体：以相机为中心做一个 Voxelize的表达，然后 采样光线只要在Global SDF中Hit到了，就直接给那个位置的 Voxelize 的光照信息。 Lumen的具体方法： 做一个 ClipMap，四层，每一层 64x64，一个Voxel 是0.78米，每个Voxel的6个面存储亮度，这样在对某个点光照信息积分的时候，发出的光纤就能永远的cast到一个值，这里的 voxel 6个面是只有一个值，而不是光场。这里有点迷惑。那怎么来照亮别人呢？ 在下一帧中融合表面直接光照和由上一帧继承而来的光照图，得到真实光照 虽然每次都只做了一次bounce但是在数学上可以推导，实际上就是做了多次bounce（GAMES202 会推导） Tips:一些限制 直接光照不超过 1024x1024 texture 间接光照不超过 512x512 texture 选择页来更新，基于 Priority = LastUsed - LastUpdated ","date":"2022-12-30","objectID":"/games104/:3:2","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Phase3：Screen Probe structure 怎么区分布Prob，对于屏幕上的每一个点如何使用 Prob去lighting 采样使用八面体球面采样（几乎是均匀的），并且插值与球面几乎一致 屏幕空间放置采样点，有一个问题，就是真实的场景中相邻屏幕空间采样点可能是相距很远的。他们并不能很好的插值。 所以应该添加真实距离作为权重，而如果两个相距超过某个阈值，那么就应该申请细分探针数量 如果将屏幕空间的采样点打印出来，会发现所有几何变化较大的地方都会进行细分探针。 采样 需要进行importance sampling，就会出现黑一块白一块。 最重要的是，需要朝“窗户”的地方多射一点。怎么知道光在哪里呢？ 可以采集上一帧的光的位置（假设光的变化不是那么大） 采样的时候需要按照重要性分布来采样，也就是往光多的地方采样，并且重要性还与法向方向有关 巴拉巴拉，没听懂我操。直接听大概意思吧。不学了。 ","date":"2022-12-30","objectID":"/games104/:3:3","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Phase4 拿到一个屏幕像素，如何使用Prob来做shading ","date":"2022-12-30","objectID":"/games104/:3:4","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"1. Dirichlet Conditions 一个周期内, 连续或者有有限个第一类间断点 一个周期内, 有限个极值点 一个周期内可积 ","date":"2022-12-30","objectID":"/fourier/:0:1","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"2. Trangle Transform 假设 $$ f(t) = c_0+\\sum_{n=1}^{\\infty}c_n\\cos(n \\omega t + \\varphi) =c_0+\\sum_{n=1}^{\\infty}[c_n\\cos\\varphi\\cos(n\\omega t)- c_n\\sin\\varphi \\sin(n\\omega t)] $$ 令 $a_n = c_n \\cos\\varphi,\\qquad b_n = -c_n\\sin\\varphi$ $$ f(t) = c_0+\\sum_{n=1}^{\\infty}[a_n\\cos(n\\omega t) + b_n \\sin(n\\omega t)]\\ \\int_0^T f(t)\\sin(k\\omega t) dt= \\int_0^Tc_0\\sin(k\\omega t) dt + \\int_0^T\\sin(k\\omega t)\\sum_{n=1}^{\\infty}[a_n\\cos(n\\omega t) + b_n \\sin(n\\omega t)] dt\\ \\int_0^T f(t)\\sin(n\\omega t) dt= 0 + b_n \\frac{T}{2}\\ b_n = \\frac{2}{T} \\int_0^T f(t)\\sin(n\\omega t) dt $$ 与 2 相似的可以计算得到 $c_n, a_n, \\varphi, c_0$ ","date":"2022-12-30","objectID":"/fourier/:0:2","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"3. Fourier 级数 根据欧拉公式: $$ e^{jx} = \\cos x + j\\sin x\\ \\cos(n\\omega t) = \\frac{e^{jn\\omega t} + e^{-jn\\omega t}}{2}\\ \\sin(n\\omega t) = \\frac{e^{jn\\omega t} - e^{-jn\\omega t}}{2j}\\ $$ (8) (9)代入(3) $$ f(t) = c_0+\\sum_{n=1}^{\\infty}[a_n \\frac{e^{jn\\omega t} + e^{-jn\\omega t}}{2} + b_n \\frac{e^{jn\\omega t} - e^{-jn\\omega t}}{2j}]\\ $$ 由于 : $$ a_n = \\frac{2}{T} \\int_0^T f(t)\\cos(-n\\omega t)dt = a_{-n}\\ 同理:-b_n = b_{-n} $$ 整理得到: $$ f(t) = c_0 + \\sum_{n=1}^{\\infty}[\\frac{a_n-jb_n}{2}e^{jn\\omega t} + \\ \\frac{a_{-n} - jb_{-n}}{2}e^{-jn\\omega t}]\\ f(t) = c_0 + \\sum_{n=1}^{\\infty}\\frac{a_n-jb_n}{2}e^{jn\\omega t} + \\sum_{n = -\\infty}^{-1} \\frac{a_n - jb_n}{2}e^{jn\\omega t}\\ 合并得到:\\ \\qquad\\qquad f(t) = \\sum_{n=-\\infty}^{\\infty}\\frac{a_n - jb_n}{2}e^{jn\\omega t}\\ 令:\\ \\qquad\\qquad A_n = \\frac{a_n - jb_n}{2}\\ f(t) = \\sum_{n=-\\infty}^{\\infty}A_ne^{jn\\omega t}\\ $$ 在 4. 中得到 Fourier 级数, 再两边同时 乘以 $e^{-jk\\omega t}$ 并在一个周期内积分得到: $$ \\int_{0}^{T}f(t)e^{-jn\\omega t}dt = \\int_{0}^{T}\\sum^{+\\infty}_{n = -\\infty}A_ne^{j(n-k)\\omega t}dt\\ \\int_0^Tf(t)e^{-jn\\omega t}dt = A_nT\\ A_n = \\frac{1}{T}\\int_0^Tf(t)e^{-jn\\omega t}dt $$ ","date":"2022-12-30","objectID":"/fourier/:0:3","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"4. Fourier Transform 1 $$ A_n = \\frac{1}{T}\\int_0^Tf(t)e^{-jn\\omega t}dt\\ F(\\omega) = \\lim_{T\\rightarrow \\infty}A_nT = \\int_0^\\infty f(t)e^{-jn\\omega t}dt\\qquad (Fourier Transform + )\\ \\lim_{T\\rightarrow \\infty}A_n = \\lim_{T\\rightarrow \\infty}\\frac{F(\\omega)}{T} = \\lim_{T\\rightarrow \\infty}\\frac{F(\\omega)\\cdot \\omega}{2\\pi}\\ $$ 结合 (19)(25) 得到 $$ f(t) = \\lim_{T\\rightarrow \\infty}\\sum^\\infty_{n=-\\infty}A_n e^{jn\\omega t} =\\lim_{T\\rightarrow \\infty}\\sum^\\infty_{n=-\\infty}\\frac{F(\\omega)\\cdot e^{jn\\omega t}}{2\\pi} d\\omega =\\frac{1}{2\\pi}\\int^\\infty_{-\\infty}F(\\omega)\\cdot e^{jn\\omega t}d\\omega \\qquad (Fourier Transform -)\\ $$ ","date":"2022-12-30","objectID":"/fourier/:0:4","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"5. Convolution Theorem 定理描述 $$ 设:f_1(t) 的Fourier变换为F_1(\\omega), f_2(t) 的Fourier变换为F_2(\\omega), \\ 那么:\\ 时域:\\ \\qquad\\qquad F[f_1(t)\\otimes f_2(t)] = F_1(\\omega)\\cdot F_2(\\omega)\\ 频域:\\ \\qquad\\qquad F[f_1(t)\\cdot f_2(t)] = \\frac{1}{2\\pi}F_1(\\omega)\\otimes F_2(\\omega)\\ $$ ","date":"2022-12-30","objectID":"/fourier/:0:5","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"6. Fourier 时移性质 $$ F[f(t)] = F(\\omega) \\qquad则: F[f(t - \\tau)] = F(\\omega)e^{-jn\\omega \\tau} $$ 证明: $$ F[f(t - \\tau)] = \\int^{+\\infty}{-\\infty}f(t-\\tau)e^{-jn\\omega t}dt\\ $$ 令 $x= t - \\tau:$ $$ F[f(t - \\tau)] = \\int^{+\\infty}{-\\infty}f(x)e^{-jn\\omega (x+\\tau)}dx =e^{jn\\omega\\tau}\\int^{+\\infty}_{-\\infty}f(x)e^{-jn\\omega x}dx = F(\\omega)\\cdot e^{jn\\omega\\tau} $$ ","date":"2022-12-30","objectID":"/fourier/:0:6","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"7. Convolution Theorem 证明 定义卷积运算 $$ f_1(t)\\otimes f_1(t) = \\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t - \\tau)d\\tau\\ $$ 将 (35) 带入(24) $$ F[f_1(t)\\otimes f_1(t)] = \\int_{-\\infty}^{+\\infty}[\\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t - \\tau)d\\tau]e^{-jn\\omega t}dt\\ = \\int_{-\\infty}^{+\\infty}f_1(\\tau)[\\int_{-\\infty}^{+\\infty}f_2(t - \\tau)e^{-jn\\omega t}dt]d\\tau \\qquad(调换积分顺序)\\ = \\int_{-\\infty}^{+\\infty}f_1(\\tau)F_2(\\omega)e^{-jn\\omega \\tau}d\\tau\\ = F_2(\\omega)\\cdot F_1(\\omega)\\ $$ ","date":"2022-12-30","objectID":"/fourier/:0:7","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"决策树.html ","date":"2022-12-30","objectID":"/cart_tree/:0:0","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"导入相关库 pandas：决策树的构建涉及到数据集的一些操作，利用pandas的DataFrame数据结构可以很好方便的完成 copy :在递归时浅拷贝会导致问题,使用copy.deepcopy()进行深拷贝 matplot.pyplot:绘制决策树的划分图像 import pandas as pd import copy import matplotlib.pyplot as plt import numpy as np from math import fabs ","date":"2022-12-30","objectID":"/cart_tree/:0:1","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"导入数据 input = [[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]] ","date":"2022-12-30","objectID":"/cart_tree/:0:2","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"定义回归树的节点类Node attrList 节点剩下的属性列表 Dataset 节点划分到的数据集 left/right 左右子树 c 叶节点的预测值 description 该节点的描述（可选） attr 该节点划分属性 s 划分属性的值 考虑到使用非二叉树，在每次寻找最优化分的时候算法复杂度太高，所以此时使用二叉树就OK class Node: def __init__(self, description=\"\", c = -1, Dataset=pd.DataFrame(), attrList=[]): self.attrList = attrList self.Dataset = Dataset self.left = None self.right = None self.c = c self.attr = \"\" self.s = -1 self.desciption = description ","date":"2022-12-30","objectID":"/cart_tree/:0:3","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"计算损失 $$\\ell = \\sum_{x_i \\in R_1(j,s)}(y_i-c_1)^2+\\sum_{x_i \\in R_2(j,s)}(y_i-c_2)^2$$ def loss(attr, s, data): D1 = data[data[attr] \u003c= s] D1_mean = D1['label'].std() * D1.size D2 = data[data[attr] \u003e s] D2_mean = D2['label'].std() * D2.size return D1_mean + D2_mean ","date":"2022-12-30","objectID":"/cart_tree/:0:4","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"最小化损失 $$ \\min_{j,s} ( \\min_{c_1} \\sum_{x_i \\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i \\in R_2(j,s)}(y_i-c_2)^2 ) $$ 此处数据集不大 且 为了实现起来简单就是用了遍历所有属性的值找到最小的损失，应该还有一些方法可以优化找到最小值的过程 def findOptDiv(root): losses = [] for attr in root.attrList: for s in root.Dataset[attr]: losses.append((loss(attr, s, root.Dataset), attr, s)) minLoss = min(losses) return minLoss ","date":"2022-12-30","objectID":"/cart_tree/:0:5","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"二叉树的构建 在以下情况返回IF len(attrList) == 0：此时所有属性已经划分完毕， 就以该集合所有样本的label的均值作预测值 Dataset.size == 1：此时该节点的样本仅有一个 就 以该样本的label值做预测值 ELSE 将样本按最优划分划分为两个集合D1，D2，并分别构建subTree def buildTree(root): # if root.Dataset.size() \u003c= 1: # description = \"leaf node\" # c_p = root.Dataset['label'].mean() # leaf = Node(description=description, c = c_p) # 如果样本集合中只有一个样本那么该节点为叶节点，该叶节点的预测值是该唯一样本的label if root.Dataset.size == 1: root.c = root.Dataset['label'] return # 如果已经将属性分完了，那么该节点为叶节点，剩下的样本集中label的期望为该叶节点的预测值 elif len(root.attrList) == 0: root.description = \"leaf node\" root.c = root.Dataset['label'].mean() return else: # 找到最优化分 (_, attr, s) = findOptDiv(root) # 将节点的划分属性设为找到的attr root.attr = copy.deepcopy(attr) # 将按属性attr划分该节点值划分值s设为最优的s root.s = copy.deepcopy(s) # 将样本集合按照找到的最优化分划分为D1， D2 D1 = copy.deepcopy(root.Dataset[root.Dataset[attr] \u003c= s]) D2 = copy.deepcopy(root.Dataset[root.Dataset[attr] \u003e s]) # 将划分该节点属性从属性集合中删除 list_notremoved = copy.deepcopy(root.attrList) root.attrList.remove(attr) list_removed = copy.deepcopy(root.attrList) root.attrList = copy.deepcopy(list_notremoved) # 构建左子树和右子树 root.left = Node(Dataset = D1, attrList=copy.deepcopy(list_removed)) root.right = Node(Dataset = D2, attrList=copy.deepcopy(list_removed)) buildTree(root.left) buildTree(root.right) return root ","date":"2022-12-30","objectID":"/cart_tree/:0:6","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"预测函数 def predict(x, root): while(len(root.attrList) != 0): if x[root.attr] \u003c root.s: root = root.left else: root = root.right return root.c ","date":"2022-12-30","objectID":"/cart_tree/:0:7","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"评估函数 def evaluate(data_test, root): accuracy = 0 for i in range(len(data_test)): res = predict(data_test.loc[i], root) # 将回归问题转为分类问题 res = .5 if res \u003e .5 else 0 accuracy += fabs(res - data_test.loc[i][\"label\"]) return 1 - accuracy / len(data_test) data = pd.DataFrame(input, columns=['密度','含糖率',\"label\"]) root = Node(Dataset=data, attrList = ['密度','含糖率']) root = buildTree(root) ","date":"2022-12-30","objectID":"/cart_tree/:0:8","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"可以大致看出决策过程 先看含糖率： 小于.13 小于.666 坏瓜 大于.666 好瓜 大于.13 小于.697 0.6的概率是好瓜 大于.697 1的概率是好瓜 print(root.attr,root.s) print(root.left.attr,root.left.s,root.left.left.c,root.left.right.c) print(root.right.attr,root.right.s,root.right.left.c,root.right.right.c) 含糖率 0.103 密度 0.666 0.0 0.0 密度 0.697 0.6363636363636364 1.0 ","date":"2022-12-30","objectID":"/cart_tree/:0:9","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"可视化和评估模型表现 s1 = root.s s21 = root.left.s s22 = root.right.s plt.plot([.2,.8],[s1,s1],'r-') plt.plot([s21,s21],[0,s1],'r-') plt.plot([s22,s22],[s1,.5],'r-') for plot in input: if plot[2] == 0: c = 'red' else: c = 'green' plt.scatter(plot[0],plot[1],c=c) print(\"THE ACCURACY OF REGRESSION TREE IS {}\".format(evaluate(data, root))) THE ACCURACY OF REGRESSION TREE IS 0.6176470588235294 ","date":"2022-12-30","objectID":"/cart_tree/:1:0","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"🏠 关于本站 resilient, 英语词汇, 意思是 “能够从困难或挫折中恢复或弹回的” quijotesco, 西班牙语词汇, 意思是 “像堂吉诃德一样热情有远见的人，受到高尚而不切实际的理想所激励” 取 quijotesco, 的前半部分和 resilient 的后半部分结合起来，形成一个新的词汇, quijolient 来自 new bing(chatGPT-4)的设计 我希望成为一个 resilient 和 resilient 的人, 所以我将小站取名为 Quijolient ! 我会在这里记录我的所见所想😎, 记录我努力实现的每一个想法🧠 记录我一步一步靠近理想🔆, 记录我正在努力的生活💕 ","date":"2022-12-30","objectID":"/about/:1:0","tags":null,"title":"关于我和这个小站","uri":"/about/"},{"categories":null,"content":"👨‍💻 博主是谁 _quijo 一个小镇做题家, CS本科, 喜欢说怪话 Godot Developer ","date":"2022-12-30","objectID":"/about/:2:0","tags":null,"title":"关于我和这个小站","uri":"/about/"},{"categories":null,"content":"⛹ 兴趣爱好 乒乓球❎, 轮滑❎, 玩游戏 \u0026 游戏开发✅, 上网冲浪✅ ","date":"2022-12-30","objectID":"/about/:3:0","tags":null,"title":"关于我和这个小站","uri":"/about/"},{"categories":null,"content":"🛻 Game Jam组队 特别想参加 Game Jam 但是没有志同道合的小伙伴🤦‍♂️，非常想组队但是社恐，不过山水总相逢，来日皆可期，总会遇见你们的🤡！ ","date":"2022-12-30","objectID":"/about/:4:0","tags":null,"title":"关于我和这个小站","uri":"/about/"},{"categories":null,"content":"📬 联系我呀 QQ: 1085036164 Email: herrn.xu@outlook.com ","date":"2022-12-30","objectID":"/about/:5:0","tags":null,"title":"关于我和这个小站","uri":"/about/"}]